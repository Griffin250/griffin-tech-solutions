<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>0x261 Strings</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part30.htm">&lt; Previous</a><span> | </span><a href="../hacking-the-art-of-exploitation.html">Contents</a><span> | </span><a href="part32.htm">Next &gt;</a></p><p class="s32" style="padding-left: 91pt;text-indent: 0pt;text-align: justify;"><a name="bookmark21">0x261 Strings</a></p><p style="padding-top: 7pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">The value <span class="s31">&quot;Hello, world!\n&quot; </span>passed to the <span class="s31">printf() </span>function in the previous program is a string—technically, a character array. In C, an <span class="s27">array </span>is simply a list of <span class="s27">n </span>elements of a specific data type. A 20-character array is simply 20 adjacent characters located in memory. Arrays are also referred to as <span class="s27">buffers</span>. The char_array.c program is an example of a character array.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s40" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">char_array.c</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_115.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">#include &lt;stdio.h&gt; int main()</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">{</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;line-height: 107%;text-align: left;">char str_a[20]; str_a[0] = &#39;H&#39;;</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;text-align: left;">str_a[1] = &#39;e&#39;;</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;text-align: left;">str_a[2] = &#39;l&#39;;</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;text-align: left;">str_a[3] = &#39;l&#39;;</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;text-align: left;">str_a[4] = &#39;o&#39;;</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;text-align: left;">str_a[5] = &#39;,&#39;;</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;text-align: left;">str_a[6] = &#39; &#39;;</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;text-align: left;">str_a[7] = &#39;w&#39;;</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;text-align: left;">str_a[8] = &#39;o&#39;;</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;text-align: left;">str_a[9] = &#39;r&#39;;</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;text-align: left;">str_a[10] = &#39;l&#39;;</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;text-align: left;">str_a[11] = &#39;d&#39;;</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;text-align: left;">str_a[12] = &#39;!&#39;;</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;line-height: 107%;text-align: left;">str_a[13] = &#39;\n&#39;; str_a[14] = 0; printf(str_a);</p><p class="s31" style="padding-bottom: 3pt;padding-left: 91pt;text-indent: 0pt;line-height: 10pt;text-align: left;">}</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_116.png"/></span></p><p style="padding-top: 7pt;padding-left: 91pt;text-indent: 18pt;line-height: 108%;text-align: justify;">The GCC compiler can also be given the <span class="s31">-o </span>switch to define the output file to compile to. This switch is used below to compile the program into an executable binary called <span class="s31">char_array</span>.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_117.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">reader@hacking:~/booksrc $ gcc -o char_array char_array.c reader@hacking:~/booksrc $ ./char_array</p><p class="s31" style="padding-bottom: 2pt;padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">Hello, world! reader@hacking:~/booksrc $</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_118.png"/></span></p><p style="padding-top: 7pt;padding-left: 91pt;text-indent: 18pt;line-height: 107%;text-align: left;">In the preceding program, a 20-element character array is defined as <span class="s31">str_a</span>, and each element of the array is written to, one by one. Notice that the number begins at 0, as opposed to 1. Also notice that the last character is a 0. (This is also called a <span class="s27">null byte</span>.) The character array was defined, so 20 bytes are allocated for it, but only 12 of these bytes are actually used. The null byte</p><p style="padding-top: 3pt;padding-left: 91pt;text-indent: 0pt;line-height: 108%;text-align: left;">at the end is used as a delimiter character to tell any function that is dealing with the string to stop operations right there. The remaining extra bytes are just garbage and will be ignored. If a null byte is inserted in the fifth element of the character array, only the characters <span class="s31">Hello </span>would be printed by the <span class="s31">printf() </span>function.</p><p style="padding-left: 91pt;text-indent: 18pt;line-height: 108%;text-align: left;">Since setting each character in a character array is painstaking and strings are used fairly often, a set of standard functions was created for string manipulation. For example, the <span class="s31">strcpy() </span>function will copy a string from a source to a destination, iterating through the source string and copying each byte to the destination (and stopping after it copies the null termination byte). The order of the function’s arguments is similar to Intel assembly syntax: destination first and then source. The char_array.c program can be rewritten using <span class="s31">strcpy() </span>to accomplish the same thing using the string library. The next version of the char_array program shown below includes string.h since it uses a string function.</p><p class="s40" style="padding-top: 9pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">char_array2.c</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_119.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">#include &lt;stdio.h&gt; #include &lt;string.h&gt;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">int main() {</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;text-align: left;">char str_a[20];</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-top: 4pt;padding-left: 104pt;text-indent: 0pt;line-height: 107%;text-align: left;">strcpy(str_a, &quot;Hello, world!\n&quot;); printf(str_a);</p><p class="s31" style="padding-bottom: 3pt;padding-left: 91pt;text-indent: 0pt;line-height: 10pt;text-align: left;">}</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_120.png"/></span></p><p style="padding-top: 7pt;padding-left: 91pt;text-indent: 18pt;line-height: 108%;text-align: left;">Let’s take a look at this program with GDB. In the output below, the compiled program is opened with GDB and breakpoints are set before, in, and after the <span class="s31">strcpy() </span>call shown in bold. The debugger will pause the program at each breakpoint, giving us a chance to examine registers and memory. The <span class="s31">strcpy() </span>function’s code comes from a shared library, so the breakpoint in this function can’t actually be set until the program is executed.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_121.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">reader@hacking:~/booksrc $ gcc -g -o char_array2 char_array2.c reader@hacking:~/booksrc $ gdb -q ./char_array2</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">Using host libthread_db library &quot;/lib/tls/i686/cmov/libthread_db.so.1&quot;. (gdb) list</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">1   #include &lt;stdio.h&gt;</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">2   #include &lt;string.h&gt;</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">3</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">4   int main() {</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">5     char str_a[20];</p><p class="s46" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">6</p><p class="s46" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">7     strcpy(str_a, &quot;Hello, world!\n&quot;);</p><p class="s46" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">8     printf(str_a);</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">9   }</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">(gdb) break 6</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">Breakpoint 1 at 0x80483c4: file char_array2.c, line 6. (gdb) break strcpy</p><p class="s31" style="padding-top: 2pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">Function &quot;strcpy&quot; not defined.</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">Make breakpoint pending on future shared library load? (y or [n]) y Breakpoint 2 (strcpy) pending.</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">(gdb) break 8</p><p class="s31" style="padding-bottom: 3pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">Breakpoint 3 at 0x80483d7: file char_array2.c, line 8. (gdb)</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_122.png"/></span></p><p style="padding-top: 6pt;padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: left;">When the program is run, the <span class="s31">strcpy() </span>breakpoint is resolved. At each breakpoint, we’re going to look at EIP and the instructions it points to. Notice that the memory location for EIP at the middle breakpoint is different.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_123.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">(gdb) run</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">Starting program: /home/reader/booksrc/char_array2 Breakpoint 4 at 0xb7f076f4</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">Pending breakpoint &quot;strcpy&quot; resolved</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">Breakpoint 1, main () at char_array2.c:7</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">7     strcpy(str_a, &quot;Hello, world!\n&quot;); (gdb) i r eip</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">eip      0x80483c4    0x80483c4 &lt;main+16&gt; (gdb) x/5i $eip</p><table style="border-collapse:collapse;margin-left:88.94pt" cellspacing="0"><tr style="height:10pt"><td style="width:96pt"><p class="s42" style="padding-left: 2pt;text-indent: 0pt;line-height: 9pt;text-align: left;">0x80483c4 &lt;main+16&gt;:</p></td><td style="width:32pt"><p class="s42" style="padding-left: 8pt;text-indent: 0pt;line-height: 9pt;text-align: left;">mov</p></td><td style="width:123pt"><p class="s42" style="padding-left: 6pt;text-indent: 0pt;line-height: 9pt;text-align: left;">DWORD PTR [esp+4],0x80484c4</p></td></tr><tr style="height:11pt"><td style="width:96pt"><p class="s42" style="padding-left: 2pt;text-indent: 0pt;line-height: 10pt;text-align: left;">0x80483cc &lt;main+24&gt;:</p></td><td style="width:32pt"><p class="s42" style="padding-left: 8pt;text-indent: 0pt;line-height: 10pt;text-align: left;">lea</p></td><td style="width:123pt"><p class="s42" style="padding-left: 6pt;text-indent: 0pt;line-height: 10pt;text-align: left;">eax,[ebp-40]</p></td></tr><tr style="height:11pt"><td style="width:96pt"><p class="s42" style="padding-left: 2pt;text-indent: 0pt;line-height: 10pt;text-align: left;">0x80483cf &lt;main+27&gt;:</p></td><td style="width:32pt"><p class="s42" style="padding-left: 8pt;text-indent: 0pt;line-height: 10pt;text-align: left;">mov</p></td><td style="width:123pt"><p class="s42" style="padding-left: 6pt;text-indent: 0pt;line-height: 10pt;text-align: left;">DWORD PTR [esp],eax</p></td></tr><tr style="height:11pt"><td style="width:96pt"><p class="s42" style="padding-left: 2pt;text-indent: 0pt;line-height: 9pt;text-align: left;">0x80483d2 &lt;main+30&gt;:</p></td><td style="width:32pt"><p class="s42" style="padding-left: 8pt;text-indent: 0pt;line-height: 9pt;text-align: left;">call</p></td><td style="width:123pt"><p class="s42" style="padding-left: 6pt;text-indent: 0pt;line-height: 9pt;text-align: left;">0x80482c4 &lt;strcpy@plt&gt;</p></td></tr><tr style="height:11pt"><td style="width:96pt"><p class="s42" style="padding-left: 2pt;text-indent: 0pt;line-height: 9pt;text-align: left;">0x80483d7 &lt;main+35&gt;:</p></td><td style="width:32pt"><p class="s42" style="padding-left: 8pt;text-indent: 0pt;line-height: 9pt;text-align: left;">lea</p></td><td style="width:123pt"><p class="s42" style="padding-left: 6pt;text-indent: 0pt;line-height: 9pt;text-align: left;">eax,[ebp-40]</p></td></tr><tr style="height:11pt"><td style="width:96pt"><p class="s42" style="padding-left: 2pt;text-indent: 0pt;line-height: 10pt;text-align: left;">(gdb) continue</p></td><td style="width:32pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td><td style="width:123pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td></tr><tr style="height:10pt"><td style="width:96pt"><p class="s42" style="padding-left: 2pt;text-indent: 0pt;line-height: 9pt;text-align: left;">Continuing.</p></td><td style="width:32pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td><td style="width:123pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td></tr></table><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">Breakpoint 4, 0xb7f076f4 in strcpy () from /lib/tls/i686/cmov/libc.so.6 (gdb) i r eip</p><p class="s46" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">eip      0xb7f076f4   0xb7f076f4 &lt;strcpy+4&gt;</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">(gdb) x/5i $eip</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">0xb7f076f4 &lt;strcpy+4&gt;: mov  esi,DWORD PTR [ebp+8] 0xb7f076f7 &lt;strcpy+7&gt;: mov  eax,DWORD PTR [ebp+12] 0xb7f076fa &lt;strcpy+10&gt;: mov  ecx,esi</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 106%;text-align: justify;">0xb7f076fc &lt;strcpy+12&gt;: sub  ecx,eax 0xb7f076fe &lt;strcpy+14&gt;: mov  edx,eax (gdb) continue</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">Continuing.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">Breakpoint 3, main () at char_array2.c:8</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">8     printf(str_a); (gdb) i r eip</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">eip      0x80483d7    0x80483d7 &lt;main+35&gt; (gdb) x/5i $eip</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 106%;text-align: left;">0x80483d7 &lt;main+35&gt;:  lea  eax,[ebp-40] 0x80483da &lt;main+38&gt;:  mov  DWORD PTR [esp],eax 0x80483dd &lt;main+41&gt;:  call  0x80482d4 &lt;printf@plt&gt; 0x80483e2 &lt;main+46&gt;:  leave</p><p class="s31" style="padding-bottom: 2pt;padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">0x80483e3 &lt;main+47&gt;:  ret (gdb)</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_124.png"/></span></p><p style="padding-top: 3pt;padding-left: 91pt;text-indent: 18pt;line-height: 108%;text-align: left;">The address in EIP at the middle breakpoint is different because the code for the <span class="s31">strcpy() </span>function comes from a loaded library. In fact, the debugger shows EIP for the middle breakpoint in the <span class="s31">strcpy() </span>function, while EIP at the other two breakpoints is in the <span class="s31">main() </span>function. I’d like to point out that EIP is able to travel from the main code to the <span class="s31">strcpy() </span>code and back again. Each time a function is called, a record is kept on a data</p><p style="padding-left: 91pt;text-indent: 0pt;text-align: left;">structure simply called the stack. The <span class="s27">stack </span>lets EIP return through long chains of function calls. In GDB, the <span class="s31">bt </span>command can be used to backtrace the stack. In the output below, the stack backtrace is shown at each breakpoint.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_125.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">(gdb) run</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">The program being debugged has been started already. Start it from the beginning? (y or n) y</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">Starting program: /home/reader/booksrc/char_array2 Error in re-setting breakpoint 4:</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">Function &quot;strcpy&quot; not defined.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">Breakpoint 1, main () at char_array2.c:7</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">7     strcpy(str_a, &quot;Hello, world!\n&quot;); (gdb) bt</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">#0 main () at char_array2.c:7 (gdb) cont</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 10pt;text-align: left;">Continuing.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">Breakpoint 4, 0xb7f076f4 in strcpy () from /lib/tls/i686/cmov/libc.so.6 (gdb) bt</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">#0 0xb7f076f4 in strcpy () from /lib/tls/i686/cmov/libc.so.6 #1 0x080483d7 in main () at char_array2.c:7</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">(gdb) cont Continuing.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">Breakpoint 3, main () at char_array2.c:8</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">8     printf(str_a); (gdb) bt</p><p class="s31" style="padding-bottom: 2pt;padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">#0 main () at char_array2.c:8 (gdb)</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_126.png"/></span></p><p style="padding-top: 7pt;padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: left;">At the middle breakpoint, the backtrace of the stack shows its record of the <span class="s31">strcpy() </span>call. Also, you may notice that the <span class="s31">strcpy() </span>function is at a slightly different address during the second run. This is due to an exploit protection method that is turned on by default in the Linux kernel since 2.6.11. We will talk about this protection in more detail later.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part30.htm">&lt; Previous</a><span> | </span><a href="../hacking-the-art-of-exploitation.html">Contents</a><span> | </span><a href="part32.htm">Next &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
