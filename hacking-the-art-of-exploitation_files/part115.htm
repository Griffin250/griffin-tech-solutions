<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>0x510 Assembly vs. C</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part114.htm">&lt; Previous</a><span> | </span><a href="../hacking-the-art-of-exploitation.html">Contents</a><span> | </span><a href="part116.htm">Next &gt;</a></p><p class="s30" style="padding-top: 3pt;padding-left: 37pt;text-indent: 0pt;text-align: left;"><a name="bookmark104">0x510 Assembly vs. C</a></p><p style="padding-top: 7pt;padding-left: 91pt;text-indent: 0pt;line-height: 108%;text-align: left;">The shellcode bytes are actually architecture-specific machine instructions, so shellcode is written using the assembly language. Writing a program in assembly is different than writing it in C, but many of the principles are similar. The operating system manages things like input, output, process control, file access, and network communication in the kernel. Compiled C programs ultimately perform these tasks by making system calls to the kernel. Different operating systems have different sets of system calls.</p><p style="padding-left: 91pt;text-indent: 17pt;line-height: 107%;text-align: justify;">In C, standard libraries are used for convenience and portability. A C pro- gram that uses <span class="s31">printf() </span>to output a string can be compiled for many different systems, since the library knows the appropriate system calls for various archi- tectures. A C program compiled on an <span class="s27">x</span>86 processor will produce <span class="s27">x</span>86 assembly language.</p><p style="padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: left;">By definition, assembly language is already specific to a certain processor architecture, so portability is impossible. There are no standard libraries; instead, kernel system calls have to be made directly. To begin our comparison, let’s write a simple C program, then rewrite it in <span class="s27">x</span>86 assembly.</p><p class="s40" style="padding-top: 8pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">helloworld.c</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_829.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">#include &lt;stdio.h&gt; int main() {</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;text-align: left;">printf(&quot;Hello, world!\n&quot;); return 0;</p><p class="s31" style="padding-bottom: 3pt;padding-left: 91pt;text-indent: 0pt;line-height: 10pt;text-align: left;">}</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_830.png"/></span></p><p style="padding-top: 7pt;padding-left: 91pt;text-indent: 17pt;line-height: 106%;text-align: justify;">When the compiled program is run, execution flows through the standard I/O library, eventually making a system call to write the string <span class="s27">Hello, world! </span>to the screen. The strace program is used to trace a program’s system calls. Used on the compiled helloworld program, it shows every system call that program makes.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_831.png"/></span></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">reader@hacking:~/booksrc $ gcc helloworld.c reader@hacking:~/booksrc $ strace ./a.out execve(&quot;./a.out&quot;, [&quot;./a.out&quot;], [/* 27 vars */]) = 0 brk(0)                  = 0x804a000</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">access(&quot;/etc/ld.so.nohwcap&quot;, F_OK)   = -1 ENOENT (No such file or directory) mmap2(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7ef6000</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">access(&quot;/etc/ld.so.preload&quot;, R_OK)    = -1 ENOENT (No such file or directory) open(&quot;/etc/ld.so.cache&quot;, O_RDONLY)    = 3</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">fstat64(3, {st_mode=S_IFREG|0644, st_size=61323, ...}) = 0 mmap2(NULL, 61323, PROT_READ, MAP_PRIVATE, 3, 0) = 0xb7ee7000</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">close(3)                 = 0</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">access(&quot;/etc/ld.so.nohwcap&quot;, F_OK)    = -1 ENOENT (No such file or directory) open(&quot;/lib/tls/i686/cmov/libc.so.6&quot;, O_RDONLY) = 3</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">read(3, &quot;\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\20Z\1\000&quot;..., 512) = 512 fstat64(3, {st_mode=S_IFREG|0755, st_size=1248904, ...}) = 0</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">mmap2(NULL, 1258876, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0xb7db3000 mmap2(0xb7ee0000, 16384, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x12c) =</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 9pt;text-align: left;">0xb7ee0000</p><p class="s31" style="padding-top: 2pt;padding-left: 19pt;text-indent: 0pt;line-height: 10pt;text-align: left;">mmap2(0xb7ee4000, 9596, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) =</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 10pt;text-align: left;">0xb7ee4000</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">close(3)                 = 0</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7db2000</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">set_thread_area({entry_number:-1 -&gt; 6, base_addr:0xb7db26b0, limit:1048575, seg_32bit:1, contents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1}) = 0 mprotect(0xb7ee0000, 8192, PROT_READ)  = 0</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">munmap(0xb7ee7000, 61323)       = 0</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">fstat64(1, {st_mode=S_IFCHR|0620, st_rdev=makedev(136, 2), ...}) = 0</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7ef5000</p><p class="s46" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">write(1, &quot;Hello, world!\n&quot;, 13Hello, world!</p><p class="s46" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">)     = 13</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">exit_group(0)              = ?</p><p class="s31" style="padding-bottom: 3pt;padding-left: 19pt;text-indent: 0pt;text-align: left;">Process 11528 detached reader@hacking:~/booksrc $</p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_832.png"/></span></p><p style="padding-top: 7pt;padding-left: 109pt;text-indent: 0pt;text-align: left;">As you can see, the compiled program does more than just print a string.</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 108%;text-align: left;">The system calls at the start are setting up the environment and memory for the program, but the important part is the <span class="s31">write() </span>syscall shown in bold. This is what actually outputs the string.</p><p style="padding-left: 91pt;text-indent: 18pt;line-height: 108%;text-align: left;">The Unix manual pages (accessed with the <span class="s31">man </span>command) are sep- arated into sections. Section 2 contains the manual pages for system calls, so <span class="s31">man 2 write </span>will describe the use of the <span class="s31">write() </span>system call:</p><p class="s40" style="padding-top: 8pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">Man Page for the write() System Call</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_833.png"/></span></p><p class="s31" style="padding-top: 1pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">WRITE(2)         Linux Programmer&#39;s Manual WRITE(2)</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-top: 4pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">NAME</p><p class="s31" style="padding-left: 121pt;text-indent: 0pt;text-align: left;">write - write to a file descriptor</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-top: 4pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">SYNOPSIS</p><p class="s31" style="padding-left: 121pt;text-indent: 0pt;text-align: left;">#include &lt;unistd.h&gt;</p><p class="s31" style="padding-top: 2pt;padding-left: 91pt;text-indent: 29pt;line-height: 21pt;text-align: left;">ssize_t write(int fd, const void *buf, size_t count); DESCRIPTION</p><p class="s31" style="padding-left: 121pt;text-indent: 0pt;line-height: 8pt;text-align: left;">write() writes up to count bytes to the file referenced by the file</p><p class="s31" style="padding-bottom: 3pt;padding-left: 121pt;text-indent: 0pt;text-align: left;">descriptor fd from the buffer starting at buf. POSIX requires that a read() which can be proved to occur after a write() returns the new data. Note that not all file systems are POSIX conforming.</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_834.png"/></span></p><p style="padding-top: 7pt;padding-left: 91pt;text-indent: 18pt;line-height: 108%;text-align: left;">The strace output also shows the arguments for the syscall. The <span class="s31">buf </span>and <span class="s31">count </span>arguments are a pointer to our string and its length. The <span class="s31">fd </span>argument of <span class="s31">1 </span>is a special standard file descriptor. File descriptors are used for almost everything in Unix: input, output, file access, network sockets, and so on. A file descriptor is similar to a number given out at a coat check. Opening a file descriptor is like checking in your coat, since you are given a number that can later be used to reference your coat. The first three file</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 108%;text-align: justify;">descriptor numbers (0, 1, and 2) are automatically used for standard input, output, and error. These values are standard and have been defined in several places, such as the /usr/include/unistd.h file on the following page.</p><p class="s40" style="padding-top: 4pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">From /usr/include/unistd.h</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_835.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">/* Standard file descriptors. */</p><p class="s31" style="padding-bottom: 2pt;padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">#define STDIN_FILENO  0 /* Standard input. */ #define STDOUT_FILENO 1 /* Standard output. */ #define STDERR_FILENO 2 /* Standard error output. */</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_836.png"/></span></p><p style="padding-top: 8pt;padding-left: 91pt;text-indent: 18pt;line-height: 108%;text-align: left;">Writing bytes to standard output’s file descriptor of <span class="s31">1 </span>will print the bytes; reading from standard input’s file descriptor of <span class="s31">0 </span>will input bytes. The standard error file descriptor of <span class="s31">2 </span>is used to display the error or debugging messages that can be filtered from the standard output.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part114.htm">&lt; Previous</a><span> | </span><a href="../hacking-the-art-of-exploitation.html">Contents</a><span> | </span><a href="part116.htm">Next &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
