<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>0x340 Overflows in Other Segments</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part57.htm">&lt; Previous</a><span> | </span><a href="../hacking-the-art-of-exploitation.html">Contents</a><span> | </span><a href="part59.htm">Next &gt;</a></p><p class="s30" style="padding-left: 37pt;text-indent: 0pt;text-align: left;"><a name="bookmark48">0x340 Overflows in Other Segments</a></p><p style="padding-top: 7pt;padding-left: 91pt;text-indent: 0pt;line-height: 108%;text-align: left;">Buffer overflows can happen in other memory segments, like heap and bss. As in auth_overflow.c, if an important variable is located after a buffer vulnerable to an overflow, the program’s control flow can be altered. This is true regardless of the memory segment these variables reside in; however,</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 108%;text-align: left;">the control tends to be quite limited. Being able to find these control points and learning to make the most of them just takes some experience and creative thinking. While these types of overflows aren’t as standardized as stack-based overflows, they can be just as effective.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part57.htm">&lt; Previous</a><span> | </span><a href="../hacking-the-art-of-exploitation.html">Contents</a><span> | </span><a href="part59.htm">Next &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
