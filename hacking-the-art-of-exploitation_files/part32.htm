<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>0x262 Signed, Unsigned, Long, and Short</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part31.htm">&lt; Previous</a><span> | </span><a href="../hacking-the-art-of-exploitation.html">Contents</a><span> | </span><a href="part33.htm">Next &gt;</a></p><p class="s32" style="padding-left: 91pt;text-indent: 0pt;text-align: left;"><a name="bookmark22">0x262 Signed, Unsigned, Long, and Short</a></p><p style="padding-top: 6pt;padding-left: 91pt;text-indent: 0pt;line-height: 108%;text-align: left;">By default, numerical values in C are signed, which means they can be both negative and positive. In contrast, unsigned values don’t allow negative num- bers. Since it’s all just memory in the end, all numerical values must be stored in binary, and unsigned values make the most sense in binary. A 32-bit unsigned integer can contain values from 0 (all binary 0s) to 4,294,967,295 (all binary 1s). A 32-bit signed integer is still just 32 bits, which means it can</p><p style="padding-top: 5pt;padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">only be in one of 2<span class="s41">32</span> possible bit combinations. This allows 32-bit signed integers to range from <span class="s47"></span>2,147,483,648 to 2,147,483,647. Essentially, one of the bits is a flag marking the value positive or negative. Positively signed values look the same as unsigned values, but negative numbers are stored differently using a method called two’s complement. <span class="s27">Two’s complement </span>represents neg- ative numbers in a form suited for binary adders—when a negative value in two’s complement is added to a positive number of the same magnitude, the result will be 0. This is done by first writing the positive number in binary, then inverting all the bits, and finally adding 1. It sounds strange, but it works and allows negative numbers to be added in combination with positive numbers using simple binary adders.</p><p style="padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: left;">This can be explored quickly on a smaller scale using <span class="s31">pcalc</span>, a simple programmer’s calculator that displays results in decimal, hexadecimal, and binary formats. For simplicity’s sake, 8-bit numbers are used in this example.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_127.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">reader@hacking:~/booksrc $ pcalc 0y01001001</p><p class="s31" style="padding-left: 125pt;text-indent: 0pt;text-align: left;">73       0x49      0y1001001</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">reader@hacking:~/booksrc $ pcalc 0y10110110 + 1</p><p class="s31" style="padding-left: 125pt;text-indent: 0pt;text-align: left;">183       0xb7      0y10110111</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">reader@hacking:~/booksrc $ pcalc 0y01001001 + 0y10110111</p><p class="s31" style="padding-left: 125pt;text-indent: 0pt;text-align: left;">256       0x100      0y100000000</p><p class="s31" style="padding-bottom: 3pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">reader@hacking:~/booksrc $</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_128.png"/></span></p><p style="padding-top: 7pt;padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: left;">First, the binary value 01001001 is shown to be positive 73. Then all the bits are flipped, and 1 is added to result in the two’s complement representa- tion for negative 73, 10110111. When these two values are added together, the result of the original 8 bits is 0. The program <span class="s31">pcalc </span>shows the value 256 because it’s not aware that we’re only dealing with 8-bit values. In a binary adder, that carry bit would just be thrown away because the end of the vari- able’s memory would have been reached. This example might shed some light on how two’s complement works its magic.</p><p style="padding-left: 91pt;text-indent: 18pt;line-height: 108%;text-align: left;">In C, variables can be declared as unsigned by simply prepending the keyword <span class="s31">unsigned </span>to the declaration. An unsigned integer would be declared with <span class="s31">unsigned int</span>. In addition, the size of numerical variables can be extended or shortened by adding the keywords <span class="s31">long </span>or <span class="s31">short</span>. The actual sizes will vary depending on the architecture the code is compiled for. The language of C provides a macro called <span class="s31">sizeof() </span>that can determine the size of certain data types. This works like a function that takes a data type as its input and returns the size of a variable declared with that data type for the target architecture. The datatype_sizes.c program explores the sizes of various data types, using the <span class="s31">sizeof() </span>function.</p><p class="s40" style="padding-top: 9pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">datatype_sizes.c</p><p style="text-indent: 0pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_129.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 21pt;text-align: left;">#include &lt;stdio.h&gt; int main() {</p><p class="s31" style="padding-left: 30pt;text-indent: 0pt;line-height: 8pt;text-align: center;">printf(&quot;The &#39;int&#39; data type is\t\t %d bytes\n&quot;, sizeof(int));</p><p class="s31" style="padding-top: 2pt;padding-left: 103pt;text-indent: 0pt;line-height: 106%;text-align: left;">printf(&quot;The &#39;unsigned int&#39; data type is\t %d bytes\n&quot;, sizeof(unsigned int)); printf(&quot;The &#39;short int&#39; data type is\t %d bytes\n&quot;, sizeof(short int)); printf(&quot;The &#39;long int&#39; data type is\t %d bytes\n&quot;, sizeof(long int)); printf(&quot;The &#39;long long int&#39; data type is %d bytes\n&quot;, sizeof(long long int)); printf(&quot;The &#39;float&#39; data type is\t %d bytes\n&quot;, sizeof(float));</p><p class="s31" style="padding-left: 103pt;text-indent: 0pt;text-align: left;">printf(&quot;The &#39;char&#39; data type is\t\t %d bytes\n&quot;, sizeof(char));</p><p class="s31" style="padding-bottom: 3pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">}</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_130.png"/></span></p><p style="padding-top: 8pt;padding-left: 91pt;text-indent: 18pt;line-height: 110%;text-align: justify;">This piece of code uses the <span class="s31">printf() </span>function in a slightly different way. It uses something called a format specifier to display the value returned from the <span class="s31">sizeof() </span>function calls. Format specifiers will be explained in depth later, so for now, let’s just focus on the program’s output.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_131.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: justify;">reader@hacking:~/booksrc $ gcc datatype_sizes.c reader@hacking:~/booksrc $ ./a.out</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: justify;">The &#39;int&#39; data type is     4 bytes The &#39;unsigned int&#39; data type is 4 bytes The &#39;short int&#39; data type is  2 bytes The &#39;long int&#39; data type is   4 bytes The &#39;long long int&#39; data type is 8 bytes The &#39;float&#39; data type is    4 bytes</p><p class="s31" style="padding-bottom: 2pt;padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: justify;">The &#39;char&#39; data type is    1 bytes reader@hacking:~/booksrc $</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_132.png"/></span></p><p style="padding-top: 7pt;padding-left: 91pt;text-indent: 18pt;line-height: 108%;text-align: justify;">As previously stated, both signed and unsigned integers are four bytes in size on the <span class="s27">x </span>86 architecture. A float is also four bytes, while a char only needs a single byte. The <span class="s31">long </span>and <span class="s31">short </span>keywords can also be used with floating-point variables to extend and shorten their sizes.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part31.htm">&lt; Previous</a><span> | </span><a href="../hacking-the-art-of-exploitation.html">Contents</a><span> | </span><a href="part33.htm">Next &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
