<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>0x6c4 A First Attempt</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part160.htm">&lt; Previous</a><span> | </span><a href="../hacking-the-art-of-exploitation.html">Contents</a><span> | </span><a href="part162.htm">Next &gt;</a></p><p class="s32" style="padding-left: 91pt;text-indent: 0pt;text-align: left;"><a name="bookmark148">0x6c4 A First Attempt</a></p><p style="padding-top: 6pt;padding-left: 91pt;text-indent: 0pt;line-height: 108%;text-align: left;">In fact, I had written this chapter before linux-gate was fixed in the Linux kernel, so I had to hack together an ASLR bypass. My first thought was to leverage the <span class="s31">execl() </span>family of functions. We’ve been using the <span class="s31">execve() </span>function in our shellcode to spawn a shell, and if you pay close attention (or just read the man page), you’ll notice the <span class="s31">execve() </span>function replaces the currently running process with the new process image.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_1204.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">EXEC(3)        Linux Programmer&#39;s Manual</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-top: 4pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">NAME</p><p class="s31" style="padding-left: 121pt;text-indent: 0pt;text-align: left;">execl, execlp, execle, execv, execvp - execute a file</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-top: 4pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">SYNOPSIS</p><p class="s31" style="padding-left: 121pt;text-indent: 0pt;line-height: 206%;text-align: left;">#include &lt;unistd.h&gt; extern char **environ;</p><p class="s31" style="padding-left: 121pt;text-indent: 0pt;text-align: left;">int execl(const char *path, const char *arg, ...); int execlp(const char *file, const char *arg, ...); int execle(const char *path, const char *arg,</p><p class="s31" style="padding-left: 20pt;text-indent: 0pt;line-height: 10pt;text-align: center;">..., char * const envp[]);</p><p class="s31" style="padding-left: 121pt;text-indent: -4pt;text-align: center;">int execv(const char *path, char *const argv[]); int execvp(const char *file, char *const argv[]);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">DESCRIPTION</p><p class="s31" style="padding-left: 121pt;text-indent: 0pt;text-align: justify;">The  exec()  family  of  functions  replaces the current process image with a new process image.  The functions described in this manual page are front-ends for the function execve(2).  (See the</p><p class="s31" style="padding-top: 2pt;padding-bottom: 3pt;padding-left: 121pt;text-indent: 0pt;text-align: left;">manual page for execve() for detailed information about the replacement of the current process.)</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_1205.png"/></span></p><p style="padding-top: 6pt;padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: left;">It seems like there could be a weakness here if the memory layout is randomized only when the process is started. Let’s test this hypothesis with a piece of code that prints the address of a stack variable and then executes aslr_demo using an <span class="s31">execl() </span>function.</p><p class="s40" style="padding-top: 9pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">aslr_execl.c</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_1206.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">#include &lt;stdio.h&gt; #include &lt;unistd.h&gt;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 104pt;text-indent: -12pt;text-align: left;">int main(int argc, char *argv[]) { int stack_var;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;text-align: left;">// Print an address from the current stack frame. printf(&quot;stack_var is at %p\n&quot;, &amp;stack_var);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-top: 4pt;padding-left: 104pt;text-indent: 0pt;text-align: left;">// Start aslr_demo to see how its stack is arranged. execl(&quot;./aslr_demo&quot;, &quot;aslr_demo&quot;, NULL);</p><p class="s31" style="padding-bottom: 3pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">}</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_1207.png"/></span></p><p style="padding-top: 7pt;padding-left: 91pt;text-indent: 17pt;text-align: justify;">When this program is compiled and executed, it will <span class="s31">execl() </span>aslr_demo, which also prints the address of a stack variable (buffer). This lets us compare the memory layouts.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_1208.png"/></span></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">reader@hacking:~/booksrc $ gcc -o aslr_demo aslr_demo.c reader@hacking:~/booksrc $ gcc -o aslr_execl aslr_execl.c reader@hacking:~/booksrc $ ./aslr_demo test</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">buffer is at 0xbf9f31c0 reader@hacking:~/booksrc $ ./aslr_demo test buffer is at 0xbffaaf70 reader@hacking:~/booksrc $ ./aslr_execl stack_var is at 0xbf832044</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">buffer is at 0xbf832000</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">reader@hacking:~/booksrc $ gdb -q --batch -ex &quot;p 0xbf832044 - 0xbf832000&quot;</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">$1 = 68</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">reader@hacking:~/booksrc $ ./aslr_execl stack_var is at 0xbfa97844</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 10pt;text-align: left;">buffer is at 0xbf82f800</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">reader@hacking:~/booksrc $ gdb -q --batch -ex &quot;p 0xbfa97844 - 0xbf82f800&quot;</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">$1 = 2523204</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">reader@hacking:~/booksrc $ ./aslr_execl stack_var is at 0xbfbb0bc4</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 10pt;text-align: left;">buffer is at 0xbff3e710</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">reader@hacking:~/booksrc $ gdb -q --batch -ex &quot;p 0xbfbb0bc4 - 0xbff3e710&quot;</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">$1 = 4291241140</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">reader@hacking:~/booksrc $ ./aslr_execl stack_var is at 0xbf9a81b4</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 10pt;text-align: left;">buffer is at 0xbf9a8180</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">reader@hacking:~/booksrc $ gdb -q --batch -ex &quot;p 0xbf9a81b4 - 0xbf9a8180&quot;</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">$1 = 52</p><p class="s31" style="padding-bottom: 3pt;padding-left: 19pt;text-indent: 0pt;text-align: left;">reader@hacking:~/booksrc $</p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_1209.png"/></span></p><p style="padding-top: 3pt;padding-left: 91pt;text-indent: 20pt;text-align: left;">The first result looks very promising, but further attempts show that there is some degree of randomization happening when the new process is executed with <span class="s31">execl()</span>. I’m sure this wasn’t always the case, but the progress of open source is rather constant. This isn’t much of a problem though, since we have ways to deal with that partial uncertainty.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part160.htm">&lt; Previous</a><span> | </span><a href="../hacking-the-art-of-exploitation.html">Contents</a><span> | </span><a href="part162.htm">Next &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
