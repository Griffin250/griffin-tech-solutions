<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>0x6c0 Randomized Stack Space</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part156.htm">&lt; Previous</a><span> | </span><a href="../hacking-the-art-of-exploitation.html">Contents</a><span> | </span><a href="part158.htm">Next &gt;</a></p><p class="s30" style="padding-left: 37pt;text-indent: 0pt;text-align: left;"><a name="bookmark144">0x6c0 Randomized Stack Space</a></p><p style="padding-top: 5pt;padding-left: 91pt;text-indent: 0pt;line-height: 108%;text-align: left;">Another protective countermeasure tries a slightly different approach. Instead of preventing execution on the stack, this countermeasure randomizes the stack memory layout. When the memory layout is randomized, the attacker won’t be able to return execution into waiting shellcode, since he won’t know where it is.</p><p style="padding-left: 91pt;text-indent: 18pt;line-height: 108%;text-align: left;">This countermeasure has been enabled by default in the Linux kernel since 2.6.12, but this book’s LiveCD has been configured with it turned off. To turn this protection on again, echo <span class="s31">1 </span>to the /proc filesystem as shown below.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_1172.png"/></span></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">reader@hacking:~/booksrc $ sudo su -</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">root@hacking:~ # echo 1 &gt; /proc/sys/kernel/randomize_va_space root@hacking:~ # exit</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">logout</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">reader@hacking:~/booksrc $ gcc exploit_notesearch.c reader@hacking:~/booksrc $ ./a.out</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">[DEBUG] found a 34 byte note for user id 999 [DEBUG] found a 41 byte note for user id 999</p><p class="s31" style="padding-bottom: 2pt;padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">-------[ end of note data ]------- reader@hacking:~/booksrc $</p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_1173.png"/></span></p><p style="padding-top: 6pt;padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: left;">With this countermeasure turned on, the notesearch exploit no longer works, since the layout of the stack is randomized. Every time a program starts, the stack begins at a random location. The following example demon- strates this.</p><p class="s40" style="padding-top: 4pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">aslr_demo.c</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_1174.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">#include &lt;stdio.h&gt;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 104pt;text-indent: -12pt;line-height: 107%;text-align: left;">int main(int argc, char *argv[]) { char buffer[50];</p><p class="s31" style="padding-top: 1pt;padding-left: 104pt;text-indent: 0pt;line-height: 21pt;text-align: left;">printf(&quot;buffer is at %p\n&quot;, &amp;buffer); if(argc &gt; 1)</p><p class="s31" style="padding-left: 116pt;text-indent: 0pt;line-height: 8pt;text-align: left;">strcpy(buffer, argv[1]);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-top: 4pt;padding-left: 104pt;text-indent: 0pt;text-align: left;">return 1;</p><p class="s31" style="padding-bottom: 3pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">}</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_1175.png"/></span></p><p style="padding-top: 6pt;padding-left: 109pt;text-indent: 0pt;text-align: left;">This program has an obvious buffer overflow vulnerability in it. However,</p><p style="padding-left: 91pt;text-indent: 0pt;text-align: left;">with ASLR turned on, exploitation isn’t that easy.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_1176.png"/></span></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">reader@hacking:~/booksrc $ gcc -g -o aslr_demo aslr_demo.c reader@hacking:~/booksrc $ ./aslr_demo</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 106%;text-align: left;">buffer is at 0xbffbbf90 reader@hacking:~/booksrc $ ./aslr_demo buffer is at 0xbfe4de20 reader@hacking:~/booksrc $ ./aslr_demo buffer is at 0xbfc7ac50</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">reader@hacking:~/booksrc $ ./aslr_demo $(perl -e &#39;print &quot;ABCD&quot;x20&#39;) buffer is at 0xbf9a4920</p><p class="s31" style="padding-bottom: 3pt;padding-left: 19pt;text-indent: 0pt;text-align: left;">Segmentation fault reader@hacking:~/booksrc $</p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_1177.png"/></span></p><p style="padding-top: 6pt;padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: left;">Notice how the location of the buffer on the stack changes with every run. We can still inject the shellcode and corrupt memory to overwrite the return address, but we don’t know where the shellcode is in memory. The randomization changes the location of everything on the stack, including environment variables.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_1178.png"/></span></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">reader@hacking:~/booksrc $ export SHELLCODE=$(cat shellcode.bin) reader@hacking:~/booksrc $ ./getenvaddr SHELLCODE ./aslr_demo SHELLCODE will be at 0xbfd919c3</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">reader@hacking:~/booksrc $ ./getenvaddr SHELLCODE ./aslr_demo SHELLCODE will be at 0xbfe499c3</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">reader@hacking:~/booksrc $ ./getenvaddr SHELLCODE ./aslr_demo SHELLCODE will be at 0xbfcae9c3</p><p class="s31" style="padding-bottom: 3pt;padding-left: 19pt;text-indent: 0pt;line-height: 10pt;text-align: left;">reader@hacking:~/booksrc $</p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_1179.png"/></span></p><p style="padding-top: 6pt;padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: left;">This type of protection can be very effective in stopping exploits by the average attacker, but it isn’t always enough to stop a determined hacker. Can you think of a way to successfully exploit this program under these conditions?</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part156.htm">&lt; Previous</a><span> | </span><a href="../hacking-the-art-of-exploitation.html">Contents</a><span> | </span><a href="part158.htm">Next &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
