<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>0x772 RC4 Stream Cipher</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part188.htm">&lt; Previous</a><span> | </span><a href="../hacking-the-art-of-exploitation.html">Contents</a><span> | </span><a href="part190.htm">Next &gt;</a></p><p class="s32" style="padding-left: 91pt;text-indent: 0pt;text-align: left;"><a name="bookmark174">0x772 RC4 Stream Cipher</a></p><p style="padding-top: 6pt;padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">RC4 is a surprisingly simple algorithm. It consists of two algorithms: the Key Scheduling Algorithm (KSA) and the Pseudo-Random Generation Algorithm (PRGA). Both of these algorithms use an <span class="s27">8-by-8 S-box</span>, which is just an array of 256 numbers that are both unique and range in value from 0 to 255. Stated simply, all the numbers from 0 to 255 exist in the array, but they’re all just mixed up in different ways. The KSA does the initial scrambling of the S-box, based on the seed value fed into it, and the seed can be up to 256 bits long.</p><p style="padding-left: 91pt;text-indent: 18pt;line-height: 106%;text-align: left;">First, the S-box array is filled with sequential values from 0 to 255. This array will be aptly named <span class="s27">S</span>. Then, another 256-byte array is filled with the seed value, repeating as necessary until the entire array is filled. This array will be named <span class="s27">K</span>. Then the <span class="s27">S </span>array is scrambled using the following pseudo-code.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_1313.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">j = 0;</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">for i = 0 to 255</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">{</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;text-align: left;">j = (j + S[i] + K[i]) mod 256;</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;text-align: left;">swap S[i] and S[j];</p><p class="s31" style="padding-bottom: 3pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">}</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_1314.png"/></span></p><p style="padding-top: 7pt;padding-left: 109pt;text-indent: 0pt;text-align: left;">Once that is done, the S-box is all mixed up based on the seed value.</p><p style="padding-left: 91pt;text-indent: 0pt;text-align: left;">That’s the key scheduling algorithm. Pretty simple.</p><p style="padding-top: 3pt;padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: left;">Now when keystream data is needed, the Pseudo-Random Generation Algorithm (PRGA) is used. This algorithm has two counters, <span class="s31">i </span>and <span class="s31">j</span>, which are both initialized at <span class="s31">0 </span>to begin with. After that, for each byte of keystream data, the following pseudo-code is used.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_1315.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">i = (i + 1) mod 256;</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">j = (j + S[i]) mod 256; swap S[i] and S[j];</p><p class="s31" style="padding-bottom: 3pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">t = (S[i] + S[j]) mod 256; Output the value of S[t];</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_1316.png"/></span></p><p style="padding-top: 7pt;padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: justify;">The outputted byte of <span class="s31">S[t] </span>is the first byte of the keystream. This algorithm is repeated for additional keystream bytes.</p><p style="padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: justify;">RC4 is simple enough that it can be easily memorized and implemented on the fly, and it is quite secure if used properly. However, there are a few problems with the way RC4 is used for WEP.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="toc">&nbsp;</p><div class="toc"><a class="toc0" href="part190.htm">0x780 WEP Attacks</a></div><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part188.htm">&lt; Previous</a><span> | </span><a href="../hacking-the-art-of-exploitation.html">Contents</a><span> | </span><a href="part190.htm">Next &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
