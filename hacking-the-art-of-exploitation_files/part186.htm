<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>0x764 Password Probability Matrix</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part185.htm">&lt; Previous</a><span> | </span><a href="../hacking-the-art-of-exploitation.html">Contents</a><span> | </span><a href="part187.htm">Next &gt;</a></p><p class="s32" style="padding-left: 91pt;text-indent: 0pt;text-align: justify;"><a name="bookmark171">0x764 Password Probability Matrix</a></p><p style="padding-top: 7pt;padding-left: 91pt;text-indent: 0pt;line-height: 108%;text-align: left;">There is a trade-off between computational power and storage space that exists everywhere. This can be seen in the most elementary forms of computer science and everyday life. MP3 files use compression to store a high-quality sound file in a relatively small amount of space, but the demand for compu- tational resources increases. Pocket calculators use this trade-off in the other direction by maintaining a lookup table for functions such as sine and cosine to save the calculator from doing heavy computations.</p><p style="padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: left;">This trade-off can also be applied to cryptography in what has become known as a time/space trade-off attack. While Hellman’s methods for this type of attack are probably more efficient, the following source code should be easier to understand. The general principle is always the same, though: Try to find the sweet spot between computational power and storage space, so that an exhaustive brute-force attack can be completed in a reasonable amount of time, using a reasonable amount of space. Unfortunately, the dilemma of salts will still present itself, since this method still requires some form of storage. However, there are only 4,096 possible salts with <span class="s31">crypt()</span>-style password hashes, so the effect of this problem can be diminished by reducing the needed storage space far enough to remain reasonable despite the 4,096 multiplier.</p><p style="padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: left;">This method uses a form of lossy compression. Instead of having an exact hash lookup table, several thousand possible plaintext values will be returned when a password hash is entered. These values can be checked quickly to converge on the original plaintext password, and the lossy com- pression allows for a major space reduction. In the demonstration code that follows, the keyspace for all possible four-character passwords (with a fixed salt) is used. The storage space needed is reduced by 88 percent, compared to a full hash lookup table (with a fixed salt), and the keyspace that must be brute-forced through is reduced by about 1,018 times. Under the assumption of 10,000 cracks per second, this method can crack any four-character pass- word (with a fixed salt) in under eight seconds, which is a considerable speedup when compared to the two hours needed for an exhaustive brute- force attack of the same keyspace.</p><p style="padding-left: 109pt;text-indent: 0pt;line-height: 11pt;text-align: left;">This method builds a three-dimensional binary matrix that correlates</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 108%;text-align: left;">parts of the hash values with parts of the plaintext values. On the x-axis, the plaintext is split into two pairs: the first two characters and the second two characters. The possible values are enumerated into a binary vector that is 95<span class="s41">2</span>, or 9,025, bits long (about 1,129 bytes). On the y-axis, the ciphertext is split into four three-character chunks. These are enumerated the same way down the columns, but only four bits of the third character are actually used. This means there are 64<span class="s41">2</span> · 4, or 16,384, columns. The z-axis exists simply to maintain eight different two-dimensional matrices, so four exist for each of the plaintext pairs.</p><p style="padding-top: 3pt;padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: left;">The basic idea is to split the plaintext into two paired values that are enumerated along a vector. Every possible plaintext is hashed into ciphertext, and the ciphertext is used to find the appropriate column of the matrix.</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 108%;text-align: left;">Then the plaintext enumeration bit across the row of the matrix is turned on. When the ciphertext values are reduced into smaller chunks, collisions are inevitable.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 3pt;text-align: left;"><span><img width="150" height="4" alt="image" src="Image_1298.png"/></span></p><p class="s37" style="padding-bottom: 3pt;padding-left: 93pt;text-indent: 0pt;text-align: left;">Plaintext  Hash</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 2pt;text-align: left;"><span><img width="149" height="3" alt="image" src="Image_1299.png"/></span></p><p class="s48" style="padding-left: 93pt;text-indent: 0pt;text-align: left;">test   je<span class="s37">HEA</span>X1m66RV.</p><p class="s48" style="padding-top: 3pt;padding-left: 93pt;text-indent: 0pt;text-align: left;">!J)h   je<span class="s37">HEA</span>38vqlkkQ</p><p class="s48" style="padding-top: 3pt;padding-left: 93pt;text-indent: 0pt;text-align: left;">&quot;.F+   je<span class="s37">HEA</span>1Tbde5FE</p><p class="s48" style="padding-top: 3pt;padding-bottom: 2pt;padding-left: 93pt;text-indent: 0pt;text-align: left;">&quot;8,J   je<span class="s37">HEA</span>nX8kQK3I</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 2pt;text-align: left;"><span><img width="149" height="3" alt="image" src="Image_1300.png"/></span></p><p style="padding-top: 7pt;padding-left: 91pt;text-indent: 18pt;line-height: 107%;text-align: justify;">In this case, the column for <span class="s31">HEA </span>would have the bits corresponding to the plaintext pairs <span class="s31">te</span>, <span class="s31">!J</span>, <span class="s31">&quot;.</span>, and <span class="s31">&quot;8 </span>turned on, as these plaintext/hash pairs are added to the matrix.</p><p style="padding-left: 91pt;text-indent: 18pt;line-height: 107%;text-align: left;">After the matrix is completely filled out, when a hash such as <span class="s31">jeHEA38vqlkkQ </span>is entered, the column for <span class="s31">HEA </span>will be looked up, and the two-dimensional matrix will return the values <span class="s31">te</span>, <span class="s31">!J</span>, <span class="s31">&quot;.</span>, and <span class="s31">&quot;8 </span>for the first two characters of the plaintext. There are four matrices like this for the first two characters, using ciphertext substring from characters 2 through 4, 4 through 6, 6 though 8, and 8 though 10, each with a different vector of possible first two-character plaintext values. Each vector is pulled, and they are combined with a bitwise AND. This will leave only those bits turned on that correspond to the plaintext pairs listed as possibilities for each substring of ciphertext. There are also four matrices like this for the last two characters of plaintext.</p><p style="padding-left: 91pt;text-indent: 18pt;line-height: 106%;text-align: left;">The sizes of the matrices were determined by the pigeonhole principle. This is a simple principle that states: If <span class="s27">k </span>+ 1 objects are put into <span class="s27">k </span>boxes, at least one of the boxes will contain two objects. So, to get the best results, the goal is for each vector to be a little bit less than half full of 1s. Since 95<span class="s41">4</span>, or 81,450,625, entries will be put in the matrices, there need to be about twice as many holes to achieve 50 percent saturation. Since each vector has 9,025 entries, there should be about (95<span class="s41">4</span> · 2) / 9025 columns. This works out to be about 18,000 columns. Since ciphertext substrings of three characters are being used for the columns, the first two characters and four bits from the third character are used to provide 64<span class="s41">2</span> · 4, or about 16 thousand columns (there are only 64 possible values for each character of ciphertext hash). This should be close enough, because when a bit is added twice, the overlap is ignored. In practice, each vector turns out to be about 42 percent saturated with 1s.</p><p style="padding-left: 91pt;text-indent: 17pt;line-height: 107%;text-align: left;">Since there are four vectors that are pulled for a single ciphertext, the probability of any one enumeration position having a 1 value in each vector is about 0.42<span class="s41">4</span>, or about 3.11 percent. This means that, on average, the 9,025 possibilities for the first two characters of plaintext are reduced by about 97 percent to 280 possibilities. This is also done for the last two characters, pro- viding about 280<span class="s41">2</span>, or 78,400, possible plaintext values. Under the assumption of 10,000 cracks per second, this reduced keyspace would take under 8 seconds to check.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s40" style="padding-top: 8pt;padding-left: 19pt;text-indent: 0pt;text-align: left;">ppm_gen.c</p><p style="padding-top: 3pt;padding-left: 19pt;text-indent: 17pt;line-height: 108%;text-align: left;">Of course, there are downsides. First, it takes at least as long to create the matrix as the original brute-force attack would have taken; however, this is a one-time cost. Also, the salts still tend to prohibit any type of storage attack, even with the reduced storage-space requirements.</p><p style="padding-left: 19pt;text-indent: 18pt;line-height: 108%;text-align: left;">The following two source code listings can be used to create a password probability matrix and crack passwords with it. The first listing will generate a matrix that can be used to crack all possible four-character passwords salted with <span class="s31">je</span>. The second listing will use the generated matrix to actually do the password cracking.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_1301.png"/></span></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">/*********************************************************\</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">* Password Probability Matrix  *  File: ppm_gen.c  *</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">***********************************************************</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">*                              *</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;"><a href="mailto:matrix@phiral.com" class="s81" target="_blank">* Author:   Jon Erickson </a>&lt;matrix@phiral.com&gt;   *</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">* Organization: Phiral Research Laboratories     *</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">*                              *</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">* This is the generate program for the PPM proof of   *</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">* concept. It generates a file called 4char.ppm, which *</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">* contains information regarding all possible 4-    *</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">* character passwords salted with &#39;je&#39;. This file can  *</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">* be used to quickly crack passwords found within this  *</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">* keyspace with the corresponding ppm_crack.c program.  *</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">*                              *</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">\*********************************************************/</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">#define _XOPEN_SOURCE #include &lt;unistd.h&gt; #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">#define HEIGHT 16384</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">#define WIDTH 1129</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">#define DEPTH 8</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">#define SIZE HEIGHT * WIDTH * DEPTH</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">/* Map a single hash byte to an enumerated value. */ int enum_hashbyte(char a) {</p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;line-height: 10pt;text-align: left;">int i, j;</p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;text-align: left;">i = (int)a;</p><p class="s31" style="padding-left: 44pt;text-indent: -12pt;line-height: 107%;text-align: left;">if((i &gt;= 46) &amp;&amp; (i &lt;= 57)) j = i - 46;</p><p class="s31" style="padding-left: 44pt;text-indent: -12pt;line-height: 107%;text-align: left;">else if ((i &gt;= 65) &amp;&amp; (i &lt;= 90)) j = i - 53;</p><p class="s31" style="padding-left: 44pt;text-indent: -12pt;line-height: 107%;text-align: left;">else if ((i &gt;= 97) &amp;&amp; (i &lt;= 122)) j = i - 59;</p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;line-height: 10pt;text-align: left;">return j;</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">}</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">/* Map 3 hash bytes to an enumerated value. */ int enum_hashtriplet(char a, char b, char c) {</p><p class="s31" style="padding-top: 2pt;padding-left: 32pt;text-indent: 0pt;text-align: left;">return (((enum_hashbyte(c)%4)*4096)+(enum_hashbyte(a)*64)+enum_hashbyte(b));</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">}</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">/* Barf a message and exit. */</p><p class="s31" style="padding-left: 32pt;text-indent: -12pt;line-height: 107%;text-align: left;">void barf(char *message, char *extra) { printf(message, extra);</p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;line-height: 10pt;text-align: left;">exit(1);</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">}</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">/* Generate a 4–char.ppm file with all possible 4-char passwords (salted w/ je). */ int main() {</p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;line-height: 107%;text-align: left;">char plain[5]; char *code, *data; int i, j, k, l;</p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;line-height: 107%;text-align: left;">unsigned int charval, val; FILE *handle;</p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;text-align: left;">if (!(handle = fopen(&quot;4char.ppm&quot;, &quot;w&quot;)))</p><p class="s31" style="padding-left: 44pt;text-indent: 0pt;text-align: left;">barf(&quot;Error: Couldn&#39;t open file &#39;4char.ppm&#39; for writing.\n&quot;, NULL);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;line-height: 107%;text-align: left;">data = (char *) malloc(SIZE); if (!(data))</p><p class="s31" style="padding-left: 44pt;text-indent: 0pt;text-align: left;">barf(&quot;Error: Couldn&#39;t allocate memory.\n&quot;, NULL);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 44pt;text-indent: -12pt;line-height: 107%;text-align: left;">for(i=32; i&lt;127; i++) { for(j=32; j&lt;127; j++) {</p><p class="s31" style="padding-left: 57pt;text-indent: 0pt;text-align: left;">printf(&quot;Adding %c%c** to 4char.ppm..\n&quot;, i, j); for(k=32; k&lt;127; k++) {</p><p class="s31" style="padding-left: 69pt;text-indent: 0pt;text-align: left;">for(l=32; l&lt;127; l++) {</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 82pt;text-indent: 0pt;line-height: 106%;text-align: left;">plain[0]  = (char)i; // Build every plain[1]  = (char)j; // possible 4-byte plain[2]  = (char)k; // password. plain[3]  = (char)l;</p><p class="s31" style="padding-left: 82pt;text-indent: 0pt;text-align: left;">plain[4] = &#39;\0&#39;;</p><p class="s31" style="padding-left: 82pt;text-indent: 0pt;text-align: left;">code = crypt((const char *)plain, (const char *)&quot;je&quot;); // Hash it.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 82pt;text-indent: 0pt;text-align: left;">/* Lossfully store statistical info about the pairings. */</p><p class="s31" style="padding-left: 80pt;text-indent: 0pt;text-align: left;">val = enum_hashtriplet(code[2], code[3], code[4]); // Store info about bytes 2-4.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 82pt;text-indent: 0pt;line-height: 107%;text-align: left;">charval = (i-32)*95 + (j-32); // First 2 plaintext bytes data[(val*WIDTH)+(charval/8)] |= (1&lt;&lt;(charval%8));</p><p class="s31" style="padding-left: 82pt;text-indent: 0pt;line-height: 10pt;text-align: left;">val += (HEIGHT * 4);</p><p class="s31" style="padding-left: 82pt;text-indent: 0pt;line-height: 107%;text-align: left;">charval = (k-32)*95 + (l-32); // Last 2 plaintext bytes data[(val*WIDTH)+(charval/8)] |= (1&lt;&lt;(charval%8));</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 82pt;text-indent: 0pt;line-height: 107%;text-align: left;">val = HEIGHT + enum_hashtriplet(code[4], code[5], code[6]); // bytes 4-6 charval = (i-32)*95 + (j-32); // First 2 plaintext bytes data[(val*WIDTH)+(charval/8)] |= (1&lt;&lt;(charval%8));</p><p class="s31" style="padding-left: 82pt;text-indent: 0pt;text-align: left;">val += (HEIGHT * 4);</p><p class="s31" style="padding-left: 82pt;text-indent: 0pt;line-height: 107%;text-align: left;">charval = (k-32)*95 + (l-32); // Last 2 plaintext bytes data[(val*WIDTH)+(charval/8)] |= (1&lt;&lt;(charval%8));</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 82pt;text-indent: 0pt;line-height: 106%;text-align: left;">val = (2 * HEIGHT) + enum_hashtriplet(code[6], code[7], code[8]); // bytes 6-8 charval = (i-32)*95 + (j-32); // First 2 plaintext bytes data[(val*WIDTH)+(charval/8)] |= (1&lt;&lt;(charval%8));</p><p class="s31" style="padding-left: 82pt;text-indent: 0pt;text-align: left;">val += (HEIGHT * 4);</p><p class="s31" style="padding-top: 2pt;padding-left: 82pt;text-indent: 0pt;text-align: left;">charval = (k-32)*95 + (l-32); // Last 2 plaintext bytes data[(val*WIDTH)+(charval/8)] |= (1&lt;&lt;(charval%8));</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-top: 4pt;padding-left: 82pt;text-indent: 0pt;text-align: left;">val = (3 * HEIGHT) + enum_hashtriplet(code[8], code[9], code[10]); // bytes 8-10 charval = (i-32)*95 + (j-32); // First 2 plaintext chars data[(val*WIDTH)+(charval/8)] |= (1&lt;&lt;(charval%8));</p><p class="s31" style="padding-left: 82pt;text-indent: 0pt;text-align: left;">val += (HEIGHT * 4);</p><p class="s31" style="padding-left: 82pt;text-indent: 0pt;text-align: left;">charval = (k-32)*95 + (l-32); // Last 2 plaintext bytes data[(val*WIDTH)+(charval/8)] |= (1&lt;&lt;(charval%8));</p><p class="s31" style="padding-left: 69pt;text-indent: 0pt;text-align: left;">}</p><p class="s31" style="padding-left: 57pt;text-indent: 0pt;text-align: left;">}</p><p class="s31" style="padding-left: 44pt;text-indent: 0pt;text-align: left;">}</p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;text-align: left;">}</p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;line-height: 106%;text-align: left;">printf(&quot;finished.. saving..\n&quot;); fwrite(data, SIZE, 1, handle); free(data);</p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;line-height: 10pt;text-align: left;">fclose(handle);</p><p class="s31" style="padding-bottom: 3pt;padding-left: 19pt;text-indent: 0pt;text-align: left;">}</p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_1302.png"/></span></p><p style="padding-top: 6pt;padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: left;">The first piece of code, ppm_gen.c, can be used to generate a four- character password probability matrix, as shown in the output below. The</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 108%;text-align: left;">-O3 <span class="p">option passed to GCC tells it to optimize the code for speed when it compiles.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_1303.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: justify;">reader@hacking:~/booksrc $ gcc -O3 -o ppm_gen ppm_gen.c -lcrypt reader@hacking:~/booksrc $ ./ppm_gen</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 106%;text-align: justify;">Adding  ** to 4char.ppm.. Adding !** to 4char.ppm.. Adding &quot;** to 4char.ppm..</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: justify;">.:[ output trimmed ]:.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s40" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">ppm_crack.c</p><p class="s31" style="padding-top: 4pt;padding-left: 19pt;text-indent: 0pt;line-height: 106%;text-align: left;">Adding ~|** to 4char.ppm.. Adding ~}** to 4char.ppm.. Adding ~~** to 4char.ppm.. finished.. saving.. @hacking:~ $ ls -lh 4char.ppm</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 10pt;text-align: left;">-rw-r--r-- 1  142M 2007-09-30 13:56 4char.ppm</p><p class="s31" style="padding-bottom: 3pt;padding-left: 19pt;text-indent: 0pt;text-align: left;">reader@hacking:~/booksrc $</p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_1304.png"/></span></p><p style="padding-top: 6pt;padding-left: 19pt;text-indent: 17pt;line-height: 108%;text-align: left;">The 142MB 4char.ppm file contains loose associations between the plaintext and hash data for every possible four-character password. This data can then be used by this next program to quickly crack four-character pass- words that would foil a dictionary attack.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_1305.png"/></span></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">/*********************************************************\</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">* Password Probability Matrix  *  File: ppm_crack.c  *</p><p class="s31" style="padding-bottom: 1pt;padding-left: 19pt;text-indent: 0pt;text-align: left;">***********************************************************</p><table style="border-collapse:collapse;margin-left:16.94pt" cellspacing="0"><tr style="height:10pt"><td style="width:75pt"><p class="s42" style="padding-left: 2pt;text-indent: 0pt;line-height: 9pt;text-align: left;">*</p></td><td style="width:157pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td><td style="width:24pt"><p class="s42" style="padding-right: 2pt;text-indent: 0pt;line-height: 9pt;text-align: right;">*</p></td></tr><tr style="height:11pt"><td style="width:75pt"><p class="s42" style="padding-left: 2pt;text-indent: 0pt;line-height: 9pt;text-align: left;">* Author:</p></td><td style="width:157pt"><p style="padding-left: 4pt;text-indent: 0pt;line-height: 9pt;text-align: left;"><a href="mailto:matrix@phiral.com" class="s120" target="_blank">Jon Erickson &lt;matrix@phiral.com&gt;</a></p></td><td style="width:24pt"><p class="s42" style="padding-right: 2pt;text-indent: 0pt;line-height: 9pt;text-align: right;">*</p></td></tr><tr style="height:11pt"><td style="width:75pt"><p class="s42" style="padding-left: 2pt;text-indent: 0pt;line-height: 9pt;text-align: left;">* Organization:</p></td><td style="width:157pt"><p class="s42" style="padding-left: 4pt;text-indent: 0pt;line-height: 9pt;text-align: left;">Phiral Research Laboratories</p></td><td style="width:24pt"><p class="s42" style="padding-right: 2pt;text-indent: 0pt;line-height: 9pt;text-align: right;">*</p></td></tr><tr style="height:10pt"><td style="width:75pt"><p class="s42" style="padding-left: 2pt;text-indent: 0pt;line-height: 9pt;text-align: left;">*</p></td><td style="width:157pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td><td style="width:24pt"><p class="s42" style="padding-right: 2pt;text-indent: 0pt;line-height: 9pt;text-align: right;">*</p></td></tr></table><p class="s31" style="padding-top: 2pt;padding-left: 19pt;text-indent: 0pt;text-align: left;">* This is the crack program for the PPM proof of concept.*</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">* It uses an existing file called 4char.ppm, which   *</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">* contains information regarding all possible 4–    *</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">* character passwords salted with &#39;je&#39;. This file can  *</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">* be generated with the corresponding ppm_gen.c program. *</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">*                              *</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">\*********************************************************/</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 106%;text-align: left;">#define _XOPEN_SOURCE #include &lt;unistd.h&gt; #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">#define HEIGHT 16384</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">#define WIDTH 1129</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">#define DEPTH 8</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">#define SIZE HEIGHT * WIDTH * DEPTH</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">#define DCM HEIGHT * WIDTH</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">/* Map a single hash byte to an enumerated value. */ int enum_hashbyte(char a) {</p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;line-height: 107%;text-align: left;">int i, j; i = (int)a;</p><p class="s31" style="padding-left: 44pt;text-indent: -12pt;line-height: 107%;text-align: left;">if((i &gt;= 46) &amp;&amp; (i &lt;= 57)) j = i - 46;</p><p class="s31" style="padding-left: 44pt;text-indent: -12pt;line-height: 107%;text-align: left;">else if ((i &gt;= 65) &amp;&amp; (i &lt;= 90)) j = i - 53;</p><p class="s31" style="padding-left: 44pt;text-indent: -12pt;line-height: 107%;text-align: left;">else if ((i &gt;= 97) &amp;&amp; (i &lt;= 122)) j = i - 59;</p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;line-height: 10pt;text-align: left;">return j;</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">}</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">/* Map 3 hash bytes to an enumerated value. */ int enum_hashtriplet(char a, char b, char c) {</p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;text-align: left;">return (((enum_hashbyte(c)%4)*4096)+(enum_hashbyte(a)*64)+enum_hashbyte(b));</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">}</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">/* Merge two vectors. */</p><p class="s31" style="padding-left: 32pt;text-indent: -12pt;line-height: 107%;text-align: left;">void merge(char *vector1, char *vector2) { int i;</p><p class="s31" style="padding-left: 44pt;text-indent: -12pt;text-align: left;">for(i=0; i &lt; WIDTH; i++) vector1[i] &amp;= vector2[i];</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">}</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">/* Returns the bit in the vector at the passed index position */ int get_vector_bit(char *vector, int index) {</p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;text-align: left;">return ((vector[(index/8)]&amp;(1&lt;&lt;(index%8)))&gt;&gt;(index%8));</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">}</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">/* Counts the number of plaintext pairs in the passed vector */ int count_vector_bits(char *vector) {</p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;line-height: 107%;text-align: left;">int i, count=0; for(i=0; i &lt; 9025; i++)</p><p class="s31" style="padding-left: 32pt;text-indent: 12pt;line-height: 107%;text-align: left;">count += get_vector_bit(vector, i); return count;</p><p class="s31" style="padding-top: 2pt;padding-left: 19pt;text-indent: 0pt;text-align: left;">}</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">/* Print the plaintext pairs that each ON bit in the vector enumerates. */ void print_vector(char *vector) {</p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;text-align: left;">int i, a, b, val; for(i=0; i &lt; 9025; i++) {</p><p class="s31" style="padding-left: 44pt;text-indent: 0pt;text-align: left;">if(get_vector_bit(vector, i) == 1) { // If bit is on,</p><p class="s31" style="padding-left: 57pt;text-indent: 0pt;text-align: left;">a = i / 95;         // calculate the</p><p class="s31" style="padding-left: 57pt;text-indent: 0pt;text-align: left;">b = i - (a * 95);      // plaintext pair printf(&quot;%c%c &quot;,a+32, b+32); // and print it.</p><p class="s31" style="padding-left: 44pt;text-indent: 0pt;text-align: left;">}</p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;text-align: left;">}</p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;text-align: left;">printf(&quot;\n&quot;);</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">}</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-top: 4pt;padding-left: 19pt;text-indent: 0pt;text-align: left;">/* Barf a message and exit. */</p><p class="s31" style="padding-left: 32pt;text-indent: -12pt;text-align: left;">void barf(char *message, char *extra) { printf(message, extra);</p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;text-align: left;">exit(1);</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">}</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">/* Crack a 4-character password using generated 4char.ppm file. */ int main(int argc, char *argv[]) {</p><p class="s31" style="padding-left: 27pt;text-indent: 0pt;text-align: left;">char *pass, plain[5];</p><p class="s31" style="padding-left: 27pt;text-indent: 0pt;text-align: left;">unsigned char bin_vector1[WIDTH], bin_vector2[WIDTH], temp_vector[WIDTH]; char prob_vector1[2][9025];</p><p class="s31" style="padding-left: 27pt;text-indent: 0pt;text-align: left;">char prob_vector2[2][9025];</p><p class="s31" style="padding-left: 27pt;text-indent: 0pt;line-height: 107%;text-align: left;">int a, b, i, j, len, pv1_len=0, pv2_len=0; FILE *fd;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 27pt;text-indent: 0pt;text-align: left;">if(argc &lt; 1)</p><p class="s31" style="padding-left: 40pt;text-indent: 0pt;text-align: left;">barf(&quot;Usage: %s &lt;password hash&gt; (will use the file 4char.ppm)\n&quot;, argv[0]);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 27pt;text-indent: 0pt;text-align: left;">if(!(fd = fopen(&quot;4char.ppm&quot;, &quot;r&quot;)))</p><p class="s31" style="padding-left: 27pt;text-indent: 12pt;line-height: 214%;text-align: left;">barf(&quot;Fatal: Couldn&#39;t open PPM file for reading.\n&quot;, NULL); pass = argv[1]; // First argument is password hash</p><p class="s31" style="padding-left: 27pt;text-indent: 0pt;line-height: 10pt;text-align: left;">printf(&quot;Filtering possible plaintext bytes for the first two characters:\n&quot;);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 27pt;text-indent: 0pt;text-align: left;">fseek(fd,(DCM*0)+enum_hashtriplet(pass[2], pass[3], pass[4])*WIDTH, SEEK_SET); fread(bin_vector1, WIDTH, 1, fd); // Read the vector associating bytes 2-4 of hash.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 27pt;text-indent: 0pt;text-align: left;">len = count_vector_bits(bin_vector1);</p><p class="s31" style="padding-top: 1pt;padding-left: 19pt;text-indent: 8pt;text-align: left;">printf(&quot;only 1 vector of 4:\t%d plaintext pairs, with %0.2f%% saturation\n&quot;, len, len*100.0/ 9025.0);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 27pt;text-indent: 0pt;line-height: 106%;text-align: left;">fseek(fd,(DCM*1)+enum_hashtriplet(pass[4], pass[5], pass[6])*WIDTH, SEEK_SET); fread(temp_vector, WIDTH, 1, fd); // Read the vector associating bytes 4-6 of hash. merge(bin_vector1, temp_vector); // Merge it with the first vector.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 27pt;text-indent: 0pt;text-align: left;">len = count_vector_bits(bin_vector1);</p><p class="s31" style="padding-left: 19pt;text-indent: 8pt;text-align: left;">printf(&quot;vectors 1 AND 2 merged:\t%d plaintext pairs, with %0.2f%% saturation\n&quot;, len, len*100.0/9025.0);</p><p class="s31" style="padding-top: 2pt;padding-left: 27pt;text-indent: 0pt;line-height: 106%;text-align: left;">fseek(fd,(DCM*2)+enum_hashtriplet(pass[6], pass[7], pass[8])*WIDTH, SEEK_SET); fread(temp_vector, WIDTH, 1, fd); // Read the vector associating bytes 6-8 of hash. merge(bin_vector1, temp_vector); // Merge it with the first two vectors.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 27pt;text-indent: 0pt;text-align: left;">len = count_vector_bits(bin_vector1);</p><p class="s31" style="padding-left: 19pt;text-indent: 8pt;text-align: left;">printf(&quot;first 3 vectors merged:\t%d plaintext pairs, with %0.2f%% saturation\n&quot;, len, len*100.0/9025.0);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 27pt;text-indent: 0pt;line-height: 107%;text-align: left;">fseek(fd,(DCM*3)+enum_hashtriplet(pass[8], pass[9],pass[10])*WIDTH, SEEK_SET); fread(temp_vector, WIDTH, 1, fd); // Read the vector associatind bytes 8-10 of hash. merge(bin_vector1, temp_vector); // Merge it with the othes vectors.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 27pt;text-indent: 0pt;text-align: left;">len = count_vector_bits(bin_vector1);</p><p class="s31" style="padding-left: 19pt;text-indent: 8pt;text-align: left;">printf(&quot;all 4 vectors merged:\t%d plaintext pairs, with %0.2f%% saturation\n&quot;, len, len*100.0/9025.0);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 27pt;text-indent: 0pt;line-height: 107%;text-align: left;">printf(&quot;Possible plaintext pairs for the first two bytes:\n&quot;); print_vector(bin_vector1);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 27pt;text-indent: 0pt;text-align: left;">printf(&quot;\nFiltering possible plaintext bytes for the last two characters:\n&quot;);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 27pt;text-indent: 0pt;line-height: 107%;text-align: left;">fseek(fd,(DCM*4)+enum_hashtriplet(pass[2], pass[3], pass[4])*WIDTH, SEEK_SET); fread(bin_vector2, WIDTH, 1, fd); // Read the vector associating bytes 2-4 of hash.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 27pt;text-indent: 0pt;text-align: left;">len = count_vector_bits(bin_vector2);</p><p class="s31" style="padding-left: 19pt;text-indent: 8pt;text-align: left;">printf(&quot;only 1 vector of 4:\t%d plaintext pairs, with %0.2f%% saturation\n&quot;, len, len*100.0/ 9025.0);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 27pt;text-indent: 0pt;line-height: 107%;text-align: left;">fseek(fd,(DCM*5)+enum_hashtriplet(pass[4], pass[5], pass[6])*WIDTH, SEEK_SET); fread(temp_vector, WIDTH, 1, fd); // Read the vector associating bytes 4-6 of hash. merge(bin_vector2, temp_vector); // Merge it with the first vector.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 27pt;text-indent: 0pt;text-align: left;">len = count_vector_bits(bin_vector2);</p><p class="s31" style="padding-top: 1pt;padding-left: 19pt;text-indent: 8pt;text-align: left;">printf(&quot;vectors 1 AND 2 merged:\t%d plaintext pairs, with %0.2f%% saturation\n&quot;, len, len*100.0/9025.0);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 27pt;text-indent: 0pt;line-height: 106%;text-align: left;">fseek(fd,(DCM*6)+enum_hashtriplet(pass[6], pass[7], pass[8])*WIDTH, SEEK_SET); fread(temp_vector, WIDTH, 1, fd); // Read the vector associating bytes 6-8 of hash. merge(bin_vector2, temp_vector); // Merge it with the first two vectors.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 27pt;text-indent: 0pt;text-align: left;">len = count_vector_bits(bin_vector2);</p><p class="s31" style="padding-top: 1pt;padding-left: 19pt;text-indent: 8pt;text-align: left;">printf(&quot;first 3 vectors merged:\t%d plaintext pairs, with %0.2f%% saturation\n&quot;, len, len*100.0/9025.0);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 27pt;text-indent: 0pt;line-height: 106%;text-align: left;">fseek(fd,(DCM*7)+enum_hashtriplet(pass[8], pass[9],pass[10])*WIDTH, SEEK_SET); fread(temp_vector, WIDTH, 1, fd); // Read the vector associatind bytes 8-10 of hash. merge(bin_vector2, temp_vector); // Merge it with the othes vectors.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 27pt;text-indent: 0pt;text-align: left;">len = count_vector_bits(bin_vector2);</p><p class="s31" style="padding-top: 1pt;padding-left: 19pt;text-indent: 8pt;text-align: left;">printf(&quot;all 4 vectors merged:\t%d plaintext pairs, with %0.2f%% saturation\n&quot;, len, len*100.0/9025.0);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 27pt;text-indent: 0pt;text-align: left;">printf(&quot;Possible plaintext pairs for the last two bytes:\n&quot;); print_vector(bin_vector2);</p><p class="s31" style="padding-top: 2pt;padding-left: 27pt;text-indent: 0pt;text-align: left;">printf(&quot;Building probability vectors...\n&quot;);</p><p class="s31" style="padding-left: 36pt;text-indent: -8pt;line-height: 107%;text-align: left;">for(i=0; i &lt; 9025; i++) { // Find possible first two plaintext bytes. if(get_vector_bit(bin_vector1, i)==1) {;</p><p class="s31" style="padding-left: 44pt;text-indent: 0pt;text-align: left;">prob_vector1[0][pv1_len] = i / 95;</p><p class="s31" style="padding-left: 44pt;text-indent: 0pt;text-align: left;">prob_vector1[1][pv1_len] = i - (prob_vector1[0][pv1_len] * 95); pv1_len++;</p><p class="s31" style="padding-left: 36pt;text-indent: 0pt;text-align: left;">}</p><p class="s31" style="padding-left: 27pt;text-indent: 0pt;text-align: left;">}</p><p class="s31" style="padding-left: 36pt;text-indent: -8pt;text-align: left;">for(i=0; i &lt; 9025; i++) { // Find possible last two plaintext bytes. if(get_vector_bit(bin_vector2, i)) {</p><p class="s31" style="padding-left: 44pt;text-indent: 0pt;text-align: left;">prob_vector2[0][pv2_len] = i / 95;</p><p class="s31" style="padding-left: 44pt;text-indent: 0pt;line-height: 107%;text-align: left;">prob_vector2[1][pv2_len] = i - (prob_vector2[0][pv2_len] * 95); pv2_len++;</p><p class="s31" style="padding-left: 36pt;text-indent: 0pt;line-height: 10pt;text-align: left;">}</p><p class="s31" style="padding-left: 27pt;text-indent: 0pt;text-align: left;">}</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-top: 4pt;padding-left: 27pt;text-indent: 0pt;text-align: left;">printf(&quot;Cracking remaining %d possibilites..\n&quot;, pv1_len*pv2_len); for(i=0; i &lt; pv1_len; i++) {</p><p class="s31" style="padding-left: 44pt;text-indent: -8pt;line-height: 107%;text-align: left;">for(j=0; j &lt; pv2_len; j++) { plain[0] = prob_vector1[0][i] + 32; plain[1] = prob_vector1[1][i] + 32; plain[2] = prob_vector2[0][j] + 32; plain[3] = prob_vector2[1][j] + 32; plain[4] = 0;</p><p class="s31" style="padding-left: 53pt;text-indent: -8pt;text-align: left;">if(strcmp(crypt(plain, &quot;je&quot;), pass) == 0) { printf(&quot;Password : %s\n&quot;, plain);</p><p class="s31" style="padding-left: 53pt;text-indent: 0pt;text-align: left;">i = 31337;</p><p class="s31" style="padding-left: 53pt;text-indent: 0pt;text-align: left;">j = 31337;</p><p class="s31" style="padding-left: 44pt;text-indent: 0pt;text-align: left;">}</p><p class="s31" style="padding-left: 36pt;text-indent: 0pt;text-align: left;">}</p><p class="s31" style="padding-left: 27pt;text-indent: 0pt;text-align: left;">}</p><p class="s31" style="padding-left: 27pt;text-indent: 0pt;text-align: left;">if(i &lt; 31337)</p><p class="s31" style="padding-left: 36pt;text-indent: 0pt;text-align: left;">printf(&quot;Password wasn&#39;t salted with &#39;je&#39; or is not 4 chars long.\n&quot;);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-top: 4pt;padding-left: 27pt;text-indent: 0pt;text-align: left;">fclose(fd);</p><p class="s31" style="padding-bottom: 3pt;padding-left: 19pt;text-indent: 0pt;text-align: left;">}</p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_1306.png"/></span></p><p style="padding-top: 7pt;padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: left;">The second piece of code, ppm_crack.c, can be used to crack the troublesome password of <span class="s31">h4R% </span>in a matter of seconds:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_1307.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">reader@hacking:~/booksrc $ ./crypt_test h4R% je</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 106%;text-align: left;">password &quot;h4R%&quot; with salt &quot;je&quot; hashes to ==&gt; jeMqqfIfPNNTE reader@hacking:~/booksrc $ gcc -O3 -o ppm_crack ppm_crack.c -lcrypt reader@hacking:~/booksrc $ ./ppm_crack jeMqqfIfPNNTE</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">Filtering possible plaintext bytes for the first two characters: only 1 vector of 4:  3801 plaintext pairs, with 42.12% saturation</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 106%;text-align: left;">vectors 1 AND 2 merged: 1666 plaintext pairs, with 18.46% saturation first 3 vectors merged: 695 plaintext pairs, with 7.70% saturation all 4 vectors merged:  287 plaintext pairs, with 3.18% saturation Possible plaintext pairs for the first two bytes:</p><p class="s31" style="padding-left: 95pt;text-indent: 0pt;line-height: 10pt;text-align: left;">4 9 N !&amp; !M !Q &quot;/ &quot;5 &quot;W #K #d #g #p $K $O $s %) %Z %\ %r &amp;( &amp;T &#39;- &#39;0 &#39;7 &#39;D</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">&#39;F ( (v (| )+ ). )E )W *c *p *q *t *x +C -5 -A -[ -a .% .D .S .f /t 02 07 0? 0e 0{ 0| 1A 1U 1V 1Z 1d 2V 2e 2q 3P 3a 3k 3m 4E 4M 4P 4X 4f 6 6, 6C 7: 7@ 7S</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 9pt;text-align: left;">7z 8F 8H 9R 9U 9_ 9~ :- :q :s ;G ;J ;Z ;k &lt;! &lt;8 =! =3 =H =L =N =Y &gt;V &gt;X ?1 @#</p><p class="s31" style="padding-top: 3pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">@W @v @| AO B/ B0 BO Bz C( D8 D&gt; E8 EZ F@ G&amp; G? Gj Gy H4 I@ J JN JT JU Jh Jq Ks Ku M) M{ N, N: NC NF NQ Ny O/ O[ P9 Pc Q! QA Qi Qv RA Sg Sv T0 Te U&amp; U&gt; UO VT V[ V] Vc Vg Vi W: WG X&quot; X6 XZ X` Xp YT YV Y^ Yl Yy Y{ Za [$ [* [9 [m [z \&quot; \</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">+ \C \O \w ]( ]: ]@ ]w _K _j `q a. aN a^ ae au b: bG bP cE cP dU d] e! fI fv g! gG h+ h4 hc iI iT iV iZ in k. kp l5 l` lm lq m, m= mE n0 nD nQ n~ o# o: o^ p0 p1 pC pc q* q0 qQ q{ rA rY s&quot; sD sz tK tw u- v$ v. v3 v; v_ vi vo wP wt x&quot; x&amp; x+ x1 xQ xX xi yN yo zO zP zU z[ z^ zf zi zr zt {- {B {a |s }) }+ }? }y ~L ~m</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">Filtering possible plaintext bytes for the last two characters:</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">only 1 vector of 4:   3821 plaintext pairs, with 42.34% saturation</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 106%;text-align: left;">vectors 1 AND 2 merged: 1677 plaintext pairs, with 18.58% saturation first 3 vectors merged: 713 plaintext pairs, with 7.90% saturation all 4 vectors merged:  297 plaintext pairs, with 3.29% saturation Possible plaintext pairs for the last two bytes:</p><p class="s31" style="padding-left: 95pt;text-indent: 0pt;line-height: 10pt;text-align: left;">! &amp; != !H !I !K !P !X !o !~ &quot;r &quot;{ &quot;} #% #0 $5 $] %K %M %T &amp;&quot; &amp;% &amp;( &amp;0 &amp;4 &amp;I</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">&amp;q &amp;} &#39;B &#39;Q &#39;d )j )w *I *] *e *j *k *o *w *| +B +W ,&#39; ,J ,V -z . .$ .T /&#39; /_ 0Y 0i 0s 1! 1= 1l 1v 2- 2/ 2g 2k 3n 4K 4Y 4\ 4y 5- 5M 5O 5} 6+ 62 6E 6j 7* 74</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 9pt;text-align: left;">8E 9Q 9\ 9a 9b :8 :; :A :H :S :w ;&quot; ;&amp; ;L &lt;L &lt;m &lt;r &lt;u =, =4 =v &gt;v &gt;x ?&amp; ?` ?j</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">?w @0 A* B B@ BT C8 CF CJ CN C} D+ D? DK Dc EM EQ FZ GO GR H) Hj I: I&gt; J( J+ J3 J6 Jm K# K) K@ L, L1 LT N* NW N` O= O[ Ot P: P\ Ps Q- Qa R% RJ RS S3 Sa T!</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 9pt;text-align: left;">T$ T@ TR T_ Th U&quot; U1 V* V{ W3 Wy Wz X% X* Y* Y? Yw Z7 Za Zh Zi Zm [F \( \3 \5 \</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">_ \a \b \| ]$ ]. ]2 ]? ]d ^[ ^~ `1 `F `f `y a8 a= aI aK az b, b- bS bz c( cg dB e, eF eJ eK eu fT fW fo g( g&gt; gW g\ h$ h9 h: h@ hk i? jN ji jn k= kj l7 lo m&lt; m= mT me m| m} n% n? n~ o oF oG oM p&quot; p9 p\ q} r6 r= rB sA sN s{ s~ tX tp u u2 uQ uU uk v# vG vV vW vl w* w&gt; wD wv x2 xA y: y= y? yM yU yX zK zv {# {) {=</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">{O {m |I |Z }. }; }d ~+ ~C ~a Building probability vectors...</p><p class="s31" style="padding-bottom: 2pt;padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">Cracking remaining 85239 possibilites.. Password : h4R% reader@hacking:~/booksrc $</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_1308.png"/></span></p><p style="padding-top: 7pt;padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: left;">These programs are proof-of-concept hacks, which take advantage of the bit diffusion provided by hash functions. There are other time-space trade-off attacks, and some have become quite popular. RainbowCrack is a popular tool, which has support for multiple algorithms. If you want to learn more, consult the Internet.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="toc">&nbsp;</p><div class="toc"><a class="toc0" href="part187.htm">0x770 Wireless 802.11b Encryption</a></div><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part185.htm">&lt; Previous</a><span> | </span><a href="../hacking-the-art-of-exploitation.html">Contents</a><span> | </span><a href="part187.htm">Next &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
