<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>0x283 User IDs</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part44.htm">&lt; Previous</a><span> | </span><a href="../hacking-the-art-of-exploitation.html">Contents</a><span> | </span><a href="part46.htm">Next &gt;</a></p><p class="s32" style="padding-left: 91pt;text-indent: 0pt;text-align: left;"><a name="bookmark35">0x283 User IDs</a></p><p style="padding-top: 7pt;padding-left: 91pt;text-indent: 0pt;line-height: 108%;text-align: left;">Every user on a Unix system has a unique user ID number. This user ID can be displayed using the <span class="s31">id </span>command.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_273.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">reader@hacking:~/booksrc $ id reader</p><p class="s46" style="padding-top: 1pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">uid=999(reader) <span class="s31">gid=999(reader) groups=999(reader),4(adm),20(dialout),24(cdrom),25(floppy),29(audio),30(dip),4 4(video),46(plugdev),104(scanner),112(netdev),113(lpadmin),115(powerdev),117(a dmin)</span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">reader@hacking:~/booksrc $ id matrix uid=500(matrix) gid=500(matrix) groups=500(matrix) reader@hacking:~/booksrc $ id root</p><p class="s31" style="padding-bottom: 2pt;padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">uid=0(root) gid=0(root) groups=0(root) reader@hacking:~/booksrc $</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_274.png"/></span></p><p style="padding-top: 7pt;padding-left: 91pt;text-indent: 18pt;line-height: 108%;text-align: left;">The root user with user ID 0 is like the administrator account, which has full access to the system. The <span class="s31">su </span>command can be used to switch to a differ- ent user, and if this command is run as root, it can be done without a pass- word. The <span class="s31">sudo </span>command allows a single command to be run as the root user. On the LiveCD, <span class="s31">sudo </span>has been configured so it can be executed without a pass- word, for simplicity’s sake. These commands provide a simple method to quickly switch between users.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_275.png"/></span></p><p class="s31" style="padding-bottom: 2pt;padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">reader@hacking:~/booksrc $ sudo su jose jose@hacking:/home/reader/booksrc $ id uid=501(jose) gid=501(jose) groups=501(jose) jose@hacking:/home/reader/booksrc $</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_276.png"/></span></p><p style="padding-top: 7pt;padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: justify;">As the user jose, the simplenote program will run as jose if it is executed, but it won’t have access to the /tmp/notes file. This file is owned by the user reader, and it only allows read and write permission to its owner.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_277.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">jose@hacking:/home/reader/booksrc $ ls -l /tmp/notes</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 106%;text-align: left;">-rw------- 1 reader reader 36 2007-09-07 05:20 /tmp/notes jose@hacking:/home/reader/booksrc $ ./simplenote &quot;a note for jose&quot; [DEBUG] buffer  @ 0x804a008: &#39;a note for jose&#39;</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">[DEBUG] datafile @ 0x804a070: &#39;/tmp/notes&#39;</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">[!!] Fatal Error in main() while opening file: Permission denied jose@hacking:/home/reader/booksrc $ cat /tmp/notes</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">cat: /tmp/notes: Permission denied jose@hacking:/home/reader/booksrc $ exit exit</p><p class="s31" style="padding-bottom: 3pt;padding-left: 91pt;text-indent: 0pt;line-height: 10pt;text-align: left;">reader@hacking:~/booksrc $</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_278.png"/></span></p><p style="padding-top: 7pt;padding-left: 91pt;text-indent: 18pt;line-height: 108%;text-align: left;">This is fine if reader is the only user of the simplenote program; however, there are many times when multiple users need to be able to access certain portions of the same file. For example, the /etc/passwd file contains account information for every user on the system, including each user’s default login shell. The command <span class="s31">chsh </span>allows any user to change his or her own login shell. This program needs to be able to make changes to the /etc/passwd file, but only on the line that pertains to the current user’s account. The solution to this problem in Unix is the <span class="s31">set user ID (setuid) </span>permission. This is an addi- tional file permission bit that can be set using <span class="s31">chmod</span>. When a program with this flag is executed, it runs as the user ID of the file’s owner.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_279.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">reader@hacking:~/booksrc $ which chsh</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">/usr/bin/chsh</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">reader@hacking:~/booksrc $ ls -l /usr/bin/chsh /etc/passwd</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">-rw-r--r-- 1 root root 1424 2007-09-06 21:05 /etc/passwd</p><p class="s31" style="padding-bottom: 3pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">-rw<b>s</b>r-xr-x 1 root root 23920 2006-12-19 20:35 /usr/bin/chsh reader@hacking:~/booksrc $</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_280.png"/></span></p><p style="padding-top: 7pt;padding-left: 91pt;text-indent: 18pt;line-height: 107%;text-align: left;">The <span class="s31">chsh </span>program has the <span class="s31">setuid </span>flag set, which is indicated by an <span class="s31">s </span>in the <span class="s31">ls </span>output above. Since this file is owned by root and has the <span class="s31">setuid </span>permission set, the program will run as the root user when <span class="s27">any </span>user runs this program. The /etc/passwd file that <span class="s31">chsh </span>writes to is also owned by root and only allows the owner to write to it. The program logic in <span class="s31">chsh </span>is designed to only allow writing to the line in /etc/passwd that corresponds to the user running the program, even though the program is effectively running as root. This means that a running program has both a real user ID and an effective user ID. These IDs can be retrieved using the functions <span class="s31">getuid() </span>and <span class="s31">geteuid()</span>, respectively, as shown in uid_demo.c.</p><p class="s40" style="padding-top: 4pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">uid_demo.c</p><p style="text-indent: 0pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_281.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 21pt;text-align: left;">#include &lt;stdio.h&gt; int main() {</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;line-height: 8pt;text-align: left;">printf(&quot;real uid: %d\n&quot;, getuid());</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;text-align: left;">printf(&quot;effective uid: %d\n&quot;, geteuid());</p><p class="s31" style="padding-bottom: 3pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">}</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_282.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 109pt;text-indent: 0pt;text-align: left;">The results of compiling and executing uid_demo.c are as follows.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_283.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">reader@hacking:~/booksrc $ gcc -o uid_demo uid_demo.c reader@hacking:~/booksrc $ ls -l uid_demo</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">-rwxr-xr-x 1 reader reader 6825 2007-09-07 05:32 uid_demo reader@hacking:~/booksrc $ ./uid_demo</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">real uid: 999</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">effective uid: 999</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">reader@hacking:~/booksrc $ sudo chown root:root ./uid_demo reader@hacking:~/booksrc $ ls -l uid_demo</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">-rwxr-xr-x 1 root root 6825 2007-09-07 05:32 uid_demo reader@hacking:~/booksrc $ ./uid_demo</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">real uid: 999</p><p class="s31" style="padding-bottom: 2pt;padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">effective uid: 999 reader@hacking:~/booksrc $</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_284.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 18pt;line-height: 108%;text-align: left;">In the output for uid_demo.c, both user IDs are shown to be 999 when <span class="s31">uid_demo </span>is executed, since 999 is the user ID for reader. Next, the <span class="s31">sudo </span>com- mand is used with the <span class="s31">chown </span>command to change the owner and group of <span class="s31">uid_demo </span>to root. The program can still be executed, since it has execute permission for other, and it shows that both user IDs remain 999, since that’s still the ID of the user.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_285.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">reader@hacking:~/booksrc $ chmod u+s ./uid_demo</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">chmod: changing permissions of `./uid_demo&#39;: Operation not permitted reader@hacking:~/booksrc $ sudo chmod u+s ./uid_demo reader@hacking:~/booksrc $ ls -l uid_demo</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">-rwsr-xr-x 1 root root 6825 2007-09-07 05:32 uid_demo reader@hacking:~/booksrc $ ./uid_demo</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">real uid: 999</p><p class="s31" style="padding-bottom: 2pt;padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">effective uid: 0 reader@hacking:~/booksrc $</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_286.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 18pt;line-height: 108%;text-align: left;">Since the program is owned by root now, <span class="s31">sudo </span>must be used to change file permissions on it. The <span class="s31">chmod u+s </span>command turns on the <span class="s31">setuid </span>permis- sion, which can be seen in the following <span class="s31">ls -l </span>output. Now when the user reader executes <span class="s31">uid_demo</span>, the effective user ID is 0 for root, which means the program can access files as root. This is how the <span class="s31">chsh </span>program is able to allow any user to change his or her login shell stored in /etc/passwd.</p><p style="padding-top: 3pt;padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: left;">This same technique can be used in a multiuser note-taking program. The next program will be a modification of the simplenote program; it will also record the user ID of each note’s original author. In addition, a new syntax for <span class="s31">#include </span>will be introduced.</p><p style="padding-left: 91pt;text-indent: 18pt;line-height: 108%;text-align: justify;">The <span class="s31">ec_malloc() </span>and <span class="s31">fatal() </span>functions have been useful in many of our programs. Rather than copy and paste these functions into each program, they can be put in a separate include file.</p><p class="s40" style="padding-top: 9pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">hacking.h</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_287.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">// A function to display an error message and then exit void fatal(char *message) {</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;text-align: left;">char error_message[100];</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-top: 4pt;padding-left: 104pt;text-indent: 0pt;line-height: 107%;text-align: left;">strcpy(error_message, &quot;[!!] Fatal Error &quot;); strncat(error_message, message, 83); perror(error_message);</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;text-align: left;">exit(-1);</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">}</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-top: 4pt;padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">// An error-checked malloc() wrapper function void *ec_malloc(unsigned int size) {</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;line-height: 10pt;text-align: left;">void *ptr;</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;line-height: 107%;text-align: left;">ptr = malloc(size); if(ptr == NULL)</p><p class="s31" style="padding-left: 104pt;text-indent: 12pt;text-align: left;">fatal(&quot;in ec_malloc() on memory allocation&quot;); return ptr;</p><p class="s31" style="padding-bottom: 3pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">}</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_288.png"/></span></p><p style="padding-top: 7pt;padding-left: 91pt;text-indent: 18pt;line-height: 108%;text-align: left;">In this new program, hacking.h, the functions can just be included. In C, when the filename for a <span class="s31">#include </span>is surrounded by <span class="s31">&lt; </span>and <span class="s31">&gt;</span>, the compiler looks for this file in standard include paths, such as /usr/include/. If the filename is surrounded by quotes, the compiler looks in the current directory. There- fore, if hacking.h is in the same directory as a program, it can be included with that program by typing <span class="s31">#include &quot;hacking.h&quot;</span>.</p><p style="padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: left;">The changed lines for the new notetaker program (notetaker.c) are displayed in bold.</p><p class="s40" style="padding-top: 9pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">notetaker.c</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_289.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;fcntl.h&gt; #include &lt;sys/stat.h&gt; <b>#include &quot;hacking.h&quot;</b></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">void usage(char *prog_name, char *filename) {</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;line-height: 107%;text-align: left;">printf(&quot;Usage: %s &lt;data to add to %s&gt;\n&quot;, prog_name, filename); exit(0);</p><p class="s31" style="padding-top: 2pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">}</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">void fatal(char *);       // A function for fatal errors</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">void *ec_malloc(unsigned int); // An error-checked malloc() wrapper</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 104pt;text-indent: -12pt;line-height: 107%;text-align: left;">int main(int argc, char *argv[]) { <b>int userid, fd; // File descriptor </b>char *buffer, *datafile;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;line-height: 107%;text-align: left;">buffer = (char *) ec_malloc(100); datafile = (char *) ec_malloc(20); <b>strcpy(datafile, &quot;/var/notes&quot;);</b></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 116pt;text-indent: -12pt;line-height: 107%;text-align: left;">if(argc &lt; 2)       // If there aren&#39;t command-line arguments, usage(argv[0], datafile); // display usage message and exit.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;text-align: left;">strcpy(buffer, argv[1]); // Copy into buffer.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;line-height: 107%;text-align: left;">printf(&quot;[DEBUG] buffer  @ %p: \&#39;%s\&#39;\n&quot;, buffer, buffer); printf(&quot;[DEBUG] datafile @ %p: \&#39;%s\&#39;\n&quot;, datafile, datafile);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 95pt;text-indent: 0pt;text-align: left;">// Opening the file</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;line-height: 107%;text-align: left;">fd = open(datafile, O_WRONLY|O_CREAT|O_APPEND, S_IRUSR|S_IWUSR); if(fd == -1)</p><p class="s31" style="padding-left: 104pt;text-indent: 12pt;text-align: left;">fatal(&quot;in main() while opening file&quot;); printf(&quot;[DEBUG] file descriptor is %d\n&quot;, fd);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s46" style="padding-left: 104pt;text-indent: 0pt;text-align: left;">userid = getuid(); // Get the real user ID.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">// Writing data</p><p class="s46" style="padding-left: 116pt;text-indent: -12pt;line-height: 107%;text-align: left;">if(write(fd, &amp;userid, 4) == -1) // Write user ID before note data. fatal(&quot;in main() while writing userid to file&quot;);</p><p class="s46" style="padding-left: 104pt;text-indent: 0pt;text-align: left;">write(fd, &quot;\n&quot;, 1); // Terminate line.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s46" style="padding-left: 116pt;text-indent: -12pt;line-height: 107%;text-align: left;">if(write(fd, buffer, strlen(buffer)) == -1) // Write note. fatal(&quot;in main() while writing buffer to file&quot;);</p><p class="s46" style="padding-left: 104pt;text-indent: 0pt;text-align: left;">write(fd, &quot;\n&quot;, 1); // Terminate line.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 104pt;text-indent: -12pt;line-height: 107%;text-align: left;">// Closing file if(close(fd) == -1)</p><p class="s31" style="padding-left: 116pt;text-indent: 0pt;text-align: left;">fatal(&quot;in main() while closing file&quot;);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-top: 4pt;padding-left: 104pt;text-indent: 0pt;line-height: 107%;text-align: left;">printf(&quot;Note has been saved.\n&quot;); free(buffer);</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;text-align: left;">free(datafile);</p><p class="s31" style="padding-bottom: 3pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">}</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_290.png"/></span></p><p style="padding-top: 7pt;padding-left: 91pt;text-indent: 18pt;line-height: 108%;text-align: justify;">The output file has been changed from /tmp/notes to /var/notes, so the data is now stored in a more permanent place. The <span class="s31">getuid() </span>function is used to get the real user ID, which is written to the datafile on the line before the note’s line is written. Since the <span class="s31">write() </span>function is expecting a pointer for its source, the <span class="s31">&amp; </span>operator is used on the integer value <span class="s31">userid </span>to provide its address.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_291.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">reader@hacking:~/booksrc $ gcc -o notetaker notetaker.c reader@hacking:~/booksrc $ sudo chown root:root ./notetaker reader@hacking:~/booksrc $ sudo chmod u+s ./notetaker reader@hacking:~/booksrc $ ls -l ./notetaker</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">-rwsr-xr-x 1 root root 9015 2007-09-07 05:48 ./notetaker reader@hacking:~/booksrc $ ./notetaker &quot;this is a test of multiuser notes&quot; [DEBUG] buffer  @ 0x804a008: &#39;this is a test of multiuser notes&#39;</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">[DEBUG] datafile @ 0x804a070: &#39;/var/notes&#39; [DEBUG] file descriptor is 3</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">Note has been saved. reader@hacking:~/booksrc $ ls -l /var/notes</p><p class="s31" style="padding-bottom: 3pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">-rw------- 1 root reader 39 2007-09-07 05:49 /var/notes reader@hacking:~/booksrc $</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_292.png"/></span></p><p style="padding-top: 7pt;padding-left: 91pt;text-indent: 18pt;line-height: 108%;text-align: left;">In the preceding output, the notetaker program is compiled and changed to be owned by root, and the <span class="s31">setuid </span>permission is set. Now when the program is executed, the program runs as the root user, so the file /var/notes is also owned by root when it is created.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_293.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">reader@hacking:~/booksrc $ cat /var/notes cat: /var/notes: Permission denied</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">reader@hacking:~/booksrc $ sudo cat /var/notes</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">?</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">this is a test of multiuser notes reader@hacking:~/booksrc $ sudo hexdump -C /var/notes</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">00000000 <b>e7 03 00 00 </b>0a 74 68 69 73 20 69 73 20 61 20 74 |.....this is a t|</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">00000010 65 73 74 20 6f 66 20 6d 75 6c 74 69 75 73 65 72 |est of multiuser|</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">00000020 20 6e 6f 74 65 73 0a               | notes.|</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">00000027</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">reader@hacking:~/booksrc $ pcalc 0x03e7</p><p class="s31" style="padding-left: 125pt;text-indent: 0pt;text-align: left;">999       0x3e7      0y1111100111</p><p class="s31" style="padding-bottom: 3pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">reader@hacking:~/booksrc $</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_294.png"/></span></p><p style="padding-top: 7pt;padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: justify;">The /var/notes file contains the user ID of reader (999) and the note. Because of little-endian architecture, the 4 bytes of the integer 999 appear reversed in hexadecimal (shown in bold above).</p><p style="padding-left: 91pt;text-indent: 18pt;line-height: 108%;text-align: left;">In order for a normal user to be able to read the note data, a correspond- ing <span class="s31">setuid </span>root program is needed. The notesearch.c program will read the note data and only display the notes written by that user ID. Additionally, an optional command-line argument can be supplied for a search string. When this is used, only notes matching the search string will be displayed.</p><p class="s40" style="padding-top: 9pt;padding-left: 91pt;text-indent: 0pt;text-align: left;"><a name="bookmark41">notesearch.c</a></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_295.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 106%;text-align: left;">#include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;fcntl.h&gt; #include &lt;sys/stat.h&gt; #include &quot;hacking.h&quot;</p><p class="s31" style="padding-top: 2pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">#define FILENAME &quot;/var/notes&quot;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">int print_notes(int, int, char *);  // Note printing function.</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">int find_user_note(int, int);    // Seek in file for a note for user. int search_note(char *, char *);   // Search for keyword function.</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 10pt;text-align: left;">void fatal(char *);         // Fatal error handler</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">int main(int argc, char *argv[]) {</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;text-align: left;">int userid, printing=1, fd; // File descriptor char searchstring[100];</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 116pt;text-indent: -12pt;line-height: 107%;text-align: left;">if(argc &gt; 1)            // If there is an arg, strcpy(searchstring, argv[1]);  //  that is the search string;</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;line-height: 10pt;text-align: left;">else                 // otherwise,</p><p class="s31" style="padding-left: 116pt;text-indent: 0pt;text-align: left;">searchstring[0] = 0;      //  search string is empty.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;text-align: left;">userid = getuid();</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;line-height: 107%;text-align: left;">fd = open(FILENAME, O_RDONLY);  // Open the file for read-only access. if(fd == -1)</p><p class="s31" style="padding-left: 116pt;text-indent: 0pt;text-align: left;">fatal(&quot;in main() while opening file for reading&quot;);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-top: 4pt;padding-left: 104pt;text-indent: 0pt;text-align: left;">while(printing)</p><p class="s31" style="padding-left: 104pt;text-indent: 12pt;line-height: 107%;text-align: left;">printing = print_notes(fd, userid, searchstring); printf(&quot;-------[ end of note data ]   \n&quot;);</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;text-align: left;">close(fd);</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">}</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-top: 4pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">// A function to print the notes for a given uid that match</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">// an optional search string;</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">// returns 0 at end of file, 1 if there are still more notes. int print_notes(int fd, int uid, char *searchstring) {</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;text-align: left;">int note_length;</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;text-align: left;">char byte=0, note_buffer[100];</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;line-height: 107%;text-align: left;">note_length = find_user_note(fd, uid); if(note_length == -1) // If end of file reached,</p><p class="s31" style="padding-left: 116pt;text-indent: 0pt;text-align: left;">return 0;      //  return 0.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;line-height: 107%;text-align: left;">read(fd, note_buffer, note_length); // Read note data. note_buffer[note_length] = 0;    // Terminate the string.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-top: 4pt;padding-left: 116pt;text-indent: -12pt;line-height: 107%;text-align: left;">if(search_note(note_buffer, searchstring)) // If searchstring found, printf(note_buffer);          //  print the note.</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;text-align: left;">return 1;</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">}</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-top: 4pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">// A function to find the next note for a given userID;</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">// returns -1 if the end of the file is reached;</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">// otherwise, it returns the length of the found note. int find_user_note(int fd, int user_uid) {</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;line-height: 107%;text-align: left;">int note_uid=-1; unsigned char byte; int length;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;text-align: left;">while(note_uid != user_uid) { // Loop until a note for user_uid is found.</p><p class="s31" style="padding-top: 2pt;padding-left: 116pt;text-indent: 0pt;text-align: left;">if(read(fd, &amp;note_uid, 4) != 4) // Read the uid data.</p><p class="s31" style="padding-left: 116pt;text-indent: 12pt;text-align: left;">return -1; // If 4 bytes aren&#39;t read, return end of file code. if(read(fd, &amp;byte, 1) != 1) // Read the newline separator.</p><p class="s31" style="padding-left: 129pt;text-indent: 0pt;text-align: left;">return -1;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 116pt;text-indent: 0pt;text-align: left;">byte = length = 0;</p><p class="s31" style="padding-left: 129pt;text-indent: -12pt;text-align: left;">while(byte != &#39;\n&#39;) { // Figure out how many bytes to the end of line. if(read(fd, &amp;byte, 1) != 1) // Read a single byte.</p><p class="s31" style="padding-left: 129pt;text-indent: 12pt;line-height: 107%;text-align: left;">return -1;   // If byte isn&#39;t read, return end of file code. length++;</p><p class="s31" style="padding-left: 116pt;text-indent: 0pt;line-height: 10pt;text-align: left;">}</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;text-align: left;">}</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;text-align: left;">lseek(fd, length * -1, SEEK_CUR); // Rewind file reading by length bytes.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-top: 4pt;padding-left: 104pt;text-indent: 0pt;line-height: 107%;text-align: left;">printf(&quot;[DEBUG] found a %d byte note for user id %d\n&quot;, length, note_uid); return length;</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 10pt;text-align: left;">}</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-top: 4pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">// A function to search a note for a given keyword;</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">// returns 1 if a match is found, 0 if there is no match. int search_note(char *note, char *keyword) {</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;text-align: left;">int i, keyword_length, match=0;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;text-align: left;">keyword_length = strlen(keyword);</p><p class="s31" style="padding-left: 116pt;text-indent: -12pt;text-align: left;">if(keyword_length == 0) // If there is no search string, return 1;       // always &quot;match&quot;.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 116pt;text-indent: -12pt;text-align: left;">for(i=0; i &lt; strlen(note); i++) { // Iterate over bytes in note. if(note[i] == keyword[match]) // If byte matches keyword,</p><p class="s31" style="padding-left: 116pt;text-indent: 12pt;line-height: 107%;text-align: left;">match++;  // get ready to check the next byte; else {    //  otherwise,</p><p class="s31" style="padding-left: 142pt;text-indent: -13pt;text-align: left;">if(note[i] == keyword[0]) // if that byte matches first keyword byte, match = 1; // start the match count at 1.</p><p class="s31" style="padding-left: 129pt;text-indent: 0pt;text-align: left;">else</p><p class="s31" style="padding-left: 142pt;text-indent: 0pt;text-align: left;">match = 0; // Otherwise it is zero.</p><p class="s31" style="padding-left: 116pt;text-indent: 0pt;text-align: left;">}</p><p class="s31" style="padding-left: 129pt;text-indent: -12pt;text-align: left;">if(match == keyword_length) // If there is a full match, return 1;  // return matched.</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;line-height: 10pt;text-align: left;">}</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;text-align: left;">return 0; // Return not matched.</p><p class="s31" style="padding-bottom: 3pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">}</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_296.png"/></span></p><p style="padding-top: 6pt;padding-left: 109pt;text-indent: 0pt;text-align: left;">Most of this code should make sense, but there are some new concepts.</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 108%;text-align: left;">The filename is defined at the top instead of using heap memory. Also, the function <span class="s31">lseek() </span>is used to rewind the read position in the file. The function call of <span class="s31">lseek(fd, length * -1, SEEK_CUR); </span>tells the program to move the read position forward from the current position in the file by <span class="s31">length * -1 </span>bytes.</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 108%;text-align: left;">Since this turns out to be a negative number, the position is moved backward by <span class="s31">length </span>bytes.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_297.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">reader@hacking:~/booksrc $ gcc -o notesearch notesearch.c reader@hacking:~/booksrc $ sudo chown root:root ./notesearch reader@hacking:~/booksrc $ sudo chmod u+s ./notesearch reader@hacking:~/booksrc $ ./notesearch</p><p class="s31" style="padding-top: 2pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">[DEBUG] found a 34 byte note for user id 999 this is a test of multiuser notes</p><p class="s31" style="padding-bottom: 2pt;padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">-------[ end of note data ]------- reader@hacking:~/booksrc $</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_298.png"/></span></p><p style="padding-top: 6pt;padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: left;">When compiled and <span class="s31">setuid </span>root, the notesearch program works as expected. But this is just a single user; what happens if a different user uses the notetaker and notesearch programs?</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_299.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">reader@hacking:~/booksrc $ sudo su jose jose@hacking:/home/reader/booksrc $ ./notetaker &quot;This is a note for jose&quot; [DEBUG] buffer  @ 0x804a008: &#39;This is a note for jose&#39;</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">[DEBUG] datafile @ 0x804a070: &#39;/var/notes&#39; [DEBUG] file descriptor is 3</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">Note has been saved. jose@hacking:/home/reader/booksrc $ ./notesearch [DEBUG] found a 24 byte note for user id 501 This is a note for jose</p><p class="s31" style="padding-bottom: 2pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">-------[ end of note data ]------- jose@hacking:/home/reader/booksrc $</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_300.png"/></span></p><p style="padding-top: 7pt;padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: left;">When the user jose uses these programs, the real user ID is 501. This means that value is added to all notes written with notetaker, and only notes with a matching user ID will be displayed by the notesearch program.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_301.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">reader@hacking:~/booksrc $ ./notetaker &quot;This is another note for the reader user&quot; [DEBUG] buffer  @ 0x804a008: &#39;This is another note for the reader user&#39;</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">[DEBUG] datafile @ 0x804a070: &#39;/var/notes&#39; [DEBUG] file descriptor is 3</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">Note has been saved. reader@hacking:~/booksrc $ ./notesearch [DEBUG] found a 34 byte note for user id 999 this is a test of multiuser notes</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">[DEBUG] found a 41 byte note for user id 999 This is another note for the reader user</p><p class="s31" style="padding-bottom: 2pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">-------[ end of note data ]------- reader@hacking:~/booksrc $</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_302.png"/></span></p><p style="padding-top: 7pt;padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: left;">Similarly, all notes for the user reader have the user ID 999 attached to them. Even though both the notetaker and notesearch programs are <span class="s31">suid </span>root and have full read and write access to the /var/notes datafile, the pro- gram logic in the notesearch program prevents the current user from view- ing other users’ notes. This is very similar to how the /etc/passwd file stores user information for all users, yet programs like <span class="s31">chsh </span>and <span class="s31">passwd </span>allow any user to change his own shell or password.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part44.htm">&lt; Previous</a><span> | </span><a href="../hacking-the-art-of-exploitation.html">Contents</a><span> | </span><a href="part46.htm">Next &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
