<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>0x421 Socket Functions</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part75.htm">&lt; Previous</a><span> | </span><a href="../hacking-the-art-of-exploitation.html">Contents</a><span> | </span><a href="part77.htm">Next &gt;</a></p><p class="s32" style="padding-left: 91pt;text-indent: 0pt;text-align: left;"><a name="bookmark65">0x421 Socket Functions</a></p><p style="padding-top: 7pt;padding-left: 91pt;text-indent: 0pt;line-height: 108%;text-align: left;">In C, sockets behave a lot like files since they use file descriptors to identify themselves. Sockets behave so much like files that you can actually use the <span class="s31">read() </span>and <span class="s31">write() </span>functions to receive and send data using socket file descrip- tors. However, there are several functions specifically designed for dealing with sockets. These functions have their prototypes defined in /usr/include/ sys/sockets.h.</p><p class="s46" style="padding-top: 6pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">socket(int domain, int type, int protocol)</p><p style="padding-top: 1pt;padding-left: 109pt;text-indent: 0pt;text-align: left;">Used to create a new socket, returns a file descriptor for the socket or</p><p class="s31" style="padding-left: 109pt;text-indent: 0pt;text-align: left;">-1 <span class="p">on error.</span></p><p style="padding-top: 7pt;padding-left: 109pt;text-indent: -18pt;line-height: 110%;text-align: left;"><span class="s46">connect(int fd, struct sockaddr *remote_host, socklen_t addr_length) </span>Connects a socket (described by file descriptor <span class="s31">fd</span>) to a remote host. Returns <span class="s31">0 </span>on success and <span class="s31">-1 </span>on error.</p><p class="s46" style="padding-top: 6pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">bind(int fd, struct sockaddr *local_addr, socklen_t addr_length)</p><p style="padding-top: 1pt;padding-left: 109pt;text-indent: 0pt;line-height: 108%;text-align: left;">Binds a socket to a local address so it can listen for incoming connections. Returns <span class="s31">0 </span>on success and <span class="s31">-1 </span>on error.</p><p class="s46" style="padding-top: 6pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">listen(int fd, int backlog_queue_size)</p><p style="padding-top: 1pt;padding-left: 109pt;text-indent: 0pt;text-align: left;">Listens for incoming connections and queues connection requests up to</p><p class="s31" style="padding-left: 109pt;text-indent: 0pt;text-align: left;">backlog_queue_size<span class="p">. Returns </span>0 <span class="p">on success and </span>-1 <span class="p">on error.</span></p><p class="s46" style="padding-top: 7pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">accept(int fd, sockaddr *remote_host, socklen_t *addr_length)</p><p style="padding-top: 1pt;padding-left: 109pt;text-indent: 0pt;line-height: 108%;text-align: left;">Accepts an incoming connection on a bound socket. The address infor- mation from the remote host is written into the <span class="s31">remote_host </span>structure and the actual size of the address structure is written into <span class="s31">*addr_length</span>. This function returns a new socket file descriptor to identify the connected socket or <span class="s31">-1 </span>on error.</p><p class="s46" style="padding-top: 6pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">send(int fd, void *buffer, size_t <span class="s78">n</span>, int flags)</p><p style="padding-top: 1pt;padding-left: 109pt;text-indent: 0pt;line-height: 108%;text-align: left;">Sends <span class="s33">n </span>bytes from <span class="s31">*buffer </span>to socket <span class="s31">fd</span>; returns the number of bytes sent or <span class="s31">-1 </span>on error.</p><p class="s46" style="padding-top: 6pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">recv(int fd, void *buffer, size_t <span class="s78">n</span>, int flags)</p><p style="padding-top: 1pt;padding-left: 109pt;text-indent: 0pt;line-height: 108%;text-align: left;">Receives <span class="s33">n </span>bytes from socket <span class="s31">fd </span>into <span class="s31">*buffer</span>; returns the number of bytes received or <span class="s31">-1 </span>on error.</p><p style="padding-top: 5pt;padding-left: 91pt;text-indent: 18pt;line-height: 108%;text-align: left;">When a socket is created with the <span class="s31">socket() </span>function, the domain, type, and protocol of the socket must be specified. The domain refers to the pro- tocol family of the socket. A socket can be used to communicate using a variety of protocols, from the standard Internet protocol used when you browse the Web to amateur radio protocols such as AX.25 (when you are being a gigantic nerd). These protocol families are defined in bits/socket.h, which is automatically included from sys/socket.h.</p><p class="s40" style="padding-top: 4pt;padding-left: 19pt;text-indent: 0pt;text-align: left;">From /usr/include/bits/socket.h</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_603.png"/></span></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">/* Protocol families. */</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">#define PF_UNSPEC 0 /* Unspecified. */</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">#define PF_LOCAL 1 /* Local to host (pipes and file-domain). */ #define PF_UNIX  PF_LOCAL /* Old BSD name for PF_LOCAL. */</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">#define PF_FILE  PF_LOCAL /* Another nonstandard name for PF_LOCAL. */ #define PF_INET  2 /* IP protocol family. */</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">#define PF_AX25  3 /* Amateur Radio AX.25. */ #define PF_IPX   4 /* Novell Internet Protocol. */ #define PF_APPLETALK  5 /* Appletalk DDP. */ #define PF_NETROM 6 /* Amateur radio NetROM.  */ #define PF_BRIDGE 7 /* Multiprotocol bridge.  */ #define PF_ATMPVC 8 /* ATM PVCs. */</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">#define PF_X25  9 /* Reserved for X.25 project. */ #define PF_INET6 10 /* IP version 6. */</p><p class="s31" style="padding-bottom: 3pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">...</p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_604.png"/></span></p><p style="padding-top: 7pt;padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: left;">As mentioned before, there are several types of sockets, although stream sockets and datagram sockets are the most commonly used. The types of sockets are also defined in bits/socket.h. (The <span class="s31">/* comments */ </span>in the code above are just another style that comments out everything between the asterisks.)</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s40" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">From /usr/include/bits/socket.h</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_605.png"/></span></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">/* Types of sockets. */ enum <u>&nbsp;</u>socket_type</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 10pt;text-align: left;">{</p><p class="s31" style="padding-left: 19pt;text-indent: 8pt;line-height: 107%;text-align: left;">SOCK_STREAM = 1,  /* Sequenced, reliable, connection-based byte streams. */ #define SOCK_STREAM SOCK_STREAM</p><p class="s31" style="padding-left: 19pt;text-indent: 8pt;text-align: left;">SOCK_DGRAM = 2,  /* Connectionless, unreliable datagrams of fixed maximum length. */ #define SOCK_DGRAM SOCK_DGRAM</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-top: 4pt;padding-bottom: 3pt;padding-left: 27pt;text-indent: 0pt;text-align: left;">...</p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_606.png"/></span></p><p style="padding-top: 7pt;padding-left: 91pt;text-indent: 18pt;line-height: 108%;text-align: left;">The final argument for the <span class="s31">socket() </span>function is the protocol, which should almost always be <span class="s31">0</span>. The specification allows for multiple protocols within a protocol family, so this argument is used to select one of the protocols from the family. In practice, however, most protocol families only have one pro- tocol, which means this should usually be set for <span class="s31">0</span>; the first and only protocol in the enumeration of the family. This is the case for everything we will do with sockets in this book, so this argument will always be <span class="s31">0 </span>in our examples.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part75.htm">&lt; Previous</a><span> | </span><a href="../hacking-the-art-of-exploitation.html">Contents</a><span> | </span><a href="part77.htm">Next &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
