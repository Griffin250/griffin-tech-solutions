<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>0x425 A Simple Server Example</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part79.htm">&lt; Previous</a><span> | </span><a href="../hacking-the-art-of-exploitation.html">Contents</a><span> | </span><a href="part81.htm">Next &gt;</a></p><p class="s32" style="padding-left: 91pt;text-indent: 0pt;text-align: left;"><a name="bookmark69">0x425 A Simple Server Example</a></p><p style="padding-top: 7pt;padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">The best way to show how these functions are used is by example. The following server code listens for TCP connections on port 7890. When a client connects, it sends the message <span class="s27">Hello, world! </span>and then receives data until the connection is closed. This is done using socket functions and structures from the include files mentioned earlier, so these files are included at the beginning of the program. A useful memory dump function has been added to hacking.h, which is shown on the following page.</p><p class="s40" style="padding-top: 4pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">Added to hacking.h</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_628.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">// Dumps raw memory in hex byte and printable split format</p><p class="s31" style="padding-left: 103pt;text-indent: -12pt;line-height: 107%;text-align: left;">void dump(const unsigned char *data_buffer, const unsigned int length) { unsigned char byte;</p><p class="s31" style="padding-left: 103pt;text-indent: 0pt;text-align: left;">unsigned int i, j;</p><p class="s31" style="padding-left: 116pt;text-indent: -12pt;text-align: left;">for(i=0; i &lt; length; i++) { byte = data_buffer[i];</p><p class="s31" style="padding-left: 116pt;text-indent: 0pt;line-height: 107%;text-align: left;">printf(&quot;%02x &quot;, data_buffer[i]); // Display byte in hex. if(((i%16)==15) || (i==length-1)) {</p><p class="s31" style="padding-left: 128pt;text-indent: 0pt;text-align: left;">for(j=0; j &lt; 15-(i%16); j++)</p><p class="s31" style="padding-left: 141pt;text-indent: 0pt;text-align: left;">printf(&quot;  &quot;);</p><p class="s31" style="padding-left: 128pt;text-indent: 0pt;text-align: left;">printf(&quot;| &quot;);</p><p class="s31" style="padding-left: 141pt;text-indent: -12pt;line-height: 107%;text-align: left;">for(j=(i-(i%16)); j &lt;= i; j++) { // Display printable bytes from line. byte = data_buffer[j];</p><p class="s31" style="padding-left: 153pt;text-indent: -12pt;line-height: 107%;text-align: left;">if((byte &gt; 31) &amp;&amp; (byte &lt; 127)) // Outside printable char range printf(&quot;%c&quot;, byte);</p><p class="s31" style="padding-left: 141pt;text-indent: 0pt;text-align: left;">else</p><p class="s31" style="padding-left: 153pt;text-indent: 0pt;text-align: left;">printf(&quot;.&quot;);</p><p class="s31" style="padding-left: 128pt;text-indent: 0pt;text-align: left;">}</p><p class="s31" style="padding-left: 128pt;text-indent: 0pt;text-align: left;">printf(&quot;\n&quot;); // End of the dump line (each line is 16 bytes)</p><p class="s31" style="padding-left: 116pt;text-indent: 0pt;text-align: left;">} // End if</p><p class="s31" style="padding-left: 103pt;text-indent: 0pt;text-align: left;">} // End for</p><p class="s31" style="padding-bottom: 3pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">}</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_629.png"/></span></p><p style="padding-top: 7pt;padding-left: 109pt;text-indent: 0pt;text-align: left;">This function is used to display packet data by the server program.</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 108%;text-align: left;">However, since it is also useful in other places, it has been put into hacking.h, instead. The rest of the server program will be explained as you read the source code.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s40" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">simple_server.c</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_630.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;sys/socket.h&gt; #include &lt;netinet/in.h&gt; #include &lt;arpa/inet.h&gt; #include &quot;hacking.h&quot;</p><p class="s31" style="padding-top: 1pt;padding-left: 91pt;text-indent: 0pt;line-height: 21pt;text-align: left;">#define PORT 7890 // The port users will be connecting to int main(void) {</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;line-height: 8pt;text-align: left;">int sockfd, new_sockfd; // Listen on sock_fd, new connection on new_fd</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;line-height: 107%;text-align: left;">struct sockaddr_in host_addr, client_addr;  // My address information socklen_t sin_size;</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;text-align: left;">int recv_length=1, yes=1; char buffer[1024];</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;text-align: left;">if ((sockfd = socket(PF_INET, SOCK_STREAM, 0)) == -1)</p><p class="s31" style="padding-top: 2pt;padding-left: 116pt;text-indent: 0pt;text-align: left;">fatal(&quot;in socket&quot;);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-bottom: 2pt;padding-left: 116pt;text-indent: -12pt;line-height: 107%;text-align: left;">if (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &amp;yes, sizeof(int)) == -1) fatal(&quot;setting socket option SO_REUSEADDR&quot;);</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_631.png"/></span></p><p style="padding-top: 6pt;padding-left: 91pt;text-indent: 18pt;line-height: 108%;text-align: left;">So far, the program sets up a socket using the <span class="s31">socket() </span>function. We want a TCP/IP socket, so the protocol family is <span class="s31">PF_INET </span>for IPv4 and the socket type is <span class="s31">SOCK_STREAM </span>for a stream socket. The final protocol argument is <span class="s31">0</span>, since there is only one protocol in the <span class="s31">PF_INET </span>protocol family. This function returns a socket file descriptor which is stored in <span class="s31">sockfd</span>.</p><p style="padding-left: 91pt;text-indent: 18pt;line-height: 108%;text-align: justify;">The <span class="s31">setsockopt() </span>function is simply used to set socket options. This func- tion call sets the <span class="s31">SO_REUSEADDR </span>socket option to <span class="s31">true</span>, which will allow it to reuse a given address for binding. Without this option set, when the program tries to bind to a given port, it will fail if that port is already in use. If a socket isn’t closed properly, it may appear to be in use, so this option lets a socket bind to a port (and take over control of it), even if it seems to be in use.</p><p style="padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: left;">The first argument to this function is the socket (referenced by a file descriptor), the second specifies the level of the option, and the third specifies the option itself. Since <span class="s31">SO_REUSEADDR </span>is a socket-level option, the level is set to <span class="s31">SOL_SOCKET</span>. There are many different socket options defined in /usr/include/ asm/socket.h. The final two arguments are a pointer to the data that the option should be set to and the length of that data. A pointer to data and the length of that data are two arguments that are often used with socket func- tions. This allows the functions to handle all sorts of data, from single bytes to large data structures. The <span class="s31">SO_REUSEADDR </span>options uses a 32-bit integer for its value, so to set this option to <span class="s31">true</span>, the final two arguments must be a pointer to the integer value of <span class="s31">1 </span>and the size of an integer (which is 4 bytes).</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_632.png"/></span></p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;line-height: 106%;text-align: left;">host_addr.sin_family = AF_INET;  // Host byte order host_addr.sin_port = htons(PORT); // Short, network byte order host_addr.sin_addr.s_addr = 0; // Automatically fill with my IP. memset(&amp;(host_addr.sin_zero), &#39;\0&#39;, 8); // Zero the rest of the struct.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 107pt;text-indent: -8pt;line-height: 107%;text-align: left;">if (bind(sockfd, (struct sockaddr *)&amp;host_addr, sizeof(struct sockaddr)) == -1) fatal(&quot;binding to socket&quot;);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-bottom: 3pt;padding-left: 107pt;text-indent: -8pt;text-align: left;">if (listen(sockfd, 5) == -1) fatal(&quot;listening on socket&quot;);</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_633.png"/></span></p><p style="padding-top: 6pt;padding-left: 91pt;text-indent: 18pt;line-height: 108%;text-align: left;">These next few lines set up the <span class="s31">host_addr </span>structure for use in the bind call. The address family is <span class="s31">AF_INET</span>, since we are using IPv4 and the <span class="s31">sockaddr_in </span>structure. The port is set to <span class="s31">PORT</span>, which is defined as <span class="s31">7890</span>. This short integer value must be converted into network byte order, so the <span class="s31">htons() </span>function is used. The address is set to <span class="s31">0</span>, which means it will automatically be filled with the host’s current IP address. Since the value <span class="s31">0 </span>is the same regardless of byte order, no conversion is necessary.</p><p style="padding-left: 91pt;text-indent: 18pt;line-height: 108%;text-align: left;">The <span class="s31">bind() </span>call passes the socket file descriptor, the address structure, and the length of the address structure. This call will bind the socket to the current IP address on port 7890.</p><p style="padding-top: 3pt;padding-left: 91pt;text-indent: 18pt;line-height: 108%;text-align: left;">The <span class="s31">listen() </span>call tells the socket to listen for incoming connections, and a subsequent <span class="s31">accept() </span>call actually accepts an incoming connection. The <span class="s31">listen() </span>function places all incoming connections into a backlog queue until an <span class="s31">accept() </span>call accepts the connections. The last argument to the <span class="s31">listen() </span>call sets the maximum size for the backlog queue.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_634.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">while(1) {  // Accept loop.</p><p class="s31" style="padding-left: 116pt;text-indent: 0pt;text-align: left;">sin_size = sizeof(struct sockaddr_in);</p><p class="s31" style="padding-left: 116pt;text-indent: 0pt;line-height: 107%;text-align: left;">new_sockfd = accept(sockfd, (struct sockaddr *)&amp;client_addr, &amp;sin_size); if(new_sockfd == -1)</p><p class="s31" style="padding-left: 129pt;text-indent: 0pt;line-height: 10pt;text-align: left;">fatal(&quot;accepting connection&quot;);</p><p class="s31" style="padding-left: 150pt;text-indent: -34pt;text-align: left;">printf(&quot;server: got connection from %s port %d\n&quot;, inet_ntoa(client_addr.sin_addr), ntohs(client_addr.sin_port));</p><p class="s31" style="padding-left: 116pt;text-indent: 0pt;text-align: left;">send(new_sockfd, &quot;Hello, world!\n&quot;, 13, 0);</p><p class="s31" style="padding-left: 116pt;text-indent: 0pt;line-height: 107%;text-align: left;">recv_length = recv(new_sockfd, &amp;buffer, 1024, 0); while(recv_length &gt; 0) {</p><p class="s31" style="padding-left: 129pt;text-indent: 0pt;text-align: left;">printf(&quot;RECV: %d bytes\n&quot;, recv_length); dump(buffer, recv_length);</p><p class="s31" style="padding-left: 129pt;text-indent: 0pt;text-align: left;">recv_length = recv(new_sockfd, &amp;buffer, 1024, 0);</p><p class="s31" style="padding-left: 116pt;text-indent: 0pt;text-align: left;">}</p><p class="s31" style="padding-left: 116pt;text-indent: 0pt;text-align: left;">close(new_sockfd);</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;text-align: left;">}</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;text-align: left;">return 0;</p><p class="s31" style="padding-bottom: 3pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">}</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_635.png"/></span></p><p style="padding-top: 8pt;padding-left: 91pt;text-indent: 18pt;line-height: 108%;text-align: left;">Next is a loop that accepts incoming connections. The <span class="s31">accept() </span>function’s first two arguments should make sense immediately; the final argument is a pointer to the size of the address structure. This is because the <span class="s31">accept() </span>func- tion will write the connecting client’s address information into the address structure and the size of that structure into <span class="s31">sin_size</span>. For our purposes, the size never changes, but to use the function we must obey the calling conven- tion. The <span class="s31">accept() </span>function returns a new socket file descriptor for the accepted connection. This way, the original socket file descriptor can continue to</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 108%;text-align: left;">be used for accepting new connections, while the new socket file descriptor is used for communicating with the connected client.</p><p style="padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: justify;">After getting a connection, the program prints out a connection message, using <span class="s31">inet_ntoa() </span>to convert the <span class="s31">sin_addr </span>address structure to a dotted-number IP string and <span class="s31">ntohs() </span>to convert the byte order of the <span class="s31">sin_port </span>number.</p><p style="padding-left: 91pt;text-indent: 18pt;line-height: 108%;text-align: left;">The <span class="s31">send() </span>function sends the 13 bytes of the string <span class="s31">Hello, world!\n </span>to the new socket that describes the new connection. The final argument for the <span class="s31">send() </span>and <span class="s31">recv() </span>functions are flags, that for our purposes, will always be <span class="s31">0</span>.</p><p style="padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: left;">Next is a loop that receives data from the connection and prints it out. The <span class="s31">recv() </span>function is given a pointer to a buffer and a maximum length to read from the socket. The function writes the data into the buffer passed to it and returns the number of bytes it actually wrote. The loop will continue as long as the <span class="s31">recv() </span>call continues to receive data.</p><p style="padding-top: 3pt;padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: justify;">When compiled and run, the program binds to port 7890 of the host and waits for incoming connections:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_636.png"/></span></p><p class="s31" style="padding-bottom: 2pt;padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">reader@hacking:~/booksrc $ gcc simple_server.c reader@hacking:~/booksrc $ ./a.out</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_637.png"/></span></p><p style="padding-top: 8pt;padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: justify;">A telnet client basically works like a generic TCP connection client, so it can be used to connect to the simple server by specifying the target IP address and port.</p><p class="s40" style="padding-top: 9pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">From a Remote Machine</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_638.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">matrix@euclid:~ $ telnet 192.168.42.248 7890</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">Trying 192.168.42.248...</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">Connected to 192.168.42.248. Escape character is &#39;^]&#39;.</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">Hello, world! this is a test</p><p class="s31" style="padding-bottom: 3pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">fjsghau;ehg;ihskjfhasdkfjhaskjvhfdkjhvbkjgf</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_639.png"/></span></p><p style="padding-top: 7pt;padding-left: 91pt;text-indent: 18pt;line-height: 108%;text-align: left;">Upon connection, the server sends the string <span class="s31">Hello, world!</span>, and the rest is the local character echo of me typing <span class="s31">this is a test </span>and a line of keyboard mashing. Since telnet is line-buffered, each of these two lines is sent back to the server when <span class="s7">ENTER </span>is pressed. Back on the server side, the output shows the connection and the packets of data that are sent back.</p><p class="s40" style="padding-top: 9pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">On a Local Machine</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_640.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">reader@hacking:~/booksrc $ ./a.out</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">server: got connection from 192.168.42.1 port 56971 RECV: 16 bytes</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 10pt;text-align: left;">74 68 69 73 20 69 73 20 61 20 74 65 73 74 0d 0a | This is a test...</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">RECV: 45 bytes</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">66 6a 73 67 68 61 75 3b 65 68 67 3b 69 68 73 6b | fjsghau;ehg;ihsk</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">6a 66 68 61 73 64 6b 66 6a 68 61 73 6b 6a 76 68 | jfhasdkfjhaskjvh</p><p class="s31" style="padding-bottom: 3pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">66 64 6b 6a 68 76 62 6b 6a 67 66 0d 0a     | fdkjhvbkjgf...</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_641.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part79.htm">&lt; Previous</a><span> | </span><a href="../hacking-the-art-of-exploitation.html">Contents</a><span> | </span><a href="part81.htm">Next &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
