<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>0x210 What Is Programming?</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part14.htm">&lt; Previous</a><span> | </span><a href="../hacking-the-art-of-exploitation.html">Contents</a><span> | </span><a href="part16.htm">Next &gt;</a></p><p class="s30" style="padding-left: 37pt;text-indent: 0pt;text-align: left;"><a name="bookmark5">0x210 What Is Programming?</a></p><p style="padding-top: 8pt;padding-left: 91pt;text-indent: 0pt;line-height: 108%;text-align: left;">Programming is a very natural and intuitive concept. A program is nothing more than a series of statements written in a specific language. Programs are everywhere, and even the technophobes of the world use programs every day. Driving directions, cooking recipes, football plays, and DNA are all types of programs. A typical program for driving directions might look something like this:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_006.png"/></span></p><p class="s31" style="padding-top: 1pt;padding-bottom: 4pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">Start out down Main Street headed east. Continue on Main Street until you see a church on your right. If the street is blocked because of construction, turn right there at 15th Street, turn left on Pine Street, and then turn right on 16th Street. Otherwise, you can just continue and make a right on 16th Street. Continue on 16th Street, and turn left onto Destination Road. Drive straight down Destination Road for 5 miles, and then you&#39;ll see the house on the right. The address is 743 Destination Road.</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_007.png"/></span></p><p style="padding-top: 7pt;padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: left;">Anyone who knows English can understand and follow these driving directions, since they’re written in English. Granted, they’re not eloquent, but each instruction is clear and easy to understand, at least for someone who reads English.</p><p style="padding-top: 3pt;padding-left: 91pt;text-indent: 17pt;line-height: 106%;text-align: left;">But a computer doesn’t natively understand English; it only understands machine language. To instruct a computer to do something, the instructions must be written in its language. However, <span class="s27">machine language </span>is arcane and difficult to work with—it consists of raw bits and bytes, and it differs from architecture to architecture. To write a program in machine language for an Intel <span class="s27">x</span>86 processor, you would have to figure out the value associated with each instruction, how each instruction interacts, and myriad low-level details. Programming like this is painstaking and cumbersome, and it is certainly not intuitive.</p><p style="padding-left: 91pt;text-indent: 18pt;line-height: 106%;text-align: left;">What’s needed to overcome the complication of writing machine language is a translator. An <span class="s27">assembler </span>is one form of machine-language translator—it is a program that translates assembly language into machine-readable code. <span class="s27">Assembly language </span>is less cryptic than machine language, since it uses names for the different instructions and variables, instead of just using numbers. However, assembly language is still far from intuitive. The instruction names are very esoteric, and the language is architecture specific. Just as machine language for Intel <span class="s27">x</span>86 processors is different from machine language for Sparc processors, <span class="s27">x</span>86 assembly language is different from Sparc assembly language. Any program written using assembly language for one processor’s architecture will not work on another processor’s architecture. If a program is written in <span class="s27">x</span>86 assembly language, it must be rewritten to run on Sparc architecture. In addition, in order to write an effective program in assembly language, you must still know many low-level details of the processor archi- tecture you are writing for.</p><p style="padding-left: 91pt;text-indent: 17pt;line-height: 107%;text-align: left;">These problems can be mitigated by yet another form of translator called a compiler. A <span class="s27">compiler </span>converts a high-level language into machine language. High-level languages are much more intuitive than assembly language and can be converted into many different types of machine language for differ- ent processor architectures. This means that if a program is written in a high- level language, the program only needs to be written once; the same piece of program code can be compiled into machine language for various specific architectures. C, C++, and Fortran are all examples of high-level languages. A program written in a high-level language is much more readable and English-like than assembly language or machine language, but it still must follow very strict rules about how the instructions are worded, or the com- piler won’t be able to understand it.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part14.htm">&lt; Previous</a><span> | </span><a href="../hacking-the-art-of-exploitation.html">Contents</a><span> | </span><a href="part16.htm">Next &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
