<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>0x263 Pointers</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part32.htm">&lt; Previous</a><span> | </span><a href="../hacking-the-art-of-exploitation.html">Contents</a><span> | </span><a href="part34.htm">Next &gt;</a></p><p class="s32" style="padding-left: 91pt;text-indent: 0pt;text-align: justify;"><a name="bookmark23">0x263 Pointers</a></p><p style="padding-top: 7pt;padding-left: 91pt;text-indent: 0pt;line-height: 108%;text-align: left;">The EIP register is a pointer that “points” to the current instruction during a program’s execution by containing its memory address. The idea of pointers is used in C, also. Since the physical memory cannot actually be moved, the information in it must be copied. It can be very computationally expensive to copy large chunks of memory to be used by different functions or in differ- ent places. This is also expensive from a memory standpoint, since space for the new destination copy must be saved or allocated before the source can be copied. Pointers are a solution to this problem. Instead of copying a large block of memory, it is much simpler to pass around the address of the begin- ning of that block of memory.</p><p style="padding-left: 91pt;text-indent: 18pt;line-height: 107%;text-align: left;">Pointers in C can be defined and used like any other variable type. Since memory on the <span class="s27">x </span>86 architecture uses 32-bit addressing, pointers are also 32 bits in size (4 bytes). Pointers are defined by prepending an asterisk (<span class="s31">*</span>) to the variable name. Instead of defining a variable of that type, a pointer is defined as something that points to data of that type. The pointer.c program is an example of a pointer being used with the <span class="s31">char </span>data type, which is only 1 byte in size.</p><p class="s40" style="padding-top: 4pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">pointer.c</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_133.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">#include &lt;stdio.h&gt; #include &lt;string.h&gt;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">int main() {</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;text-align: left;">char str_a[20]; // A 20-element character array</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;line-height: 107%;text-align: left;">char *pointer;  // A pointer, meant for a character array char *pointer2;  // And yet another one</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;text-align: left;">strcpy(str_a, &quot;Hello, world!\n&quot;);</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;line-height: 107%;text-align: left;">pointer = str_a; // Set the first pointer to the start of the array. printf(pointer);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-top: 4pt;padding-left: 104pt;text-indent: 0pt;text-align: left;">pointer2 = pointer + 2; // Set the second one 2 bytes further in. printf(pointer2);    // Print it.</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;line-height: 107%;text-align: left;">strcpy(pointer2, &quot;y you guys!\n&quot;); // Copy into that spot. printf(pointer);    // Print again.</p><p class="s31" style="padding-bottom: 3pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">}</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_134.png"/></span></p><p style="padding-top: 7pt;padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: left;">As the comments in the code indicate, the first pointer is set at the begin- ning of the character array. When the character array is referenced like this, it is actually a pointer itself. This is how this buffer was passed as a pointer to the <span class="s31">printf() </span>and <span class="s31">strcpy() </span>functions earlier. The second pointer is set to the first pointer’s address plus two, and then some things are printed (shown in the output below).</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_135.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">reader@hacking:~/booksrc $ gcc -o pointer pointer.c reader@hacking:~/booksrc $ ./pointer</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">Hello, world! llo, world! Hey you guys!</p><p class="s31" style="padding-bottom: 3pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">reader@hacking:~/booksrc $</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_136.png"/></span></p><p style="padding-top: 7pt;padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: justify;">Let’s take a look at this with GDB. The program is recompiled, and a breakpoint is set on the tenth line of the source code. This will stop the program after the <span class="s31">&quot;Hello, world!\n&quot; </span>string has been copied into the <span class="s31">str_a </span>buffer and the pointer variable is set to the beginning of it.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_137.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">reader@hacking:~/booksrc $ gcc -g -o pointer pointer.c reader@hacking:~/booksrc $ gdb -q ./pointer</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">Using host libthread_db library &quot;/lib/tls/i686/cmov/libthread_db.so.1&quot;. (gdb) list</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">1   #include &lt;stdio.h&gt;</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">2   #include &lt;string.h&gt;</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">3</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">4   int main() {</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">5     char str_a[20]; // A 20-element character array</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">6      char *pointer;  // A pointer, meant for a character array</p><p class="s31" style="padding-top: 2pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">7     char *pointer2; // And yet another one 8</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">9    strcpy(str_a, &quot;Hello, world!\n&quot;);</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">10     pointer = str_a; // Set the first pointer to the start of the array. (gdb)</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 10pt;text-align: left;">11    printf(pointer);</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">12</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">13     pointer2 = pointer + 2; // Set the second one 2 bytes further in.</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">14     printf(pointer2);    // Print it.</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">15    strcpy(pointer2, &quot;y you guys!\n&quot;); // Copy into that spot.</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">16     printf(pointer);    // Print again.</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">17   }</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">(gdb) break 11</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">Breakpoint 1 at 0x80483dd: file pointer.c, line 11. (gdb) run</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">Starting program: /home/reader/booksrc/pointer</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">Breakpoint 1, main () at pointer.c:11</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 106%;text-align: left;">11     printf(pointer); (gdb) x/xw pointer 0xbffff7e0:   0x6c6c6548 (gdb) x/s pointer</p><p class="s31" style="padding-bottom: 2pt;padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">0xbffff7e0:   &quot;Hello, world!\n&quot; (gdb)</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_138.png"/></span></p><p style="padding-top: 7pt;padding-left: 91pt;text-indent: 18pt;line-height: 108%;text-align: left;">When the pointer is examined as a string, it’s apparent that the given string is there and is located at memory address <span class="s31">0xbffff7e0</span>. Remember that the string itself isn’t stored in the pointer variable—only the memory address <span class="s31">0xbffff7e0 </span>is stored there.</p><p style="padding-left: 91pt;text-indent: 17pt;line-height: 107%;text-align: left;">In order to see the actual data stored in the pointer variable, you must use the address-of operator. The address-of operator is a <span class="s27">unary operator</span>, which simply means it operates on a single argument. This operator is just an ampersand (<span class="s31">&amp;</span>) prepended to a variable name. When it’s used, the address of that variable is returned, instead of the variable itself. This operator exists both in GDB and in the C programming language.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_139.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">(gdb) x/xw &amp;pointer 0xbffff7dc:  0xbffff7e0 (gdb) print &amp;pointer</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">$1 = (char **) 0xbffff7dc (gdb) print pointer</p><p class="s31" style="padding-bottom: 2pt;padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">$2 = 0xbffff7e0 &quot;Hello, world!\n&quot; (gdb)</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_140.png"/></span></p><p style="padding-top: 7pt;padding-left: 91pt;text-indent: 18pt;line-height: 108%;text-align: left;">When the address-of operator is used, the pointer variable is shown to be located at the address <span class="s31">0xbffff7dc </span>in memory, and it contains the address <span class="s31">0xbffff7e0</span>.</p><p style="padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: left;">The address-of operator is often used in conjunction with pointers, since pointers contain memory addresses. The addressof.c program demonstrates the address-of operator being used to put the address of an integer variable into a pointer. This line is shown in bold below.</p><p class="s40" style="padding-top: 4pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">addressof.c</p><p style="text-indent: 0pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_141.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 21pt;text-align: left;">#include &lt;stdio.h&gt; int main() {</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;line-height: 8pt;text-align: left;">int int_var = 5;</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;text-align: left;">int *int_ptr;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s46" style="padding-top: 4pt;padding-left: 104pt;text-indent: 0pt;text-align: left;">int_ptr = &amp;int_var; // put the address of int_var into int_ptr</p><p class="s31" style="padding-bottom: 3pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">}</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_142.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 91pt;text-indent: 17pt;line-height: 110%;text-align: left;">The program itself doesn’t actually output anything, but you can probably guess what happens, even before debugging with GDB.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_143.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">reader@hacking:~/booksrc $ gcc -g addressof.c reader@hacking:~/booksrc $ gdb -q ./a.out</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">Using host libthread_db library &quot;/lib/tls/i686/cmov/libthread_db.so.1&quot;. (gdb) list</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">1   #include &lt;stdio.h&gt;</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">2</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">3   int main() {</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">4        int int_var = 5;</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">5       int *int_ptr;</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">6</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">7        int_ptr = &amp;int_var; // Put the address of int_var into int_ptr.</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">8   }</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">(gdb) break 8</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">Breakpoint 1 at 0x8048361: file addressof.c, line 8. (gdb) run</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">Starting program: /home/reader/booksrc/a.out</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">Breakpoint 1, main () at addressof.c:8</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">8   }</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">(gdb) print int_var</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">$1 = 5</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">(gdb) print &amp;int_var</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">$2 = (int *) 0xbffff804 (gdb) print int_ptr</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">$3 = (int *) 0xbffff804 (gdb) print &amp;int_ptr</p><p class="s31" style="padding-bottom: 2pt;padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">$4 = (int **) 0xbffff800 (gdb)</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_144.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 18pt;line-height: 108%;text-align: left;">As usual, a breakpoint is set and the program is executed in the debugger. At this point the majority of the program has executed. The first <span class="s31">print </span>command shows the value of <span class="s31">int_var</span>, and the second shows its address using the address-of operator. The next two print commands show that <span class="s31">int_ptr </span>contains the address of <span class="s31">int_var</span>, and they also show the address of the <span class="s31">int_ptr </span>for good measure.</p><p style="padding-top: 3pt;padding-left: 91pt;text-indent: 17pt;line-height: 107%;text-align: left;">An additional unary operator called the <span class="s27">dereference </span>operator exists for use with pointers. This operator will return the data found in the address the pointer is pointing to, instead of the address itself. It takes the form of an asterisk in front of the variable name, similar to the declaration of a pointer. Once again, the dereference operator exists both in GDB and in C. Used in GDB, it can retrieve the integer value <span class="s31">int_ptr </span>points to.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_145.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">(gdb) print *int_ptr</p><p class="s31" style="padding-bottom: 3pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">$5 = 5</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_146.png"/></span></p><p style="padding-top: 7pt;padding-left: 91pt;text-indent: 18pt;line-height: 108%;text-align: left;">A few additions to the addressof.c code (shown in addressof2.c) will demonstrate all of these concepts. The added <span class="s31">printf() </span>functions use format parameters, which I’ll explain in the next section. For now, just focus on the program’s output.</p><p class="s40" style="padding-top: 9pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">addressof2.c</p><p style="text-indent: 0pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_147.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 21pt;text-align: left;">#include &lt;stdio.h&gt; int main() {</p><p class="s31" style="padding-left: 103pt;text-indent: 0pt;line-height: 8pt;text-align: left;">int int_var = 5;</p><p class="s31" style="padding-left: 103pt;text-indent: 0pt;text-align: left;">int *int_ptr;</p><p class="s31" style="padding-left: 103pt;text-indent: 0pt;line-height: 21pt;text-align: left;">int_ptr = &amp;int_var; // Put the address of int_var into int_ptr. printf(&quot;int_ptr = 0x%08x\n&quot;, int_ptr);</p><p class="s31" style="padding-top: 1pt;padding-left: 103pt;text-indent: 0pt;line-height: 107%;text-align: left;">printf(&quot;&amp;int_ptr = 0x%08x\n&quot;, &amp;int_ptr); printf(&quot;*int_ptr = 0x%08x\n\n&quot;, *int_ptr);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-top: 4pt;padding-left: 103pt;text-indent: 0pt;line-height: 107%;text-align: left;">printf(&quot;int_var is located at 0x%08x and contains %d\n&quot;, &amp;int_var, int_var); printf(&quot;int_ptr is located at 0x%08x, contains 0x%08x, and points to %d\n\n&quot;,</p><p class="s31" style="padding-left: 116pt;text-indent: 0pt;text-align: left;">&amp;int_ptr, int_ptr, *int_ptr);</p><p class="s31" style="padding-bottom: 3pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">}</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_148.png"/></span></p><p style="padding-top: 7pt;padding-left: 109pt;text-indent: 0pt;text-align: left;">The results of compiling and executing addressof2.c are as follows.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_149.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">reader@hacking:~/booksrc $ gcc addressof2.c reader@hacking:~/booksrc $ ./a.out</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">int_ptr = 0xbffff834 &amp;int_ptr = 0xbffff830</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">*int_ptr = 0x00000005</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">int_var is located at 0xbffff834 and contains 5</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">int_ptr is located at 0xbffff830, contains 0xbffff834, and points to 5</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-top: 4pt;padding-bottom: 3pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">reader@hacking:~/booksrc $</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_150.png"/></span></p><p style="padding-top: 7pt;padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: left;">When the unary operators are used with pointers, the address-of oper- ator can be thought of as moving backward, while the dereference operator moves forward in the direction the pointer is pointing.</p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part32.htm">&lt; Previous</a><span> | </span><a href="../hacking-the-art-of-exploitation.html">Contents</a><span> | </span><a href="part34.htm">Next &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
