<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>0x272 Using the Heap</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part39.htm">&lt; Previous</a><span> | </span><a href="../hacking-the-art-of-exploitation.html">Contents</a><span> | </span><a href="part41.htm">Next &gt;</a></p><p class="s32" style="padding-left: 6pt;text-indent: 0pt;text-align: left;"><a name="bookmark30">0x272 Using the Heap</a></p><p style="padding-top: 7pt;padding-left: 6pt;text-indent: 0pt;line-height: 108%;text-align: left;">Using the other memory segments is simply a matter of how you declare variables. However, using the heap requires a bit more effort. As previously demonstrated, allocating memory on the heap is done using the <span class="s31">malloc() </span>function. This function accepts a size as its only argument and reserves that much space in the heap segment, returning the address to the start of this memory as a void pointer. If the <span class="s31">malloc() </span>function can’t allocate memory for some reason, it will simply return a NULL pointer with a value of 0. The corresponding deallocation function is <span class="s31">free()</span>. This function accepts a pointer as its only argument and frees that memory space on the heap so it can be used again later. These relatively simple functions are demonstrated in heap_example.c.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_248.png"/></span></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt;</p><p class="s31" style="padding-top: 2pt;padding-left: 32pt;text-indent: -12pt;text-align: left;">int main(int argc, char *argv[]) { char *char_ptr; // A char pointer</p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;line-height: 107%;text-align: left;">int *int_ptr;  // An integer pointer int mem_size;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 44pt;text-indent: -12pt;line-height: 107%;text-align: left;">if (argc &lt; 2)  // If there aren&#39;t command-line arguments, mem_size = 50; // use 50 as the default value.</p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;text-align: left;">else</p><p class="s31" style="padding-left: 44pt;text-indent: 0pt;text-align: left;">mem_size = atoi(argv[1]);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;line-height: 107%;text-align: left;">printf(&quot;\t[+] allocating %d bytes of memory on the heap for char_ptr\n&quot;, mem_size); char_ptr = (char *) malloc(mem_size); // Allocating heap memory</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 44pt;text-indent: -12pt;line-height: 107%;text-align: left;">if(char_ptr == NULL) { // Error checking, in case malloc() fails fprintf(stderr, &quot;Error: could not allocate heap memory.\n&quot;); exit(-1);</p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;text-align: left;">}</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;line-height: 107%;text-align: left;">strcpy(char_ptr, &quot;This is memory is located on the heap.&quot;); printf(&quot;char_ptr (%p) --&gt; &#39;%s&#39;\n&quot;, char_ptr, char_ptr);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;line-height: 107%;text-align: left;">printf(&quot;\t[+] allocating 12 bytes of memory on the heap for int_ptr\n&quot;); int_ptr = (int *) malloc(12); // Allocated heap memory again</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 44pt;text-indent: -12pt;line-height: 106%;text-align: left;">if(int_ptr == NULL) { // Error checking, in case malloc() fails fprintf(stderr, &quot;Error: could not allocate heap memory.\n&quot;); exit(-1);</p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;text-align: left;">}</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;line-height: 107%;text-align: left;">*int_ptr = 31337; // Put the value of 31337 where int_ptr is pointing. printf(&quot;int_ptr (%p) --&gt; %d\n&quot;, int_ptr, *int_ptr);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;line-height: 107%;text-align: left;">printf(&quot;\t[-] freeing char_ptr&#39;s heap memory...\n&quot;); free(char_ptr); // Freeing heap memory</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;text-align: left;">printf(&quot;\t[+] allocating another 15 bytes for char_ptr\n&quot;); char_ptr = (char *) malloc(15); // Allocating more heap memory</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 44pt;text-indent: -12pt;line-height: 106%;text-align: left;">if(char_ptr == NULL) { // Error checking, in case malloc() fails fprintf(stderr, &quot;Error: could not allocate heap memory.\n&quot;); exit(-1);</p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;text-align: left;">}</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;text-align: left;">strcpy(char_ptr, &quot;new memory&quot;);</p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;text-align: left;">printf(&quot;char_ptr (%p) --&gt; &#39;%s&#39;\n&quot;, char_ptr, char_ptr);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-top: 4pt;padding-left: 32pt;text-indent: 0pt;line-height: 107%;text-align: left;">printf(&quot;\t[-] freeing int_ptr&#39;s heap memory...\n&quot;); free(int_ptr); // Freeing heap memory</p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;line-height: 107%;text-align: left;">printf(&quot;\t[-] freeing char_ptr&#39;s heap memory...\n&quot;); free(char_ptr); // Freeing the other block of heap memory</p><p class="s31" style="padding-bottom: 3pt;padding-left: 19pt;text-indent: 0pt;text-align: left;">}</p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_249.png"/></span></p><p style="padding-top: 3pt;padding-left: 91pt;text-indent: 18pt;line-height: 108%;text-align: left;">This program accepts a command-line argument for the size of the first memory allocation, with a default value of 50. Then it uses the <span class="s31">malloc() </span>and <span class="s31">free() </span>functions to allocate and deallocate memory on the heap. There are plenty of <span class="s31">printf() </span>statements to debug what is actually happening when the program is executed. Since <span class="s31">malloc() </span>doesn’t know what type of memory it’s allocating, it returns a void pointer to the newly allocated heap memory, which must be typecast into the appropriate type. After every <span class="s31">malloc() </span>call, there is an error-checking block that checks whether or not the allocation failed. If the allocation fails and the pointer is NULL, <span class="s31">fprintf() </span>is used to print an error message to standard error and the program exits. The <span class="s31">fprintf() </span>function is very similar to <span class="s31">printf()</span>; however, its first argument is <span class="s31">stderr</span>, which is a standard filestream meant for displaying errors. This function will be explained more later, but for now, it’s just used as a way to properly display an error. The rest of the program is pretty straightforward.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_250.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">reader@hacking:~/booksrc $ gcc -o heap_example heap_example.c reader@hacking:~/booksrc $ ./heap_example</p><p class="s31" style="padding-left: 91pt;text-indent: 34pt;text-align: left;">[+] allocating 50 bytes of memory on the heap for char_ptr char_ptr (0x804a008) --&gt; &#39;This is memory is located on the heap.&#39;</p><p class="s31" style="padding-left: 91pt;text-indent: 34pt;line-height: 107%;text-align: left;">[+] allocating 12 bytes of memory on the heap for int_ptr int_ptr (0x804a040) --&gt; 31337</p><p class="s31" style="padding-left: 125pt;text-indent: 0pt;text-align: left;">[-] freeing char_ptr&#39;s heap memory...</p><p class="s31" style="padding-left: 91pt;text-indent: 34pt;line-height: 107%;text-align: left;">[+] allocating another 15 bytes for char_ptr char_ptr (0x804a050) --&gt; &#39;new memory&#39;</p><p class="s31" style="padding-left: 125pt;text-indent: 0pt;line-height: 107%;text-align: left;">[-] freeing int_ptr&#39;s heap memory... [-] freeing char_ptr&#39;s heap memory...</p><p class="s31" style="padding-bottom: 3pt;padding-left: 91pt;text-indent: 0pt;line-height: 9pt;text-align: left;">reader@hacking:~/booksrc $</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_251.png"/></span></p><p style="padding-top: 6pt;padding-left: 91pt;text-indent: 18pt;line-height: 108%;text-align: left;">In the preceding output, notice that each block of memory has an incre- mentally higher memory address in the heap. Even though the first 50 bytes were deallocated, when 15 more bytes are requested, they are put after the 12 bytes allocated for the <span class="s31">int_ptr</span>. The heap allocation functions control this behavior, which can be explored by changing the size of the initial memory allocation.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_252.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">reader@hacking:~/booksrc $ ./heap_example 100</p><p class="s31" style="padding-left: 91pt;text-indent: 34pt;line-height: 107%;text-align: left;">[+] allocating 100 bytes of memory on the heap for char_ptr char_ptr (0x804a008) --&gt; &#39;This is memory is located on the heap.&#39;</p><p class="s31" style="padding-left: 91pt;text-indent: 34pt;text-align: left;">[+] allocating 12 bytes of memory on the heap for int_ptr int_ptr (0x804a070) --&gt; 31337</p><p class="s31" style="padding-left: 125pt;text-indent: 0pt;text-align: left;">[-] freeing char_ptr&#39;s heap memory...</p><p class="s31" style="padding-left: 91pt;text-indent: 34pt;line-height: 107%;text-align: left;">[+] allocating another 15 bytes for char_ptr char_ptr (0x804a008) --&gt; &#39;new memory&#39;</p><p class="s31" style="padding-left: 125pt;text-indent: 0pt;line-height: 107%;text-align: left;">[-] freeing int_ptr&#39;s heap memory... [-] freeing char_ptr&#39;s heap memory...</p><p class="s31" style="padding-bottom: 3pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">reader@hacking:~/booksrc $</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_253.png"/></span></p><p style="padding-top: 8pt;padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: left;">If a larger block of memory is allocated and then deallocated, the final 15-byte allocation will occur in that freed memory space, instead. By experi- menting with different values, you can figure out exactly when the allocation</p><p style="padding-top: 3pt;padding-left: 91pt;text-indent: 0pt;line-height: 108%;text-align: left;">function chooses to reclaim freed space for new allocations. Often, simple informative <span class="s31">printf() </span>statements and a little experimentation can reveal many things about the underlying system.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part39.htm">&lt; Previous</a><span> | </span><a href="../hacking-the-art-of-exploitation.html">Contents</a><span> | </span><a href="part41.htm">Next &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
