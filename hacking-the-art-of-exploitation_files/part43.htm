<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>0x281 File Access</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part42.htm">&lt; Previous</a><span> | </span><a href="../hacking-the-art-of-exploitation.html">Contents</a><span> | </span><a href="part44.htm">Next &gt;</a></p><p class="s32" style="padding-left: 91pt;text-indent: 0pt;text-align: left;"><a name="bookmark33">0x281 File Access</a></p><p style="padding-top: 7pt;padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">There are two primary ways to access files in C: file descriptors and file- streams. <span class="s27">File descriptors </span>use a set of low-level I/O functions, and <span class="s27">filestreams </span>are a higher-level form of buffered I/O that is built on the lower-level functions. Some consider the filestream functions easier to program with; however, file descriptors are more direct. In this book, the focus will be on the low-level I/O functions that use file descriptors.</p><p style="padding-top: 3pt;padding-left: 91pt;text-indent: 18pt;line-height: 107%;text-align: left;">The bar code on the back of this book represents a number. Because this number is unique among the other books in a bookstore, the cashier can scan the number at checkout and use it to reference information about this book in the store’s database. Similarly, a file descriptor is a number that is used to reference open files. Four common functions that use file descriptors are <span class="s31">open()</span>, <span class="s31">close()</span>, <span class="s31">read()</span>, and <span class="s31">write()</span>. All of these functions will return <span class="s47"></span>1 if there is an error. The <span class="s31">open() </span>function opens a file for reading and/or writing and returns a file descriptor. The returned file descriptor is just an integer value, but it is unique among open files. The file descriptor is passed as an argument to the other functions like a pointer to the opened file. For the <span class="s31">close() </span>function, the file descriptor is the only argument. The <span class="s31">read() </span>and <span class="s31">write() </span>functions’ arguments are the file descriptor, a pointer to the data to read or write, and the number of bytes to read or write from that location. The arguments to the <span class="s31">open() </span>function are a pointer to the filename to open and a series of predefined flags that specify the access mode. These flags and their usage will be explained in depth later, but for now let’s take a look at a simple note-taking program that uses file descriptors—simplenote.c. This program accepts a note as a command-line argument and then adds it to the end of the file /tmp/notes. This program uses several functions, including a familiar looking error-checked heap memory allocation function. Other func- tions are used to display a usage message and to handle fatal errors. The <span class="s31">usage() </span>function is simply defined before <span class="s31">main()</span>, so it doesn’t need a function prototype.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s40" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">simplenote.c</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_256.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 106%;text-align: left;">#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;fcntl.h&gt; #include &lt;sys/stat.h&gt;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">void usage(char *prog_name, char *filename) {</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;text-align: left;">printf(&quot;Usage: %s &lt;data to add to %s&gt;\n&quot;, prog_name, filename); exit(0);</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">}</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">void fatal(char *);       // A function for fatal errors</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">void *ec_malloc(unsigned int); // An error-checked malloc() wrapper</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 104pt;text-indent: -12pt;line-height: 106%;text-align: left;">int main(int argc, char *argv[]) { int fd; // file descriptor char *buffer, *datafile;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;line-height: 106%;text-align: left;">buffer = (char *) ec_malloc(100); datafile = (char *) ec_malloc(20); strcpy(datafile, &quot;/tmp/notes&quot;);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 116pt;text-indent: -12pt;line-height: 107%;text-align: left;">if(argc &lt; 2)        // If there aren&#39;t command-line arguments, usage(argv[0], datafile); // display usage message and exit.</p><p class="s31" style="padding-top: 2pt;padding-left: 104pt;text-indent: 0pt;text-align: left;">strcpy(buffer, argv[1]); // Copy into buffer.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;line-height: 107%;text-align: left;">printf(&quot;[DEBUG] buffer  @ %p: \&#39;%s\&#39;\n&quot;, buffer, buffer); printf(&quot;[DEBUG] datafile @ %p: \&#39;%s\&#39;\n&quot;, datafile, datafile);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;text-align: left;">strncat(buffer, &quot;\n&quot;, 1); // Add a newline on the end.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">// Opening file</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;text-align: left;">fd = open(datafile, O_WRONLY|O_CREAT|O_APPEND, S_IRUSR|S_IWUSR); if(fd == -1)</p><p class="s31" style="padding-left: 104pt;text-indent: 12pt;line-height: 107%;text-align: left;">fatal(&quot;in main() while opening file&quot;); printf(&quot;[DEBUG] file descriptor is %d\n&quot;, fd);</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">// Writing data</p><p class="s31" style="padding-left: 116pt;text-indent: -12pt;line-height: 107%;text-align: left;">if(write(fd, buffer, strlen(buffer)) == -1) fatal(&quot;in main() while writing buffer to file&quot;);</p><p class="s31" style="padding-left: 104pt;text-indent: -12pt;line-height: 107%;text-align: left;">// Closing file if(close(fd) == -1)</p><p class="s31" style="padding-left: 116pt;text-indent: 0pt;line-height: 10pt;text-align: left;">fatal(&quot;in main() while closing file&quot;);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-top: 4pt;padding-left: 104pt;text-indent: 0pt;line-height: 107%;text-align: left;">printf(&quot;Note has been saved.\n&quot;); free(buffer);</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;line-height: 10pt;text-align: left;">free(datafile);</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">}</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-top: 4pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">// A function to display an error message and then exit void fatal(char *message) {</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;text-align: left;">char error_message[100];</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-top: 4pt;padding-left: 104pt;text-indent: 0pt;line-height: 106%;text-align: left;">strcpy(error_message, &quot;[!!] Fatal Error &quot;); strncat(error_message, message, 83); perror(error_message);</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;text-align: left;">exit(-1);</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">}</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-top: 4pt;padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">// An error-checked malloc() wrapper function void *ec_malloc(unsigned int size) {</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;text-align: left;">void *ptr;</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;line-height: 107%;text-align: left;">ptr = malloc(size); if(ptr == NULL)</p><p class="s31" style="padding-left: 104pt;text-indent: 12pt;line-height: 107%;text-align: left;">fatal(&quot;in ec_malloc() on memory allocation&quot;); return ptr;</p><p class="s31" style="padding-bottom: 3pt;padding-left: 91pt;text-indent: 0pt;line-height: 10pt;text-align: left;">}</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_257.png"/></span></p><p style="padding-top: 7pt;padding-left: 91pt;text-indent: 18pt;line-height: 107%;text-align: left;">Besides the strange-looking flags used in the <span class="s31">open() </span>function, most of this code should be readable. There are also a few standard functions that we haven’t used before. The <span class="s31">strlen() </span>function accepts a string and returns its length. It’s used in combination with the <span class="s31">write() </span>function, since it needs to know how many bytes to write. The <span class="s31">perror() </span>function is short for <span class="s27">print error </span>and is used in <span class="s31">fatal() </span>to print an additional error message (if it exists) before exiting.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_258.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">reader@hacking:~/booksrc $ gcc -o simplenote simplenote.c reader@hacking:~/booksrc $ ./simplenote</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">Usage: ./simplenote &lt;data to add to /tmp/notes&gt;</p><p class="s31" style="padding-top: 2pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">reader@hacking:~/booksrc $ ./simplenote &quot;this is a test note&quot; [DEBUG] buffer  @ 0x804a008: &#39;this is a test note&#39;</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">[DEBUG] datafile @ 0x804a070: &#39;/tmp/notes&#39; [DEBUG] file descriptor is 3</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 106%;text-align: left;">Note has been saved. reader@hacking:~/booksrc $ cat /tmp/notes this is a test note</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">reader@hacking:~/booksrc $ ./simplenote &quot;great, it works&quot; [DEBUG] buffer  @ 0x804a008: &#39;great, it works&#39;</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">[DEBUG] datafile @ 0x804a070: &#39;/tmp/notes&#39; [DEBUG] file descriptor is 3</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 106%;text-align: left;">Note has been saved. reader@hacking:~/booksrc $ cat /tmp/notes this is a test note</p><p class="s31" style="padding-bottom: 2pt;padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">great, it works reader@hacking:~/booksrc $</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_259.png"/></span></p><p style="padding-top: 7pt;padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: left;">The output of the program’s execution is pretty self-explanatory, but there are some things about the source code that need further explanation. The files fcntl.h and sys/stat.h had to be included, since those files define the flags used with the <span class="s31">open() </span>function. The first set of flags is found in fcntl.h and is used to set the access mode. The access mode must use at least one of the following three flags:</p><p class="s46" style="padding-top: 8pt;padding-left: 109pt;text-indent: 0pt;text-align: left;">O_RDONLY <span class="p">Open file for read-only access.</span></p><p class="s46" style="padding-top: 2pt;padding-left: 109pt;text-indent: 0pt;text-align: left;">O_WRONLY  <span class="p">Open file for write-only access.</span></p><p class="s46" style="padding-top: 3pt;padding-left: 109pt;text-indent: 0pt;text-align: left;">O_RDWR  <span class="p">Open file for both read and write access.</span></p><p style="padding-top: 9pt;padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: left;">These flags can be combined with several other optional flags using the bitwise OR operator. A few of the more common and useful of these flags are as follows:</p><p class="s46" style="padding-top: 9pt;padding-left: 109pt;text-indent: 0pt;text-align: left;">O_APPEND  <span class="p">Write data at the end of the file.</span></p><p class="s46" style="padding-top: 2pt;padding-left: 109pt;text-indent: 0pt;text-align: left;">O_TRUNC  <span class="p">If the file already exists, truncate the file to 0 length.</span></p><p class="s46" style="padding-top: 2pt;padding-left: 109pt;text-indent: 0pt;text-align: left;">O_CREAT  <span class="p">Create the file if it doesn’t exist.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 18pt;line-height: 106%;text-align: left;">Bitwise operations combine bits using standard logic gates such as OR and AND. When two bits enter an OR gate, the result is 1 if either the first bit <span class="s27">or </span>the second bit is 1. If two bits enter an AND gate, the result is 1 only if both the first bit <span class="s27">and </span>the second bit are 1. Full 32-bit values can use these bitwise operators to perform logic operations on each corresponding bit. The source code of bitwise.c and the program output demonstrate these bitwise operations.</p><p class="s40" style="padding-top: 9pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">bitwise.c</p><p style="text-indent: 0pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_260.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 21pt;text-align: left;">#include &lt;stdio.h&gt; int main() {</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;line-height: 8pt;text-align: left;">int i, bit_a, bit_b;</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;text-align: left;">printf(&quot;bitwise OR operator |\n&quot;);</p><p class="s31" style="padding-top: 2pt;padding-left: 104pt;text-indent: 0pt;text-align: left;">for(i=0; i &lt; 4; i++) {</p><p class="s31" style="padding-left: 116pt;text-indent: 0pt;line-height: 107%;text-align: left;">bit_a = (i &amp; 2) / 2; // Get the second bit. bit_b = (i &amp; 1);   // Get the first bit.</p><p class="s31" style="padding-left: 116pt;text-indent: 0pt;text-align: left;">printf(&quot;%d | %d = %d\n&quot;, bit_a, bit_b, bit_a | bit_b);</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;text-align: left;">}</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;line-height: 107%;text-align: left;">printf(&quot;\nbitwise AND operator &amp;\n&quot;); for(i=0; i &lt; 4; i++) {</p><p class="s31" style="padding-left: 116pt;text-indent: 0pt;line-height: 107%;text-align: left;">bit_a = (i &amp; 2) / 2; // Get the second bit. bit_b = (i &amp; 1);   // Get the first bit.</p><p class="s31" style="padding-left: 116pt;text-indent: 0pt;line-height: 10pt;text-align: left;">printf(&quot;%d &amp; %d = %d\n&quot;, bit_a, bit_b, bit_a &amp; bit_b);</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;text-align: left;">}</p><p class="s31" style="padding-bottom: 3pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">}</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_261.png"/></span></p><p style="padding-top: 7pt;padding-left: 109pt;text-indent: 0pt;text-align: left;">The results of compiling and executing bitwise.c are as follows.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_262.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">reader@hacking:~/booksrc $ gcc bitwise.c reader@hacking:~/booksrc $ ./a.out</p><table style="border-collapse:collapse;margin-left:88.94pt" cellspacing="0"><tr style="height:10pt"><td style="width:34pt"><p class="s42" style="padding-left: 2pt;padding-right: 2pt;text-indent: 0pt;line-height: 9pt;text-align: center;">bitwise</p></td><td style="width:69pt"><p class="s42" style="padding-left: 2pt;text-indent: 0pt;line-height: 9pt;text-align: left;">OR operator |</p></td></tr><tr style="height:11pt"><td style="width:34pt"><p class="s42" style="padding-left: 2pt;text-indent: 0pt;line-height: 9pt;text-align: left;">0 | 0 =</p></td><td style="width:69pt"><p class="s42" style="padding-left: 2pt;text-indent: 0pt;line-height: 9pt;text-align: left;">0</p></td></tr><tr style="height:11pt"><td style="width:34pt"><p class="s42" style="padding-left: 2pt;text-indent: 0pt;line-height: 10pt;text-align: left;">0 | 1 =</p></td><td style="width:69pt"><p class="s42" style="padding-left: 2pt;text-indent: 0pt;line-height: 10pt;text-align: left;">1</p></td></tr><tr style="height:11pt"><td style="width:34pt"><p class="s42" style="padding-left: 2pt;text-indent: 0pt;line-height: 10pt;text-align: left;">1 | 0 =</p></td><td style="width:69pt"><p class="s42" style="padding-left: 2pt;text-indent: 0pt;line-height: 10pt;text-align: left;">1</p></td></tr><tr style="height:16pt"><td style="width:34pt"><p class="s42" style="padding-left: 2pt;text-indent: 0pt;line-height: 10pt;text-align: left;">1 | 1 =</p></td><td style="width:69pt"><p class="s42" style="padding-left: 2pt;text-indent: 0pt;line-height: 10pt;text-align: left;">1</p></td></tr><tr style="height:16pt"><td style="width:34pt"><p class="s42" style="padding-top: 4pt;padding-left: 2pt;padding-right: 2pt;text-indent: 0pt;line-height: 10pt;text-align: center;">bitwise</p></td><td style="width:69pt"><p class="s42" style="padding-top: 4pt;padding-left: 2pt;text-indent: 0pt;line-height: 10pt;text-align: left;">AND operator &amp;</p></td></tr><tr style="height:11pt"><td style="width:34pt"><p class="s42" style="padding-left: 2pt;text-indent: 0pt;line-height: 10pt;text-align: left;">0 &amp; 0 =</p></td><td style="width:69pt"><p class="s42" style="padding-left: 2pt;text-indent: 0pt;line-height: 10pt;text-align: left;">0</p></td></tr><tr style="height:11pt"><td style="width:34pt"><p class="s42" style="padding-left: 2pt;text-indent: 0pt;line-height: 9pt;text-align: left;">0 &amp; 1 =</p></td><td style="width:69pt"><p class="s42" style="padding-left: 2pt;text-indent: 0pt;line-height: 9pt;text-align: left;">0</p></td></tr><tr style="height:11pt"><td style="width:34pt"><p class="s42" style="padding-left: 2pt;text-indent: 0pt;line-height: 9pt;text-align: left;">1 &amp; 0 =</p></td><td style="width:69pt"><p class="s42" style="padding-left: 2pt;text-indent: 0pt;line-height: 9pt;text-align: left;">0</p></td></tr><tr style="height:10pt"><td style="width:34pt"><p class="s42" style="padding-left: 2pt;text-indent: 0pt;line-height: 9pt;text-align: left;">1 &amp; 1 =</p></td><td style="width:69pt"><p class="s42" style="padding-left: 2pt;text-indent: 0pt;line-height: 9pt;text-align: left;">1</p></td></tr></table><p class="s31" style="padding-bottom: 3pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">reader@hacking:~/booksrc $</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_263.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s40" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">fcntl_flags.c</p><p style="padding-top: 4pt;padding-left: 19pt;text-indent: 17pt;line-height: 108%;text-align: left;">The flags used for the <span class="s31">open() </span>function have values that correspond to single bits. This way, flags can be combined using OR logic without destroy- ing any information. The fcntl_flags.c program and its output explore some of the flag values defined by fcntl.h and how they combine with each other.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_264.png"/></span></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">#include &lt;stdio.h&gt; #include &lt;fcntl.h&gt;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">void display_flags(char *, unsigned int); void binary_print(unsigned int);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 32pt;text-indent: -12pt;line-height: 106%;text-align: left;">int main(int argc, char *argv[]) { display_flags(&quot;O_RDONLY\t\t&quot;, O_RDONLY); display_flags(&quot;O_WRONLY\t\t&quot;, O_WRONLY); display_flags(&quot;O_RDWR\t\t\t&quot;, O_RDWR); printf(&quot;\n&quot;); display_flags(&quot;O_APPEND\t\t&quot;, O_APPEND); display_flags(&quot;O_TRUNC\t\t\t&quot;, O_TRUNC); display_flags(&quot;O_CREAT\t\t\t&quot;, O_CREAT);</p><p class="s31" style="padding-top: 2pt;padding-left: 32pt;text-indent: 0pt;text-align: left;">printf(&quot;\n&quot;);</p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;text-align: left;">display_flags(&quot;O_WRONLY|O_APPEND|O_CREAT&quot;, O_WRONLY|O_APPEND|O_CREAT);</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">}</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-top: 4pt;padding-left: 32pt;text-indent: -12pt;line-height: 106%;text-align: left;">void display_flags(char *label, unsigned int value) { printf(&quot;%s\t: %d\t:&quot;, label, value); binary_print(value);</p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;text-align: left;">printf(&quot;\n&quot;);</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">}</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">void binary_print(unsigned int value) {</p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;line-height: 106%;text-align: left;">unsigned int mask = 0xff000000; // Start with a mask for the highest byte. unsigned int shift = 256*256*256; // Start with a shift for the highest byte. unsigned int byte, byte_iterator, bit_iterator;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 44pt;text-indent: -12pt;line-height: 106%;text-align: left;">for(byte_iterator=0; byte_iterator &lt; 4; byte_iterator++) { byte = (value &amp; mask) / shift; // Isolate each byte. printf(&quot; &quot;);</p><p class="s31" style="padding-left: 57pt;text-indent: -12pt;line-height: 107%;text-align: left;">for(bit_iterator=0; bit_iterator &lt; 8; bit_iterator++) { // Print the byte&#39;s bits. if(byte &amp; 0x80) // If the highest bit in the byte isn&#39;t 0,</p><p class="s31" style="padding-left: 57pt;text-indent: 12pt;text-align: left;">printf(&quot;1&quot;);    // print a 1. else</p><p class="s31" style="padding-left: 70pt;text-indent: 0pt;text-align: left;">printf(&quot;0&quot;);    // Otherwise, print a 0.</p><p class="s31" style="padding-left: 57pt;text-indent: 0pt;text-align: left;">byte *= 2;     // Move all the bits to the left by 1.</p><p class="s31" style="padding-left: 44pt;text-indent: 0pt;text-align: left;">}</p><p class="s31" style="padding-left: 44pt;text-indent: 0pt;line-height: 107%;text-align: left;">mask /= 256;    // Move the bits in mask right by 8. shift /= 256;   // Move the bits in shift right by 8.</p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;text-align: left;">}</p><p class="s31" style="padding-bottom: 3pt;padding-left: 19pt;text-indent: 0pt;text-align: left;">}</p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_265.png"/></span></p><p style="padding-top: 7pt;padding-left: 109pt;text-indent: 0pt;text-align: left;">The results of compiling and executing fcntl_flags.c are as follows.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_266.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">reader@hacking:~/booksrc $ gcc fcntl_flags.c reader@hacking:~/booksrc $ ./a.out</p><table style="border-collapse:collapse;margin-left:91.44pt" cellspacing="0"><tr style="height:37pt"><td style="width:121pt"><p class="s42" style="text-indent: 0pt;line-height: 9pt;text-align: left;">O_RDONLY</p><p class="s42" style="padding-right: 62pt;text-indent: 0pt;line-height: 107%;text-align: left;">O_WRONLY O_RDWR</p></td><td style="width:45pt"><p class="s42" style="padding-left: 14pt;padding-right: 16pt;text-indent: 0pt;line-height: 9pt;text-align: center;">: 0</p><p class="s42" style="padding-left: 14pt;padding-right: 16pt;text-indent: 0pt;text-align: center;">: 1</p><p class="s42" style="padding-left: 14pt;padding-right: 16pt;text-indent: 0pt;text-align: center;">: 2</p></td><td style="width:167pt"><p class="s42" style="padding-left: 4pt;text-indent: 0pt;line-height: 9pt;text-align: left;">: 00000000 00000000 00000000 00000000</p><p class="s42" style="padding-left: 4pt;text-indent: 0pt;text-align: left;">: 00000000 00000000 00000000 00000001</p><p class="s42" style="padding-left: 4pt;text-indent: 0pt;text-align: left;">: 00000000 00000000 00000000 00000010</p></td></tr><tr style="height:16pt"><td style="width:121pt"><p class="s42" style="padding-top: 4pt;text-indent: 0pt;line-height: 10pt;text-align: left;">O_APPEND</p></td><td style="width:45pt"><p class="s42" style="padding-top: 4pt;padding-left: 14pt;text-indent: 0pt;line-height: 10pt;text-align: left;">: 1024</p></td><td style="width:167pt"><p class="s42" style="padding-top: 4pt;padding-right: 1pt;text-indent: 0pt;line-height: 10pt;text-align: center;">: 00000000 00000000 00000100 00000000</p></td></tr><tr style="height:11pt"><td style="width:121pt"><p class="s42" style="text-indent: 0pt;line-height: 10pt;text-align: left;">O_TRUNC</p></td><td style="width:45pt"><p class="s42" style="padding-left: 14pt;text-indent: 0pt;line-height: 10pt;text-align: left;">: 512</p></td><td style="width:167pt"><p class="s42" style="padding-right: 1pt;text-indent: 0pt;line-height: 10pt;text-align: center;">: 00000000 00000000 00000010 00000000</p></td></tr><tr style="height:16pt"><td style="width:121pt"><p class="s42" style="text-indent: 0pt;line-height: 10pt;text-align: left;">O_CREAT</p></td><td style="width:45pt"><p class="s42" style="padding-left: 14pt;text-indent: 0pt;line-height: 10pt;text-align: left;">: 64</p></td><td style="width:167pt"><p class="s42" style="padding-right: 1pt;text-indent: 0pt;line-height: 10pt;text-align: center;">: 00000000 00000000 00000000 01000000</p></td></tr><tr style="height:30pt"><td style="width:121pt;border-bottom-style:solid;border-bottom-width:1pt"><p class="s42" style="padding-top: 4pt;text-indent: 0pt;text-align: left;">O_WRONLY|O_APPEND|O_CREAT</p><p class="s42" style="text-indent: 0pt;text-align: left;">$</p></td><td style="width:45pt;border-bottom-style:solid;border-bottom-width:1pt"><p class="s42" style="padding-top: 4pt;padding-left: 14pt;text-indent: 0pt;text-align: left;">: 1089</p></td><td style="width:167pt;border-bottom-style:solid;border-bottom-width:1pt"><p class="s42" style="padding-top: 4pt;padding-right: 1pt;text-indent: 0pt;text-align: center;">: 00000000 00000000 00000100 01000001</p></td></tr></table><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: justify;">Using bit flags in combination with bitwise logic is an efficient and com- monly used technique. As long as each flag is a number that only has unique bits turned on, the effect of doing a bitwise OR on these values is the same as adding them. In fcntl_flags.c, 1 + 1024 + 64 = 1089. This technique only works when all the bits are unique, though.</p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part42.htm">&lt; Previous</a><span> | </span><a href="../hacking-the-art-of-exploitation.html">Contents</a><span> | </span><a href="part44.htm">Next &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
