<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>0x426 A Web Client Example</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part80.htm">&lt; Previous</a><span> | </span><a href="../hacking-the-art-of-exploitation.html">Contents</a><span> | </span><a href="part82.htm">Next &gt;</a></p><p class="s32" style="padding-left: 91pt;text-indent: 0pt;text-align: left;"><a name="bookmark70">0x426 A Web Client Example</a></p><p style="padding-top: 7pt;padding-left: 91pt;text-indent: 0pt;line-height: 108%;text-align: left;">The telnet program works well as a client for our server, so there really isn’t much reason to write a specialized client. However, there are thousands of different types of servers that accept standard TCP/IP connections. Every time you use a web browser, it makes a connection to a webserver somewhere. This connection transmits the web page over the connection using HTTP, which defines a certain way to request and send information. By default, webservers run on port 80, which is listed along with many other default ports in /etc/services.</p><p class="s40" style="padding-top: 4pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">From /etc/services</p><p style="text-indent: 0pt;text-align: left;"><br/></p><table style="border-collapse:collapse;margin-left:91.44pt" cellspacing="0"><tr style="height:12pt"><td style="width:34pt;border-top-style:solid;border-top-width:1pt"><p class="s42" style="padding-top: 1pt;text-indent: 0pt;line-height: 10pt;text-align: left;">finger</p></td><td style="width:43pt;border-top-style:solid;border-top-width:1pt"><p class="s42" style="padding-top: 1pt;padding-left: 2pt;padding-right: 2pt;text-indent: 0pt;line-height: 10pt;text-align: center;">79/tcp</p></td><td style="width:256pt;border-top-style:solid;border-top-width:1pt"><p class="s42" style="padding-top: 1pt;padding-left: 25pt;text-indent: 0pt;line-height: 10pt;text-align: left;"># Finger</p></td></tr><tr style="height:11pt"><td style="width:34pt"><p class="s42" style="text-indent: 0pt;line-height: 9pt;text-align: left;">finger</p></td><td style="width:43pt"><p class="s42" style="padding-left: 2pt;padding-right: 2pt;text-indent: 0pt;line-height: 9pt;text-align: center;">79/udp</p></td><td style="width:256pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td></tr><tr style="height:14pt"><td style="width:34pt;border-bottom-style:solid;border-bottom-width:1pt"><p class="s42" style="text-indent: 0pt;line-height: 10pt;text-align: left;">http</p></td><td style="width:43pt;border-bottom-style:solid;border-bottom-width:1pt"><p class="s42" style="padding-left: 2pt;padding-right: 2pt;text-indent: 0pt;line-height: 10pt;text-align: center;">80/tcp</p></td><td style="width:256pt;border-bottom-style:solid;border-bottom-width:1pt"><p class="s42" style="padding-left: 8pt;text-indent: 0pt;line-height: 10pt;text-align: left;">www www-http # World Wide Web HTTP</p></td></tr></table><p style="padding-top: 9pt;padding-left: 91pt;text-indent: 18pt;line-height: 108%;text-align: left;">HTTP exists in the application layer—the top layer—of the OSI model. At this layer, all of the networking details have already been taken care of by the lower layers, so HTTP uses plaintext for its structure. Many other application layer protocols also use plaintext, such as POP3, SMTP, IMAP, and FTP’s control channel. Since these are standard protocols, they are all well documented and easily researched. Once you know the syntax of these various protocols, you can manually talk to other programs that speak the same language. There’s no need to be fluent, but knowing a few important phrases will help you when traveling to foreign servers. In the language of HTTP, requests are made using the command <span class="s31">GET</span>, followed by the resource path and the HTTP protocol version. For example, <span class="s31">GET / HTTP/1.0 </span>will request the root document from the webserver using HTTP version 1.0. The request is actually for the root directory of /, but most webservers will automatically search for a default HTML document in that directory of index.html. If the server finds the resource, it will respond using HTTP by sending several headers before sending the content. If the command <span class="s31">HEAD </span>is used instead of <span class="s31">GET</span>, it will only return the HTTP headers without the content. These headers are plaintext and can usually provide information about the server. These headers can be retrieved manually using telnet by connecting to port 80 of a known website, then typing <span class="s31">HEAD / HTTP/1.0 </span>and pressing <span class="s7">ENTER </span><a href="http://www.internic.net/" class="a" target="_blank">twice. In the output below, telnet is used to open a TCP-IP connection to the webserver at </a>http://www.internic.net. Then the HTTP application layer is manually spoken to request the headers for the main index page.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_642.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;"><a href="http://www.internic.net/" class="s81" target="_blank">reader@hacking:~/booksrc $ telnet </a>www.internic.net 80 Trying 208.77.188.101...</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;"><a href="http://www.internic.net/" class="s81" target="_blank">Connected to </a>www.internic.net. Escape character is &#39;^]&#39;.</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">HEAD / HTTP/1.0</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">HTTP/1.1 200 OK</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">Date: Fri, 14 Sep 2007 05:34:14 GMT</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">Server: Apache/2.0.52 (CentOS) Accept-Ranges: bytes</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">Content-Length: 6743 Connection: close</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">Content-Type: text/html; charset=UTF-8</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-bottom: 2pt;padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">Connection closed by foreign host. reader@hacking:~/booksrc $</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_643.png"/></span></p><p style="padding-top: 3pt;padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: justify;">This reveals that the webserver is Apache version 2.0.52 and even that the host runs CentOS. This can be useful for profiling, so let’s write a pro- gram that automates this manual process.</p><p style="padding-left: 91pt;text-indent: 18pt;line-height: 108%;text-align: justify;">The next few programs will be sending and receiving a lot of data. Since the standard socket functions aren’t very friendly, let’s write some functions to send and receive data. These functions, called <span class="s31">send_string() </span>and <span class="s31">recv_line()</span>, will be added to a new include file called hacking-network.h.</p><p style="padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: left;">The normal <span class="s31">send() </span>function returns the number of bytes written, which isn’t always equal to the number of bytes you tried to send. The <span class="s31">send_string() </span>function accepts a socket and a string pointer as arguments and makes sure the entire string is sent out over the socket. It uses <span class="s31">strlen() </span>to figure out the total length of the string passed to it.</p><p style="padding-left: 91pt;text-indent: 18pt;line-height: 108%;text-align: left;">You may have noticed that every packet the simple server received ended with the bytes <span class="s31">0x0D </span>and <span class="s31">0x0A</span>. This is how telnet terminates the lines—it sends a carriage return and a newline character. The HTTP protocol also expects lines to be terminated with these two bytes. A quick look at an ASCII table shows that <span class="s31">0x0D </span>is a carriage return (<span class="s31">&#39;\r&#39;</span>) and <span class="s31">0x0A </span>is the newline character (<span class="s31">&#39;\n&#39;</span>).</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_644.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">reader@hacking:~/booksrc $ man ascii | egrep &quot;Hex|0A|0D&quot; Reformatting ascii(7), please wait...</p><table style="border-collapse:collapse;margin-left:118.694pt" cellspacing="0"><tr style="height:10pt"><td style="width:22pt"><p class="s42" style="padding-left: 2pt;text-indent: 0pt;line-height: 9pt;text-align: left;">Oct</p></td><td style="width:25pt"><p class="s42" style="padding-left: 6pt;text-indent: 0pt;line-height: 9pt;text-align: left;">Dec</p></td><td style="width:26pt"><p class="s42" style="padding-left: 5pt;padding-right: 5pt;text-indent: 0pt;line-height: 9pt;text-align: center;">Hex</p></td><td style="width:114pt"><p class="s42" style="padding-left: 6pt;text-indent: 0pt;line-height: 9pt;text-align: left;">Char</p></td><td style="width:30pt"><p class="s42" style="padding-left: 9pt;padding-right: 5pt;text-indent: 0pt;line-height: 9pt;text-align: center;">Oct</p></td><td style="width:26pt"><p class="s42" style="padding-left: 6pt;text-indent: 0pt;line-height: 9pt;text-align: left;">Dec</p></td><td style="width:25pt"><p class="s42" style="padding-left: 5pt;padding-right: 5pt;text-indent: 0pt;line-height: 9pt;text-align: center;">Hex</p></td><td style="width:26pt"><p class="s42" style="padding-left: 6pt;text-indent: 0pt;line-height: 9pt;text-align: left;">Char</p></td></tr><tr style="height:11pt"><td style="width:22pt"><p class="s42" style="padding-left: 2pt;text-indent: 0pt;line-height: 10pt;text-align: left;">012</p></td><td style="width:25pt"><p class="s42" style="padding-left: 6pt;text-indent: 0pt;line-height: 10pt;text-align: left;">10</p></td><td style="width:26pt"><p class="s42" style="padding-right: 5pt;text-indent: 0pt;line-height: 10pt;text-align: center;">0A</p></td><td style="width:114pt"><p class="s42" style="padding-left: 6pt;text-indent: 0pt;line-height: 10pt;text-align: left;">LF &#39;\n&#39; (new line)</p></td><td style="width:30pt"><p class="s42" style="padding-left: 9pt;padding-right: 5pt;text-indent: 0pt;line-height: 10pt;text-align: center;">112</p></td><td style="width:26pt"><p class="s42" style="padding-left: 6pt;text-indent: 0pt;line-height: 10pt;text-align: left;">74</p></td><td style="width:25pt"><p class="s42" style="padding-left: 1pt;padding-right: 5pt;text-indent: 0pt;line-height: 10pt;text-align: center;">4A</p></td><td style="width:26pt"><p class="s42" style="padding-left: 6pt;text-indent: 0pt;line-height: 10pt;text-align: left;">J</p></td></tr><tr style="height:10pt"><td style="width:22pt"><p class="s42" style="padding-left: 2pt;text-indent: 0pt;line-height: 9pt;text-align: left;">015</p></td><td style="width:25pt"><p class="s42" style="padding-left: 6pt;text-indent: 0pt;line-height: 9pt;text-align: left;">13</p></td><td style="width:26pt"><p class="s42" style="padding-right: 5pt;text-indent: 0pt;line-height: 9pt;text-align: center;">0D</p></td><td style="width:114pt"><p class="s42" style="padding-left: 6pt;text-indent: 0pt;line-height: 9pt;text-align: left;">CR &#39;\r&#39; (carriage ret)</p></td><td style="width:30pt"><p class="s42" style="padding-left: 9pt;padding-right: 5pt;text-indent: 0pt;line-height: 9pt;text-align: center;">115</p></td><td style="width:26pt"><p class="s42" style="padding-left: 6pt;text-indent: 0pt;line-height: 9pt;text-align: left;">77</p></td><td style="width:25pt"><p class="s42" style="padding-left: 1pt;padding-right: 5pt;text-indent: 0pt;line-height: 9pt;text-align: center;">4D</p></td><td style="width:26pt"><p class="s42" style="padding-left: 6pt;text-indent: 0pt;line-height: 9pt;text-align: left;">M</p></td></tr></table><p class="s31" style="padding-bottom: 3pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">reader@hacking:~/booksrc $</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_645.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 18pt;line-height: 108%;text-align: left;">The <span class="s31">recv_line() </span>function reads entire lines of data. It reads from the socket passed as the first argument into the a buffer that the second argument points to. It continues receiving from the socket until it encounters the last two line- termination bytes in sequence. Then it terminates the string and exits the function. These new functions ensure that all bytes are sent and receive data as lines terminated by <span class="s31">&#39;\r\n&#39;</span>. They are listed below in a new include file called hacking-network.h.</p><p class="s40" style="padding-top: 9pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">hacking-network.h</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_646.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">/* This function accepts a socket FD and a ptr to the null terminated</p><p class="s31" style="padding-left: 95pt;text-indent: 0pt;text-align: left;">* string to send. The function will make sure all the bytes of the</p><p class="s31" style="padding-left: 95pt;text-indent: 0pt;text-align: left;">* string are sent. Returns 1 on success and 0 on failure.</p><p class="s31" style="padding-left: 95pt;text-indent: 0pt;text-align: left;">*/</p><p class="s31" style="padding-left: 104pt;text-indent: -12pt;text-align: left;">int send_string(int sockfd, unsigned char *buffer) { int sent_bytes, bytes_to_send;</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;line-height: 107%;text-align: left;">bytes_to_send = strlen(buffer); while(bytes_to_send &gt; 0) {</p><p class="s31" style="padding-left: 116pt;text-indent: 0pt;text-align: left;">sent_bytes = send(sockfd, buffer, bytes_to_send, 0); if(sent_bytes == -1)</p><p class="s31" style="padding-left: 129pt;text-indent: 0pt;text-align: left;">return 0; // Return 0 on send error.</p><p class="s31" style="padding-top: 2pt;padding-left: 116pt;text-indent: 0pt;text-align: left;">bytes_to_send -= sent_bytes; buffer += sent_bytes;</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;text-align: left;">}</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;text-align: left;">return 1; // Return 1 on success.</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">}</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-top: 4pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">/* This function accepts a socket FD and a ptr to a destination</p><p class="s31" style="padding-left: 95pt;text-indent: 0pt;text-align: left;">* buffer. It will receive from the socket until the EOL byte</p><p class="s31" style="padding-left: 95pt;text-indent: 0pt;text-align: left;">* sequence in seen. The EOL bytes are read from the socket, but</p><p class="s31" style="padding-left: 95pt;text-indent: 0pt;text-align: left;">* the destination buffer is terminated before these bytes.</p><p class="s31" style="padding-left: 95pt;text-indent: 0pt;text-align: left;">* Returns the size of the read line (without EOL bytes).</p><p class="s31" style="padding-left: 95pt;text-indent: 0pt;text-align: left;">*/</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 106%;text-align: left;">int recv_line(int sockfd, unsigned char *dest_buffer) { #define EOL &quot;\r\n&quot; // End-of-line byte sequence #define EOL_SIZE 2</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;line-height: 107%;text-align: left;">unsigned char *ptr; int eol_matched = 0;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;text-align: left;">ptr = dest_buffer;</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;text-align: left;">while(recv(sockfd, ptr, 1, 0) == 1) { // Read a single byte.</p><p class="s31" style="padding-left: 129pt;text-indent: -12pt;text-align: left;">if(*ptr == EOL[eol_matched]) { // Does this byte match terminator? eol_matched++;</p><p class="s31" style="padding-left: 129pt;text-indent: 0pt;text-align: left;">if(eol_matched == EOL_SIZE) { // If all bytes match terminator,</p><p class="s31" style="padding-left: 142pt;text-indent: 0pt;line-height: 107%;text-align: left;">*(ptr+1-EOL_SIZE) = &#39;\0&#39;; // terminate the string. return strlen(dest_buffer); // Return bytes received</p><p class="s31" style="text-indent: 0pt;line-height: 10pt;text-align: center;">}</p><p class="s31" style="padding-left: 27pt;text-indent: 0pt;text-align: center;">} else {</p><p class="s31" style="padding-left: 86pt;text-indent: 0pt;text-align: center;">eol_matched = 0;</p><p class="s31" style="padding-left: 116pt;text-indent: 0pt;text-align: left;">}</p><p class="s31" style="padding-left: 116pt;text-indent: 0pt;text-align: left;">ptr++; // Increment the pointer to the next byter.</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;text-align: left;">}</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;text-align: left;">return 0; // Didn&#39;t find the end-of-line characters.</p><p class="s31" style="padding-bottom: 3pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">}</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_647.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 91pt;text-indent: 18pt;line-height: 108%;text-align: left;">Making a socket connection to a numerical IP address is pretty simple but named addresses are commonly used for convenience. In the manual <span class="s31">HTTP HEAD </span><a href="http://www.internic.net/" class="a" target="_blank">request, the telnet program automatically does a DNS (Domain Name Service) lookup to determine that </a>www.internic.net translates to the IP address 192.0.34.161. DNS is a protocol that allows an IP address to be looked up by a named address, similar to how a phone number can be looked up in a phone book if you know the name. Naturally, there are socket-related functions and structures specifically for hostname lookups via DNS. These functions and struc- tures are defined in netdb.h. A function called <span class="s31">gethostbyname() </span>takes a pointer to a string containing a named address and returns a pointer to a <span class="s31">hostent </span>structure, or <span class="s31">NULL </span>pointer on error. The <span class="s31">hostent </span>structure is filled with infor- mation from the lookup, including the numerical IP address as a 32-bit integer in network byte order. Similar to the <span class="s31">inet_ntoa() </span>function, the memory for this structure is statically allocated in the function. This structure is shown below, as listed in netdb.h.</p><p class="s40" style="padding-top: 4pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">From /usr/include/netdb.h</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_648.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">/* Description of database entry for a single host. */ struct hostent</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">{</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;line-height: 107%;text-align: left;">char *h_name;   /* Official name of host.  */ char **h_aliases;  /* Alias list.  */</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;line-height: 107%;text-align: left;">int h_addrtype;  /* Host address type. */ int h_length;   /* Length of address. */</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;text-align: left;">char **h_addr_list;  /* List of addresses from name server. */</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">#define h_addr h_addr_list[0] /* Address, for backward compatibility. */</p><p class="s31" style="padding-bottom: 3pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">};</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_649.png"/></span></p><p style="padding-top: 7pt;padding-left: 109pt;text-indent: 0pt;text-align: left;">The following code demonstrates the use of the <span class="s31">gethostbyname() </span>function.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s40" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">host_lookup.c</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_650.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 106%;text-align: left;">#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;sys/socket.h&gt; #include &lt;netinet/in.h&gt; #include &lt;arpa/inet.h&gt;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 212%;text-align: left;">#include &lt;netdb.h&gt; #include &quot;hacking.h&quot;</p><p class="s31" style="padding-left: 104pt;text-indent: -12pt;line-height: 106%;text-align: left;">int main(int argc, char *argv[]) { struct hostent *host_info; struct in_addr *address;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;text-align: left;">if(argc &lt; 2) {</p><p class="s31" style="padding-left: 116pt;text-indent: 0pt;text-align: left;">printf(&quot;Usage: %s &lt;hostname&gt;\n&quot;, argv[0]); exit(1);</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;text-align: left;">}</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;text-align: left;">host_info = gethostbyname(argv[1]); if(host_info == NULL) {</p><p class="s31" style="padding-left: 116pt;text-indent: 0pt;text-align: left;">printf(&quot;Couldn&#39;t lookup %s\n&quot;, argv[1]);</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;text-align: left;">} else {</p><p class="s31" style="padding-left: 116pt;text-indent: 0pt;text-align: left;">address = (struct in_addr *) (host_info-&gt;h_addr); printf(&quot;%s has address %s\n&quot;, argv[1], inet_ntoa(*address));</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;text-align: left;">}</p><p class="s31" style="padding-bottom: 3pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">}</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_651.png"/></span></p><p style="padding-top: 8pt;padding-left: 91pt;text-indent: 18pt;line-height: 108%;text-align: left;">This program accepts a hostname as its only argument and prints out the IP address. The <span class="s31">gethostbyname() </span>function returns a pointer to a <span class="s31">hostent </span>struc- ture, which contains the IP address in element <span class="s31">h_addr</span>. A pointer to this element is typecast into an <span class="s31">in_addr </span>pointer, which is later dereferenced for the call to <span class="s31">inet_ntoa()</span>, which expects a <span class="s31">in_addr </span>structure as its argument. Sample program output is shown on the following page.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_652.png"/></span></p><p class="s31" style="padding-bottom: 2pt;padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;"><a href="http://www.internic.net/" class="s81" target="_blank">reader@hacking:~/booksrc $ gcc -o host_lookup host_lookup.c reader@hacking:~/booksrc $ ./host_lookup www.internic.net </a><a href="http://www.google.com/" class="s81" target="_blank">www.internic.net has address 208.77.188.101 reader@hacking:~/booksrc $ ./host_lookup www.google.com </a>www.google.com has address 74.125.19.103 reader@hacking:~/booksrc $</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_653.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s40" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">webserver_id.c</p><p style="padding-top: 4pt;padding-left: 8pt;text-indent: 17pt;line-height: 110%;text-align: left;">Using socket functions to build on this, creating a webserver identification program isn’t that difficult.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_654.png"/></span></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 106%;text-align: left;">#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;sys/socket.h&gt; #include &lt;netinet/in.h&gt; #include &lt;arpa/inet.h&gt; #include &lt;netdb.h&gt;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">#include &quot;hacking.h&quot; #include &quot;hacking-network.h&quot;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 32pt;text-indent: -12pt;text-align: left;">int main(int argc, char *argv[]) { int sockfd;</p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;line-height: 107%;text-align: left;">struct hostent *host_info; struct sockaddr_in target_addr; unsigned char buffer[4096];</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;text-align: left;">if(argc &lt; 2) {</p><p class="s31" style="padding-left: 44pt;text-indent: 0pt;line-height: 107%;text-align: left;">printf(&quot;Usage: %s &lt;hostname&gt;\n&quot;, argv[0]); exit(1);</p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;line-height: 10pt;text-align: left;">}</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 44pt;text-indent: -12pt;line-height: 107%;text-align: left;">if((host_info = gethostbyname(argv[1])) == NULL) fatal(&quot;looking up hostname&quot;);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 44pt;text-indent: -12pt;line-height: 107%;text-align: left;">if ((sockfd = socket(PF_INET, SOCK_STREAM, 0)) == -1) fatal(&quot;in socket&quot;);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;line-height: 107%;text-align: left;">target_addr.sin_family = AF_INET; target_addr.sin_port = htons(80);</p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;line-height: 107%;text-align: left;">target_addr.sin_addr = *((struct in_addr *)host_info-&gt;h_addr); memset(&amp;(target_addr.sin_zero), &#39;\0&#39;, 8); // Zero the rest of the struct.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 44pt;text-indent: -12pt;line-height: 107%;text-align: left;">if (connect(sockfd, (struct sockaddr *)&amp;target_addr, sizeof(struct sockaddr)) == -1) fatal(&quot;connecting to target server&quot;);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;text-align: left;">send_string(sockfd, &quot;HEAD / HTTP/1.0\r\n\r\n&quot;);</p><p class="s31" style="padding-top: 2pt;padding-left: 44pt;text-indent: -12pt;text-align: left;">while(recv_line(sockfd, buffer)) { if(strncasecmp(buffer, &quot;Server:&quot;, 7) == 0) {</p><p class="s31" style="padding-left: 57pt;text-indent: 0pt;line-height: 107%;text-align: left;">printf(&quot;The web server for %s is %s\n&quot;, argv[1], buffer+8); exit(0);</p><p class="s31" style="padding-left: 44pt;text-indent: 0pt;text-align: left;">}</p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;text-align: left;">}</p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;line-height: 107%;text-align: left;">printf(&quot;Server line not found\n&quot;); exit(1);</p><p class="s31" style="padding-bottom: 3pt;padding-left: 19pt;text-indent: 0pt;text-align: left;">}</p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_655.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 91pt;text-indent: 18pt;line-height: 107%;text-align: left;">Most of this code should make sense to you now. The <span class="s31">target_addr </span>struc- ture’s <span class="s31">sin_addr </span>element is filled using the address from the <span class="s31">host_info </span>structure by typecasting and then dereferencing as before (but this time it’s done in a single line). The <span class="s31">connect() </span>function is called to connect to port 80 of the target host, the command string is sent, and the program loops reading each line into buffer. The <span class="s31">strncasecmp() </span>function is a string comparison function from strings.h. This function compares the first <span class="s27">n </span>bytes of two strings, ignoring capitalization. The first two arguments are pointers to the strings, and the third argument is <span class="s27">n</span>, the number of bytes to compare. The function will return <span class="s31">0 </span>if the strings match, so the <span class="s31">if </span>statement is searching for the line that starts with <span class="s31">&quot;Server:&quot;</span>. When it finds it, it removes the first eight bytes and prints the web- server version information. The following listing shows compilation and execution of the program.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_656.png"/></span></p><p class="s31" style="padding-bottom: 2pt;padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;"><a href="http://www.internic.net/" class="s81" target="_blank">reader@hacking:~/booksrc $ gcc -o webserver_id webserver_id.c reader@hacking:~/booksrc $ ./webserver_id www.internic.net The web server for </a><a href="http://www.microsoft.com/" class="s81" target="_blank">www.internic.net is Apache/2.0.52 (CentOS) reader@hacking:~/booksrc $ ./webserver_id www.microsoft.com The web server for </a>www.microsoft.com is Microsoft-IIS/7.0 reader@hacking:~/booksrc $</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_657.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part80.htm">&lt; Previous</a><span> | </span><a href="../hacking-the-art-of-exploitation.html">Contents</a><span> | </span><a href="part82.htm">Next &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
