<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>0x622 Tinyweb Daemon</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part133.htm">&lt; Previous</a><span> | </span><a href="../hacking-the-art-of-exploitation.html">Contents</a><span> | </span><a href="part135.htm">Next &gt;</a></p><p class="s32" style="padding-left: 91pt;text-indent: 0pt;text-align: left;"><a name="bookmark121">0x622 Tinyweb Daemon</a></p><p style="padding-top: 7pt;padding-left: 91pt;text-indent: 0pt;line-height: 108%;text-align: left;">This newer version of the tinyweb program is a system daemon that runs in the background without a controlling terminal. It writes its output to a log file with timestamps, and it listens for the terminate (<span class="s31">SIGTERM</span>) signal so it can shut down cleanly when itâ€™s killed.</p><p style="padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: justify;">These additions are fairly minor, but they provide a much more realistic exploit target. The new portions of the code are shown in bold in the listing below.</p><p class="s40" style="padding-top: 4pt;padding-left: 19pt;text-indent: 0pt;text-align: left;">tinywebd.c</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_1003.png"/></span></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 106%;text-align: left;">#include &lt;sys/stat.h&gt; #include &lt;sys/socket.h&gt; #include &lt;netinet/in.h&gt; #include &lt;arpa/inet.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/stat.h&gt; #include &lt;fcntl.h&gt; <b>#include &lt;time.h&gt; #include &lt;signal.h&gt; </b>#include &quot;hacking.h&quot;</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">#include &quot;hacking-network.h&quot;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 106%;text-align: left;">#define PORT 80  // The port users will be connecting to #define WEBROOT &quot;./webroot&quot; // The webserver&#39;s root directory <b>#define LOGFILE &quot;/var/log/tinywebd.log&quot; // Log filename</b></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s46" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">int logfd, sockfd; // Global log and socket file descriptors void handle_connection(int, struct sockaddr_in *, int);</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">int get_file_size(int); // Returns the file size of open file descriptor</p><p class="s46" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">void timestamp(int); // Writes a timestamp to the open file descriptor</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s46" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">// This function is called when the process is killed. void handle_shutdown(int signal) {</p><p class="s46" style="padding-left: 32pt;text-indent: 0pt;text-align: left;">timestamp(logfd);</p><p class="s46" style="padding-left: 32pt;text-indent: 0pt;text-align: left;">write(logfd, &quot;Shutting down.\n&quot;, 16); close(logfd);</p><p class="s46" style="padding-left: 32pt;text-indent: 0pt;line-height: 107%;text-align: left;">close(sockfd); exit(0);</p><p class="s46" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">}</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">int main(void) {</p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;text-align: left;">int new_sockfd, yes=1;</p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;line-height: 107%;text-align: left;">struct sockaddr_in host_addr, client_addr;  // My address information socklen_t sin_size;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s46" style="padding-left: 32pt;text-indent: 0pt;text-align: left;">logfd = open(LOGFILE, O_WRONLY|O_CREAT|O_APPEND, S_IRUSR|S_IWUSR);</p><p class="s46" style="padding-left: 44pt;text-indent: -12pt;line-height: 107%;text-align: left;">if(logfd == -1) fatal(&quot;opening log file&quot;);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 44pt;text-indent: -12pt;line-height: 107%;text-align: left;">if ((sockfd = socket(PF_INET, SOCK_STREAM, 0)) == -1) fatal(&quot;in socket&quot;);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 44pt;text-indent: -12pt;line-height: 107%;text-align: left;">if (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &amp;yes, sizeof(int)) == -1) fatal(&quot;setting socket option SO_REUSEADDR&quot;);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s46" style="padding-left: 32pt;text-indent: 0pt;text-align: left;">printf(&quot;Starting tiny web daemon.\n&quot;);</p><p class="s46" style="padding-left: 44pt;text-indent: -12pt;line-height: 107%;text-align: left;">if(daemon(1, 0) == -1) // Fork to a background daemon process. fatal(&quot;forking to daemon process&quot;);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s46" style="padding-left: 32pt;text-indent: 0pt;text-align: left;">signal(SIGTERM, handle_shutdown);  // Call handle_shutdown when killed. signal(SIGINT, handle_shutdown);  // Call handle_shutdown when interrupted.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s46" style="padding-left: 32pt;text-indent: 0pt;text-align: left;">timestamp(logfd);</p><p class="s46" style="padding-top: 2pt;padding-left: 32pt;text-indent: 0pt;text-align: left;">write(logfd, &quot;Starting up.\n&quot;, 15);</p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;line-height: 107%;text-align: left;">host_addr.sin_family = AF_INET;   // Host byte order host_addr.sin_port = htons(PORT);  // Short, network byte order host_addr.sin_addr.s_addr = INADDR_ANY; // Automatically fill with my IP. memset(&amp;(host_addr.sin_zero), &#39;\0&#39;, 8); // Zero the rest of the struct.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 44pt;text-indent: -12pt;line-height: 107%;text-align: left;">if (bind(sockfd, (struct sockaddr *)&amp;host_addr, sizeof(struct sockaddr)) == -1) fatal(&quot;binding to socket&quot;);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 44pt;text-indent: -12pt;line-height: 107%;text-align: left;">if (listen(sockfd, 20) == -1) fatal(&quot;listening on socket&quot;);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;text-align: left;">while(1) { // Accept loop.</p><p class="s31" style="padding-left: 44pt;text-indent: 0pt;text-align: left;">sin_size = sizeof(struct sockaddr_in);</p><p class="s31" style="padding-left: 44pt;text-indent: 0pt;line-height: 107%;text-align: left;">new_sockfd = accept(sockfd, (struct sockaddr *)&amp;client_addr, &amp;sin_size); if(new_sockfd == -1)</p><p class="s31" style="padding-left: 57pt;text-indent: 0pt;text-align: left;">fatal(&quot;accepting connection&quot;);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s46" style="padding-top: 4pt;padding-left: 44pt;text-indent: 0pt;text-align: left;">handle_connection(new_sockfd, &amp;client_addr, logfd);</p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;text-align: left;">}</p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;text-align: left;">return 0;</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">}</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s46" style="padding-top: 4pt;padding-left: 19pt;text-indent: 0pt;text-align: left;">/* This function handles the connection on the passed socket from the</p><p class="s46" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">* passed client address and logs to the passed FD. The connection is</p><p class="s46" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">* processed as a web request and this function replies over the connected</p><p class="s46" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">* socket. Finally, the passed socket is closed at the end of the function.</p><p class="s46" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">*/</p><p class="s46" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">void handle_connection(int sockfd, struct sockaddr_in *client_addr_ptr, int logfd) {</p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;line-height: 107%;text-align: left;">unsigned char *ptr, request[500], resource[500]<b>, log_buffer[500]</b>; int fd, length;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;text-align: left;">length = recv_line(sockfd, request);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s46" style="padding-left: 19pt;text-indent: 12pt;text-align: left;">sprintf(log_buffer, &quot;From %s:%d \&quot;%s\&quot;\t&quot;, inet_ntoa(client_addr_ptr-&gt;sin_addr), ntohs(client_addr_ptr-&gt;sin_port), request);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;line-height: 107%;text-align: left;">ptr = strstr(request, &quot; HTTP/&quot;); // Search for valid-looking request. if(ptr == NULL) { // Then this isn&#39;t valid HTTP</p><p class="s31" style="padding-left: 44pt;text-indent: 0pt;text-align: left;">strcat(log_buffer, &quot; NOT HTTP!\n&quot;);</p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;text-align: left;">} else {</p><p class="s31" style="padding-left: 44pt;text-indent: 0pt;text-align: left;">*ptr = 0; // Terminate the buffer at the end of the URL.</p><p class="s31" style="padding-left: 44pt;text-indent: 0pt;line-height: 107%;text-align: left;">ptr = NULL; // Set ptr to NULL (used to flag for an invalid request). if(strncmp(request, &quot;GET &quot;, 4) == 0) // Get request</p><p class="s31" style="padding-left: 44pt;text-indent: 12pt;line-height: 107%;text-align: left;">ptr = request+4; // ptr is the URL. if(strncmp(request, &quot;HEAD &quot;, 5) == 0) // Head request</p><p class="s31" style="padding-left: 57pt;text-indent: 0pt;text-align: left;">ptr = request+5; // ptr is the URL.</p><p class="s31" style="padding-left: 57pt;text-indent: -13pt;text-align: left;">if(ptr == NULL) { // Then this is not a recognized request strcat(log_buffer, &quot; UNKNOWN REQUEST!\n&quot;);</p><p class="s31" style="padding-left: 18pt;text-indent: 0pt;text-align: center;">} else { // Valid request, with ptr pointing to the resource name</p><p class="s31" style="padding-left: 57pt;text-indent: 0pt;line-height: 106%;text-align: center;">if (ptr[strlen(ptr) - 1] == &#39;/&#39;) // For resources ending with &#39;/&#39;, strcat(ptr, &quot;index.html&quot;);   // add &#39;index.html&#39; to the end. strcpy(resource, WEBROOT);   // Begin resource with web root path strcat(resource, ptr);     // and join it with resource path.</p><p class="s31" style="padding-left: 18pt;text-indent: 0pt;text-align: center;">fd = open(resource, O_RDONLY, 0); // Try to open the file.</p><p class="s31" style="padding-top: 2pt;padding-left: 70pt;text-indent: -12pt;text-align: left;">if(fd == -1) { // If file is not found <b>strcat(log_buffer, &quot; 404 Not Found\n&quot;); </b>send_string(sockfd, &quot;HTTP/1.0 404 NOT FOUND\r\n&quot;); send_string(sockfd, &quot;Server: Tiny webserver\r\n\r\n&quot;);</p><p class="s31" style="padding-left: 70pt;text-indent: 0pt;text-align: left;">send_string(sockfd, &quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;404 Not Found&lt;/title&gt;&lt;/head&gt;&quot;); send_string(sockfd, &quot;&lt;body&gt;&lt;h1&gt;URL not found&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;\r\n&quot;);</p><p class="s31" style="padding-left: 70pt;text-indent: -12pt;line-height: 106%;text-align: left;">} else {   // Otherwise, serve up the file. <b>strcat(log_buffer, &quot; 200 OK\n&quot;); </b>send_string(sockfd, &quot;HTTP/1.0 200 OK\r\n&quot;);</p><p class="s31" style="padding-left: 70pt;text-indent: 0pt;text-align: left;">send_string(sockfd, &quot;Server: Tiny webserver\r\n\r\n&quot;); if(ptr == request + 4) { // Then this is a GET request</p><p class="s31" style="padding-left: 95pt;text-indent: -12pt;text-align: left;">if( (length = get_file_size(fd)) == -1) fatal(&quot;getting resource file size&quot;);</p><p class="s31" style="padding-left: 83pt;text-indent: 0pt;text-align: center;">if( (ptr = (unsigned char *) malloc(length)) == NULL) fatal(&quot;allocating memory for reading resource&quot;); read(fd, ptr, length); // Read the file into memory. send(sockfd, ptr, length, 0);  // Send it to socket.</p><p class="s31" style="padding-left: 18pt;text-indent: 0pt;text-align: center;">free(ptr); // Free file memory.</p><p class="s31" style="padding-left: 57pt;text-indent: 0pt;line-height: 10pt;text-align: left;">}</p><p class="s31" style="padding-left: 57pt;text-indent: 0pt;text-align: left;">close(fd); // Close the file.</p><p class="s31" style="padding-left: 57pt;text-indent: 0pt;text-align: left;">} // End if block for file found/not found.</p><p class="s31" style="padding-left: 44pt;text-indent: 0pt;text-align: left;">} // End if block for valid request.</p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;text-align: left;">} // End if block for valid HTTP.</p><p class="s46" style="padding-left: 32pt;text-indent: 0pt;text-align: left;">timestamp(logfd);</p><p class="s46" style="padding-left: 32pt;text-indent: 0pt;text-align: left;">length = strlen(log_buffer);</p><p class="s46" style="padding-left: 32pt;text-indent: 0pt;text-align: left;">write(logfd, log_buffer, length); // Write to the log.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-top: 4pt;padding-left: 32pt;text-indent: 0pt;text-align: left;">shutdown(sockfd, SHUT_RDWR); // Close the socket gracefully.</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">}</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-top: 4pt;padding-left: 19pt;text-indent: 0pt;text-align: left;">/* This function accepts an open file descriptor and returns</p><p class="s31" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">* the size of the associated file. Returns -1 on failure.</p><p class="s31" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">*/</p><p class="s31" style="padding-left: 32pt;text-indent: -12pt;text-align: left;">int get_file_size(int fd) { struct stat stat_struct;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-top: 4pt;padding-left: 44pt;text-indent: -12pt;text-align: left;">if(fstat(fd, &amp;stat_struct) == -1) return -1;</p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;line-height: 10pt;text-align: left;">return (int) stat_struct.st_size;</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">}</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s46" style="padding-top: 4pt;padding-left: 19pt;text-indent: 0pt;text-align: left;">/* This function writes a timestamp string to the open file descriptor</p><p class="s46" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">* passed to it.</p><p class="s46" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">*/</p><p class="s46" style="padding-left: 32pt;text-indent: -12pt;text-align: left;">void timestamp(fd) { time_t now;</p><p class="s46" style="padding-left: 32pt;text-indent: 0pt;line-height: 107%;text-align: left;">struct tm *time_struct; int length;</p><p class="s46" style="padding-left: 32pt;text-indent: 0pt;line-height: 10pt;text-align: left;">char time_buffer[40];</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s46" style="padding-top: 4pt;padding-left: 32pt;text-indent: 0pt;text-align: justify;">time(&amp;now); // Get number of seconds since epoch.</p><p class="s46" style="padding-left: 32pt;text-indent: 0pt;text-align: justify;">time_struct = localtime((const time_t *)&amp;now); // Convert to tm struct. length = strftime(time_buffer, 40, &quot;%m/%d/%Y %H:%M:%S&gt; &quot;, time_struct); write(fd, time_buffer, length); // Write timestamp string to log.</p><p class="s46" style="padding-bottom: 3pt;padding-left: 19pt;text-indent: 0pt;line-height: 10pt;text-align: left;">}</p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_1004.png"/></span></p><p style="padding-top: 3pt;padding-left: 91pt;text-indent: 18pt;line-height: 108%;text-align: left;">This daemon program forks into the background, writes to a log file with timestamps, and cleanly exits when it is killed. The log file descriptor and connection-receiving socket are declared as globals so they can be closed cleanly by the <span class="s31">handle_shutdown() </span>function. This function is set up as the callback handler for the terminate and interrupt signals, which allows the program to exit gracefully when itâ€™s killed with the <span class="s31">kill </span>command.</p><p style="padding-left: 109pt;text-indent: 0pt;line-height: 11pt;text-align: left;">The output below shows the program compiled, executed, and killed.</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 108%;text-align: left;">Notice that the log file contains timestamps as well as the shutdown message when the program catches the terminate signal and calls <span class="s31">handle_shutdown() </span>to exit gracefully.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_1005.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 106%;text-align: left;">reader@hacking:~/booksrc $ gcc -o tinywebd tinywebd.c reader@hacking:~/booksrc $ sudo chown root ./tinywebd reader@hacking:~/booksrc $ sudo chmod u+s ./tinywebd reader@hacking:~/booksrc $ ./tinywebd</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">Starting tiny web daemon.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 106%;text-align: left;">reader@hacking:~/booksrc $ ./webserver_id 127.0.0.1 The web server for 127.0.0.1 is Tiny webserver reader@hacking:~/booksrc $ ps ax | grep tinywebd 25058 ?    Ss  0:00 ./tinywebd</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 106%;text-align: left;">25075 pts/3   R+   0:00 grep tinywebd reader@hacking:~/booksrc $ kill 25058 reader@hacking:~/booksrc $ ps ax | grep tinywebd 25121 pts/3   R+   0:00 grep tinywebd reader@hacking:~/booksrc $ cat /var/log/tinywebd.log cat: /var/log/tinywebd.log: Permission denied</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">reader@hacking:~/booksrc $ sudo cat /var/log/tinywebd.log 07/22/2007 17:55:45&gt; Starting up.</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">07/22/2007 17:57:00&gt; From 127.0.0.1:38127 &quot;HEAD / HTTP/1.0&quot;   200 OK</p><p class="s31" style="padding-bottom: 3pt;padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">07/22/2007 17:57:21&gt; Shutting down. reader@hacking:~/booksrc $</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_1006.png"/></span></p><p style="padding-top: 6pt;padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: left;">This tinywebd program serves HTTP content just like the original tinyweb program, but it behaves as a system daemon, detaching from the controlling terminal and writing to a log file. Both programs are vulnerable to the same overflow exploit; however, the exploitation is only the beginning. Using the new tinyweb daemon as a more realistic exploit target, you will learn how to avoid detection after the intrusion.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="toc">&nbsp;</p><div class="toc"><a class="toc0" href="part135.htm">0x630 Tools of the Trade</a></div><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part133.htm">&lt; Previous</a><span> | </span><a href="../hacking-the-art-of-exploitation.html">Contents</a><span> | </span><a href="part135.htm">Next &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
