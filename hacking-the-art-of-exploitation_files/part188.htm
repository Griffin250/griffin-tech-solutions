<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>0x771 Wired Equivalent Privacy</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part187.htm">&lt; Previous</a><span> | </span><a href="../hacking-the-art-of-exploitation.html">Contents</a><span> | </span><a href="part189.htm">Next &gt;</a></p><p class="s32" style="padding-left: 91pt;text-indent: 0pt;text-align: left;"><a name="bookmark173">0x771 Wired Equivalent Privacy</a></p><p style="padding-top: 8pt;padding-left: 91pt;text-indent: 0pt;line-height: 108%;text-align: left;">WEP was meant to be an encryption method providing security equivalent to a wired access point. It was originally designed with 40-bit keys; later, WEP2 came along to increase the key size to 104 bits. All of the encryption is done on a per-packet basis, so each packet is essentially a separate plaintext message to send. The packet will be called <span class="s27">M</span>.</p><p style="padding-left: 109pt;text-indent: 0pt;line-height: 10pt;text-align: left;">First, a checksum of message M is computed, so the message integrity</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 108%;text-align: left;">can be checked later. This is done using a 32-bit cyclic redundancy check- sum function aptly named CRC32. This checksum will be called <span class="s27">CS</span>, so</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 108%;text-align: left;">CS = CRC32(M). This value is appended to the end of the message, which makes up the plaintext message P<span class="s27">:</span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="232" height="50" alt="image" src="Image_1309.png"/></span></p><p class="s69" style="padding-top: 6pt;padding-left: 3pt;text-indent: 0pt;text-align: left;">CRC(M) CS</p><p style="text-indent: 0pt;text-align: left;"/><p class="s69" style="padding-top: 6pt;padding-left: 45pt;text-indent: 0pt;text-align: center;">Message M</p><p style="text-indent: 0pt;text-align: left;"/><p class="s121" style="padding-top: 7pt;padding-left: 143pt;text-indent: 0pt;text-align: left;">Plaintext message P</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 7pt;padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: left;">Now, the plaintext message needs to be encrypted. This is done using RC4, which is a stream cipher. This cipher, initialized with a seed value,</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 108%;text-align: left;">can generate a keystream, which is just an arbitrarily long stream of pseudo- random bytes. WEP uses an initialization vector (IV) for the seed value.</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 108%;text-align: left;">The IV consists of 24 bits generated for each packet. Some older WEP implementations simply use sequential values for the IV, while others use some form of pseudo-randomizer.</p><p style="padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: left;">Regardless of how the 24 bits of IV are chosen, they are prepended to the WEP key. (These 24 bits of IV are included in the WEP key size in a bit of clever marketing spin; when a vendor talks about 64-bit or 128-bit WEP keys, the actual keys are only 40 bits and 104 bits, respectively, combined with 24 bits of IV.) The IV and the WEP key together make up the seed value, which will be called S.</p><p style="text-indent: 0pt;text-align: left;"><span><img width="232" height="31" alt="image" src="Image_1310.png"/></span></p><p class="s69" style="padding-top: 6pt;padding-left: 24pt;text-indent: 0pt;text-align: left;">40-bit or 104-bit WEP key</p><p style="text-indent: 0pt;text-align: left;"/><p class="s69" style="padding-top: 6pt;padding-left: 8pt;text-indent: 0pt;text-align: left;">24-bit IV</p><p style="text-indent: 0pt;text-align: left;"/><p class="s121" style="padding-top: 8pt;padding-left: 86pt;text-indent: 0pt;text-align: center;">Seed value S</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 93pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span><img width="229" height="15" alt="image" src="Image_1311.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 7pt;padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: left;">Then the seed value S is fed into RC4, which will generate a keystream. This keystream is XORed with the plaintext message P to produce the ciphertext C. The IV is prepended to the ciphertext, and the whole thing is encapsulated with yet another header and sent out over the radio link.</p><p class="s69" style="padding-top: 6pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Plaintext message P (M with 32-bit CS)</p><p style="padding-left: 135pt;text-indent: 0pt;text-align: left;"/><p class="s69" style="padding-top: 5pt;padding-left: 86pt;text-indent: 0pt;text-align: center;">XOR</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s69" style="padding-top: 6pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">Keystream generated by RC4(seed)</p><p style="padding-left: 135pt;text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="232" height="31" alt="image" src="Image_1312.png"/></span></p><p class="s69" style="padding-top: 6pt;padding-left: 42pt;text-indent: 0pt;text-align: center;">Ciphertext C</p><p style="text-indent: 0pt;text-align: left;"/><p class="s69" style="padding-top: 6pt;padding-left: 8pt;text-indent: 0pt;text-align: left;">24-bit IV</p><p style="text-indent: 0pt;text-align: left;"/><p class="s69" style="padding-top: 5pt;padding-left: 86pt;text-indent: 0pt;text-align: center;">equals</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 7pt;padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: left;">When the recipient receives a WEP-encrypted packet, the process is simply reversed. The recipient pulls the IV from the message and then concatenates the IV with his own WEP key to produce a seed value of S. If the sender and receiver both have the same WEP key, the seed values will be the same. This seed is fed into RC4 again to produce the same keystream, which is XORed with the rest of the encrypted message. This will produce the original plaintext message, consisting of the packet message M concatenated with the integrity checksum CS. The recipient then uses the same CRC32 function to recalculate the checksum for M and checks that the calculated value matches the received value of CS. If the checksums match, the packet is passed on. Otherwise, there were too many transmission errors or the WEP keys didn’t match, and the packet is dropped.</p><p style="padding-left: 109pt;text-indent: 0pt;line-height: 11pt;text-align: left;">That’s basically WEP in a nutshell.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part187.htm">&lt; Previous</a><span> | </span><a href="../hacking-the-art-of-exploitation.html">Contents</a><span> | </span><a href="part189.htm">Next &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
