<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>0x475  Proactive Defense (shroud)</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part106.htm">&lt; Previous</a><span> | </span><a href="../hacking-the-art-of-exploitation.html">Contents</a><span> | </span><a href="part108.htm">Next &gt;</a></p><p class="s32" style="padding-top: 4pt;padding-left: 91pt;text-indent: 0pt;text-align: left;"><a name="bookmark96">0x475  Proactive Defense (shroud)</a></p><p style="padding-top: 5pt;padding-left: 91pt;text-indent: 0pt;line-height: 108%;text-align: left;">Port scans are often used to profile systems before they are attacked. Know- ing what ports are open allows an attacker to determine which services can be attacked. Many IDSs offer methods to detect port scans, but by then the information has already been leaked. While writing this chapter, I wondered if it is possible to prevent port scans before they actually happen. Hacking, really, is all about coming up with new ideas, so a newly developed method for proactive port-scanning defense will be presented here.</p><p style="padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: left;">First of all, the FIN, Null, and X-mas scans can be prevented by a simple kernel modification. If the kernel never sends reset packets, these scans will turn up nothing. The following output uses <span class="s31">grep </span>to find the kernel code responsible for sending reset packets.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_797.png"/></span></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">reader@hacking:~/booksrc $ grep -n -A 20 &quot;void.*send_reset&quot; /usr/src/linux/net/ipv4/tcp_ipv4.c 547:static void tcp_v4_send_reset(struct sock *sk, struct sk_buff *skb)</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">548-{</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">549-  struct tcphdr *th = skb-&gt;h.th;</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">550-  struct {</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">551-      struct tcphdr th;</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">552-#ifdef CONFIG_TCP_MD5SIG</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">553- <u>&nbsp;</u>be32 opt[(TCPOLEN_MD5SIG_ALIGNED &gt;&gt; 2)];</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">554-#endif</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">555-  } rep;</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">556-  struct ip_reply_arg arg;</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">557-#ifdef CONFIG_TCP_MD5SIG</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">558-  struct tcp_md5sig_key *key; 559-#endif</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">560-</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s46" style="padding-left: 40pt;text-indent: 0pt;text-align: left;">return; // Modification: Never send RST, always return.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">561-  /* Never send a reset in response to a reset. */</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">562-  if (th-&gt;rst)</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">563-      return;</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">564-</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">565-  if (((struct rtable *)skb-&gt;dst)-&gt;rt_type != RTN_LOCAL)</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">566-      return;</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">567-</p><p class="s31" style="padding-bottom: 3pt;padding-left: 19pt;text-indent: 0pt;text-align: left;">reader@hacking:~/booksrc $</p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_798.png"/></span></p><p style="padding-top: 7pt;padding-left: 91pt;text-indent: 18pt;line-height: 108%;text-align: left;">By adding the <span class="s31">return </span>command (shown above in bold), the <span class="s31">tcp_v4_send_reset() </span>kernel function will simply return instead of doing anything. After the kernel is recompiled, the resulting kernel won’t send out reset packets, avoiding information leakage.</p><p class="s40" style="padding-top: 9pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">FIN Scan Before the Kernel Modification</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_799.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">matrix@euclid:~ $ sudo nmap -T5 -sF 192.168.42.72</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;"><a href="http://www.insecure.org/nmap/" class="s81" target="_blank">Starting Nmap 4.11 ( </a>http://www.insecure.org/nmap/ ) at 2007-03-17 16:58 PDT Interesting ports on 192.168.42.72:</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">Not shown: 1678 closed ports</p><p class="s31" style="padding-top: 2pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">PORT  STATE    SERVICE</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">22/tcp open|filtered ssh 80/tcp open|filtered http</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">MAC Address: 00:01:6C:EB:1D:50 (Foxconn)</p><p class="s31" style="padding-bottom: 3pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">Nmap finished: 1 IP address (1 host up) scanned in 1.462 seconds matrix@euclid:~ $</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_800.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s40" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">FIN Scan After the Kernel Modification</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_801.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">matrix@euclid:~ $ sudo nmap -T5 -sF 192.168.42.72</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;"><a href="http://www.insecure.org/nmap/" class="s81" target="_blank">Starting Nmap 4.11 ( </a>http://www.insecure.org/nmap/ ) at 2007-03-17 16:58 PDT Interesting ports on 192.168.42.72:</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">Not shown: 1678 closed ports PORT  STATE    SERVICE</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 10pt;text-align: left;">MAC Address: 00:01:6C:EB:1D:50 (Foxconn)</p><p class="s31" style="padding-bottom: 2pt;padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">Nmap finished: 1 IP address (1 host up) scanned in 1.462 seconds matrix@euclid:~ $</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_802.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s40" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">shroud.c</p><p style="padding-top: 4pt;padding-left: 19pt;text-indent: 17pt;line-height: 108%;text-align: justify;">This works fine for scans that rely on RST packets, but preventing infor- mation leakage with SYN scans and full-connect scans is a bit more difficult. In order to maintain functionality, open ports have to respond with SYN/ACK packets—there is no way around that. But if all of the closed ports also</p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 108%;text-align: left;">responded with SYN/ACK packets, the amount of useful information an attacker could retrieve from port scans would be minimized. Simply opening every port would cause a major performance hit, though, which isn’t desirable. Ideally, this should all be done without using a TCP stack. The following pro- gram does exactly that. It’s a modification of the rst_hijack.c program, using a more complex BPF string to filter only SYN packets destined for closed ports. The callback function spoofs a legitimate looking SYN/ACK response to any SYN packet that makes it through the BPF. This will flood port scanners with a sea of false positives, which will hide legitimate ports.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_803.png"/></span></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 106%;text-align: left;">#include &lt;libnet.h&gt; #include &lt;pcap.h&gt; #include &quot;hacking.h&quot;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">#define MAX_EXISTING_PORTS 30</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">void caught_packet(u_char *, const struct pcap_pkthdr *, const u_char *); int set_packet_filter(pcap_t *, struct in_addr *, u_short *);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 32pt;text-indent: -12pt;line-height: 106%;text-align: left;">struct data_pass { int libnet_handle; u_char *packet;</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">};</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 32pt;text-indent: -12pt;line-height: 106%;text-align: left;">int main(int argc, char *argv[]) { struct pcap_pkthdr cap_header; const u_char *packet, *pkt_data; pcap_t *pcap_handle;</p><p class="s31" style="padding-top: 2pt;padding-left: 32pt;text-indent: 0pt;text-align: left;">char errbuf[PCAP_ERRBUF_SIZE]; // Same size as LIBNET_ERRBUF_SIZE char *device;</p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;text-align: left;">u_long target_ip; int network, i;</p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;text-align: left;">struct data_pass critical_libnet_data; u_short existing_ports[MAX_EXISTING_PORTS];</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 44pt;text-indent: -12pt;text-align: left;">if((argc &lt; 2) || (argc &gt; MAX_EXISTING_PORTS+2)) { if(argc &gt; 2)</p><p class="s31" style="padding-left: 44pt;text-indent: 12pt;text-align: left;">printf(&quot;Limited to tracking %d existing ports.\n&quot;, MAX_EXISTING_PORTS); else</p><p class="s31" style="padding-left: 44pt;text-indent: 12pt;text-align: left;">printf(&quot;Usage: %s &lt;IP to shroud&gt; [existing ports...]\n&quot;, argv[0]); exit(0);</p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;line-height: 9pt;text-align: left;">}</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;text-align: left;">target_ip = libnet_name_resolve(argv[1], LIBNET_RESOLVE); if (target_ip == -1)</p><p class="s31" style="padding-left: 44pt;text-indent: 0pt;line-height: 10pt;text-align: left;">fatal(&quot;Invalid target address&quot;);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;text-align: left;">for(i=2; i &lt; argc; i++)</p><p class="s31" style="padding-left: 32pt;text-indent: 12pt;line-height: 209%;text-align: left;">existing_ports[i-2] = (u_short) atoi(argv[i]); existing_ports[argc-2] = 0;</p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;text-align: left;">device = pcap_lookupdev(errbuf); if(device == NULL)</p><p class="s31" style="padding-left: 44pt;text-indent: 0pt;line-height: 10pt;text-align: left;">fatal(errbuf);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;text-align: left;">pcap_handle = pcap_open_live(device, 128, 1, 0, errbuf); if(pcap_handle == NULL)</p><p class="s31" style="padding-left: 44pt;text-indent: 0pt;line-height: 10pt;text-align: left;">fatal(errbuf);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;text-align: left;">critical_libnet_data.libnet_handle = libnet_open_raw_sock(IPPROTO_RAW); if(critical_libnet_data.libnet_handle == -1)</p><p class="s31" style="padding-left: 19pt;text-indent: 25pt;text-align: left;">libnet_error(LIBNET_ERR_FATAL, &quot;can&#39;t open network interface. -- this program must run as root.\n&quot;);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;text-align: left;">libnet_init_packet(LIBNET_IP_H + LIBNET_TCP_H, &amp;(critical_libnet_data.packet)); if (critical_libnet_data.packet == NULL)</p><p class="s31" style="padding-left: 32pt;text-indent: 12pt;line-height: 209%;text-align: left;">libnet_error(LIBNET_ERR_FATAL, &quot;can&#39;t initialize packet memory.\n&quot;); libnet_seed_prand();</p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;text-align: left;">set_packet_filter(pcap_handle, (struct in_addr *)&amp;target_ip, existing_ports);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-top: 4pt;padding-left: 32pt;text-indent: 0pt;text-align: left;">pcap_loop(pcap_handle, -1, caught_packet, (u_char *)&amp;critical_libnet_data); pcap_close(pcap_handle);</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 10pt;text-align: left;">}</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-top: 4pt;padding-left: 19pt;text-indent: 0pt;text-align: left;">/* Sets a packet filter to look for established TCP connections to target_ip */</p><p class="s31" style="padding-left: 32pt;text-indent: -12pt;text-align: left;">int set_packet_filter(pcap_t *pcap_hdl, struct in_addr *target_ip, u_short *ports) { struct bpf_program filter;</p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;text-align: left;">char *str_ptr, filter_string[90 + (25 * MAX_EXISTING_PORTS)]; int i=0;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;text-align: left;">sprintf(filter_string, &quot;dst host %s and &quot;, inet_ntoa(*target_ip)); // Target IP</p><p class="s31" style="padding-top: 2pt;padding-left: 32pt;text-indent: 0pt;text-align: left;">strcat(filter_string, &quot;tcp[tcpflags] &amp; tcp-syn != 0 and tcp[tcpflags] &amp; tcp-ack = 0&quot;);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 44pt;text-indent: -12pt;line-height: 107%;text-align: left;">if(ports[0] != 0) { // If there is at least one existing port str_ptr = filter_string + strlen(filter_string); if(ports[1] == 0) // There is only one existing port</p><p class="s31" style="padding-left: 44pt;text-indent: 12pt;line-height: 107%;text-align: left;">sprintf(str_ptr, &quot; and not dst port %hu&quot;, ports[i]); else { // Two or more existing ports</p><p class="s31" style="padding-left: 57pt;text-indent: 0pt;line-height: 107%;text-align: left;">sprintf(str_ptr, &quot; and not (dst port %hu&quot;, ports[i++]); while(ports[i] != 0) {</p><p class="s31" style="padding-left: 70pt;text-indent: 0pt;line-height: 107%;text-align: left;">str_ptr = filter_string + strlen(filter_string); sprintf(str_ptr, &quot; or dst port %hu&quot;, ports[i++]);</p><p class="s31" style="padding-left: 57pt;text-indent: 0pt;line-height: 9pt;text-align: left;">}</p><p class="s31" style="padding-left: 57pt;text-indent: 0pt;text-align: left;">strcat(filter_string, &quot;)&quot;);</p><p class="s31" style="padding-left: 44pt;text-indent: 0pt;text-align: left;">}</p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;text-align: left;">}</p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;line-height: 107%;text-align: left;">printf(&quot;DEBUG: filter string is \&#39;%s\&#39;\n&quot;, filter_string); if(pcap_compile(pcap_hdl, &amp;filter, filter_string, 0, 0) == -1)</p><p class="s31" style="padding-left: 44pt;text-indent: 0pt;line-height: 10pt;text-align: left;">fatal(&quot;pcap_compile failed&quot;);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-top: 4pt;padding-left: 44pt;text-indent: -12pt;line-height: 107%;text-align: left;">if(pcap_setfilter(pcap_hdl, &amp;filter) == -1) fatal(&quot;pcap_setfilter failed&quot;);</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 10pt;text-align: left;">}</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-top: 4pt;padding-left: 19pt;text-indent: 0pt;line-height: 10pt;text-align: left;">void caught_packet(u_char *user_args, const struct pcap_pkthdr *cap_header, const u_char</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 10pt;text-align: left;">*packet) {</p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;text-align: left;">u_char *pkt_data;</p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;line-height: 106%;text-align: left;">struct libnet_ip_hdr *IPhdr; struct libnet_tcp_hdr *TCPhdr; struct data_pass *passed;</p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;text-align: left;">int bcount;</p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;line-height: 21pt;text-align: left;">passed = (struct data_pass *) user_args; // Pass data using a pointer to a struct IPhdr = (struct libnet_ip_hdr *) (packet + LIBNET_ETH_H);</p><p class="s31" style="padding-top: 1pt;padding-left: 32pt;text-indent: 0pt;text-align: left;">TCPhdr = (struct libnet_tcp_hdr *) (packet + LIBNET_ETH_H + LIBNET_TCP_H);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 44pt;text-indent: -12pt;line-height: 107%;text-align: left;">libnet_build_ip(LIBNET_TCP_H,   // Size of the packet sans IP header IPTOS_LOWDELAY,        // IP tos</p><p class="s31" style="padding-left: 44pt;text-indent: 0pt;line-height: 107%;text-align: left;">libnet_get_prand(LIBNET_PRu16), // IP ID (randomized) 0,               // Frag stuff</p><p class="s31" style="padding-left: 44pt;text-indent: 0pt;line-height: 107%;text-align: left;">libnet_get_prand(LIBNET_PR8),  // TTL (randomized) IPPROTO_TCP,          // Transport protocol</p><p class="s31" style="padding-left: 44pt;text-indent: 0pt;text-align: left;">*((u_long *)&amp;(IPhdr-&gt;ip_dst)), // Source IP (pretend we are dst)</p><p class="s31" style="padding-left: 44pt;text-indent: 0pt;text-align: left;">*((u_long *)&amp;(IPhdr-&gt;ip_src)),  // Destination IP (send back to src) NULL,               // Payload (none)</p><p class="s31" style="padding-left: 44pt;text-indent: 0pt;text-align: left;">0,               // Payload length</p><p class="s31" style="padding-left: 44pt;text-indent: 0pt;text-align: left;">passed-&gt;packet);        // Packet header memory</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 44pt;text-indent: -12pt;line-height: 107%;text-align: left;">libnet_build_tcp(htons(TCPhdr-&gt;th_dport),// Source TCP port (pretend we are dst) htons(TCPhdr-&gt;th_sport),     // Destination TCP port (send back to src) htonl(TCPhdr-&gt;th_ack),      // Sequence number (use previous ack) htonl((TCPhdr-&gt;th_seq) + 1),   // Acknowledgement number (SYN&#39;s seq # + 1) TH_SYN | TH_ACK,         // Control flags (RST flag set only) libnet_get_prand(LIBNET_PRu16), // Window size (randomized)</p><p class="s31" style="padding-left: 44pt;text-indent: 0pt;line-height: 10pt;text-align: left;">0,               // Urgent pointer</p><p class="s31" style="padding-top: 2pt;padding-left: 44pt;text-indent: 0pt;text-align: left;">NULL,              // Payload (none)</p><p class="s31" style="padding-left: 44pt;text-indent: 0pt;text-align: left;">0,               // Payload length</p><p class="s31" style="padding-left: 44pt;text-indent: 0pt;text-align: left;">(passed-&gt;packet) + LIBNET_IP_H);// Packet header memory</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 44pt;text-indent: -12pt;text-align: left;">if (libnet_do_checksum(passed-&gt;packet, IPPROTO_TCP, LIBNET_TCP_H) == -1) libnet_error(LIBNET_ERR_FATAL, &quot;can&#39;t compute checksum\n&quot;);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-top: 4pt;padding-left: 32pt;text-indent: 0pt;line-height: 107%;text-align: left;">bcount = libnet_write_ip(passed-&gt;libnet_handle, passed-&gt;packet, LIBNET_IP_H+LIBNET_TCP_H); if (bcount &lt; LIBNET_IP_H + LIBNET_TCP_H)</p><p class="s31" style="padding-left: 32pt;text-indent: 12pt;line-height: 107%;text-align: left;">libnet_error(LIBNET_ERR_WARNING, &quot;Warning: Incomplete packet written.&quot;); printf(&quot;bing!\n&quot;);</p><p class="s31" style="padding-bottom: 3pt;padding-left: 19pt;text-indent: 0pt;text-align: left;">}</p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_804.png"/></span></p><p style="padding-top: 7pt;padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: justify;">There are a few tricky parts in the code above, but you should be able to follow all of it. When the program is compiled and executed, it will shroud the IP address given as the first argument, with the exception of a list of existing ports provided as the remaining arguments.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_805.png"/></span></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">reader@hacking:~/booksrc $ gcc $(libnet-config --defines) -o shroud shroud.c -lnet -lpcap reader@hacking:~/booksrc $ sudo ./shroud 192.168.42.72 22 80</p><p class="s31" style="padding-bottom: 3pt;padding-left: 19pt;text-indent: 0pt;text-align: left;">DEBUG: filter string is &#39;dst host 192.168.42.72 and tcp[tcpflags] &amp; tcp-syn != 0 and tcp[tcpflags] &amp; tcp-ack = 0 and not (dst port 22 or dst port 80)&#39;</p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_806.png"/></span></p><p style="padding-top: 8pt;padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: justify;">While shroud is running, any port scanning attempts will show every port to be open.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_807.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">matrix@euclid:~ $ sudo nmap -sS 192.168.0.189</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;"><a href="http://www.insecure.org/nmap/" class="s81" target="_blank">Starting nmap V. 3.00 ( </a>www.insecure.org/nmap/ ) Interesting ports on (192.168.0.189):</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 10pt;text-align: left;">Port    State    Service</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">1/tcp   open    tcpmux</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">2/tcp   open    compressnet</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">3/tcp   open    compressnet</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">4/tcp   open    unknown</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">5/tcp   open    rje</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">6/tcp   open    unknown</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">7/tcp   open    echo</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">8/tcp   open    unknown</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">9/tcp   open    discard</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">10/tcp  open    unknown</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">11/tcp   open    systat</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">12/tcp  open    unknown</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">13/tcp   open    daytime</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">14/tcp  open    unknown</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">15/tcp   open    netstat</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">16/tcp  open    unknown</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">17/tcp   open    qotd</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">18/tcp   open    msp</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">19/tcp   open    chargen</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">20/tcp   open    ftp-data</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">21/tcp   open    ftp</p><p class="s46" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">22/tcp   open    ssh</p><table style="border-collapse:collapse;margin-left:88.94pt" cellspacing="0"><tr style="height:10pt"><td style="width:39pt"><p class="s42" style="padding-left: 2pt;text-indent: 0pt;line-height: 9pt;text-align: left;">23/tcp</p></td><td style="width:44pt"><p class="s42" style="padding-left: 10pt;text-indent: 0pt;line-height: 9pt;text-align: left;">open</p></td><td style="width:58pt"><p class="s42" style="padding-left: 16pt;text-indent: 0pt;line-height: 9pt;text-align: left;">telnet</p></td></tr><tr style="height:11pt"><td style="width:39pt"><p class="s42" style="padding-left: 2pt;text-indent: 0pt;line-height: 9pt;text-align: left;">24/tcp</p></td><td style="width:44pt"><p class="s42" style="padding-left: 10pt;text-indent: 0pt;line-height: 9pt;text-align: left;">open</p></td><td style="width:58pt"><p class="s42" style="padding-left: 16pt;text-indent: 0pt;line-height: 9pt;text-align: left;">priv-mail</p></td></tr><tr style="height:10pt"><td style="width:39pt"><p class="s42" style="padding-left: 2pt;text-indent: 0pt;line-height: 9pt;text-align: left;">25/tcp</p></td><td style="width:44pt"><p class="s42" style="padding-left: 10pt;text-indent: 0pt;line-height: 9pt;text-align: left;">open</p></td><td style="width:58pt"><p class="s42" style="padding-left: 16pt;text-indent: 0pt;line-height: 9pt;text-align: left;">smtp</p></td></tr></table><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-top: 4pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">[ output trimmed ]</p><p style="text-indent: 0pt;text-align: left;"><br/></p><table style="border-collapse:collapse;margin-left:88.94pt" cellspacing="0"><tr style="height:10pt"><td style="width:45pt"><p class="s42" style="padding-left: 2pt;text-indent: 0pt;line-height: 9pt;text-align: left;">32780/tcp</p></td><td style="width:38pt"><p class="s42" style="padding-left: 4pt;text-indent: 0pt;line-height: 9pt;text-align: left;">open</p></td><td style="width:101pt"><p class="s42" style="padding-left: 16pt;text-indent: 0pt;line-height: 9pt;text-align: left;">sometimes-rpc23</p></td></tr><tr style="height:11pt"><td style="width:45pt"><p class="s42" style="padding-left: 2pt;text-indent: 0pt;line-height: 10pt;text-align: left;">32786/tcp</p></td><td style="width:38pt"><p class="s42" style="padding-left: 4pt;text-indent: 0pt;line-height: 10pt;text-align: left;">open</p></td><td style="width:101pt"><p class="s42" style="padding-left: 16pt;text-indent: 0pt;line-height: 10pt;text-align: left;">sometimes-rpc25</p></td></tr><tr style="height:11pt"><td style="width:45pt"><p class="s42" style="padding-left: 2pt;text-indent: 0pt;line-height: 9pt;text-align: left;">32787/tcp</p></td><td style="width:38pt"><p class="s42" style="padding-left: 4pt;text-indent: 0pt;line-height: 9pt;text-align: left;">open</p></td><td style="width:101pt"><p class="s42" style="padding-left: 16pt;text-indent: 0pt;line-height: 9pt;text-align: left;">sometimes-rpc27</p></td></tr><tr style="height:11pt"><td style="width:45pt"><p class="s42" style="padding-left: 2pt;text-indent: 0pt;line-height: 9pt;text-align: left;">43188/tcp</p></td><td style="width:38pt"><p class="s42" style="padding-left: 4pt;text-indent: 0pt;line-height: 9pt;text-align: left;">open</p></td><td style="width:101pt"><p class="s42" style="padding-left: 16pt;text-indent: 0pt;line-height: 9pt;text-align: left;">reachout</p></td></tr><tr style="height:11pt"><td style="width:45pt"><p class="s42" style="padding-left: 2pt;text-indent: 0pt;line-height: 10pt;text-align: left;">44442/tcp</p></td><td style="width:38pt"><p class="s42" style="padding-left: 4pt;text-indent: 0pt;line-height: 10pt;text-align: left;">open</p></td><td style="width:101pt"><p class="s42" style="padding-left: 16pt;text-indent: 0pt;line-height: 10pt;text-align: left;">coldfusion-auth</p></td></tr><tr style="height:11pt"><td style="width:45pt"><p class="s42" style="padding-left: 2pt;text-indent: 0pt;line-height: 10pt;text-align: left;">44443/tcp</p></td><td style="width:38pt"><p class="s42" style="padding-left: 4pt;text-indent: 0pt;line-height: 10pt;text-align: left;">open</p></td><td style="width:101pt"><p class="s42" style="padding-left: 16pt;text-indent: 0pt;line-height: 10pt;text-align: left;">coldfusion-auth</p></td></tr><tr style="height:11pt"><td style="width:45pt"><p class="s42" style="padding-left: 2pt;text-indent: 0pt;line-height: 9pt;text-align: left;">47557/tcp</p></td><td style="width:38pt"><p class="s42" style="padding-left: 4pt;text-indent: 0pt;line-height: 9pt;text-align: left;">open</p></td><td style="width:101pt"><p class="s42" style="padding-left: 16pt;text-indent: 0pt;line-height: 9pt;text-align: left;">dbbrowse</p></td></tr><tr style="height:11pt"><td style="width:45pt"><p class="s42" style="padding-left: 2pt;text-indent: 0pt;line-height: 9pt;text-align: left;">49400/tcp</p></td><td style="width:38pt"><p class="s42" style="padding-left: 4pt;text-indent: 0pt;line-height: 9pt;text-align: left;">open</p></td><td style="width:101pt"><p class="s42" style="padding-left: 16pt;text-indent: 0pt;line-height: 9pt;text-align: left;">compaqdiag</p></td></tr><tr style="height:11pt"><td style="width:45pt"><p class="s42" style="padding-left: 2pt;text-indent: 0pt;line-height: 10pt;text-align: left;">54320/tcp</p></td><td style="width:38pt"><p class="s42" style="padding-left: 4pt;text-indent: 0pt;line-height: 10pt;text-align: left;">open</p></td><td style="width:101pt"><p class="s42" style="padding-left: 16pt;text-indent: 0pt;line-height: 10pt;text-align: left;">bo2k</p></td></tr><tr style="height:11pt"><td style="width:45pt"><p class="s42" style="padding-left: 2pt;text-indent: 0pt;line-height: 10pt;text-align: left;">61439/tcp</p></td><td style="width:38pt"><p class="s42" style="padding-left: 4pt;text-indent: 0pt;line-height: 10pt;text-align: left;">open</p></td><td style="width:101pt"><p class="s42" style="padding-left: 16pt;text-indent: 0pt;line-height: 10pt;text-align: left;">netprowler-manager</p></td></tr><tr style="height:11pt"><td style="width:45pt"><p class="s42" style="padding-left: 2pt;text-indent: 0pt;line-height: 9pt;text-align: left;">61440/tcp</p></td><td style="width:38pt"><p class="s42" style="padding-left: 4pt;text-indent: 0pt;line-height: 9pt;text-align: left;">open</p></td><td style="width:101pt"><p class="s42" style="padding-left: 16pt;text-indent: 0pt;line-height: 9pt;text-align: left;">netprowler-manager2</p></td></tr><tr style="height:11pt"><td style="width:45pt"><p class="s42" style="padding-left: 2pt;text-indent: 0pt;line-height: 9pt;text-align: left;">61441/tcp</p></td><td style="width:38pt"><p class="s42" style="padding-left: 4pt;text-indent: 0pt;line-height: 9pt;text-align: left;">open</p></td><td style="width:101pt"><p class="s42" style="padding-left: 16pt;text-indent: 0pt;line-height: 9pt;text-align: left;">netprowler-sensor</p></td></tr><tr style="height:10pt"><td style="width:45pt"><p class="s42" style="padding-left: 2pt;text-indent: 0pt;line-height: 9pt;text-align: left;">65301/tcp</p></td><td style="width:38pt"><p class="s42" style="padding-left: 4pt;text-indent: 0pt;line-height: 9pt;text-align: left;">open</p></td><td style="width:101pt"><p class="s42" style="padding-left: 16pt;text-indent: 0pt;line-height: 9pt;text-align: left;">pcanywhere</p></td></tr></table><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-bottom: 3pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">Nmap run completed -- 1 IP address (1 host up) scanned in 37 seconds matrix@euclid:~ $</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_808.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: left;">The only service that is actually running is ssh on port 22, but it is hidden in a sea of false positives. A dedicated attacker could simply telnet to every port to check the banners, but this technique could easily be expanded to spoof banners also.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="toc">&nbsp;</p><div class="toc"><a class="toc0" href="part108.htm">0x480 Reach Out and Hack Someone</a></div><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part106.htm">&lt; Previous</a><span> | </span><a href="../hacking-the-art-of-exploitation.html">Contents</a><span> | </span><a href="part108.htm">Next &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
