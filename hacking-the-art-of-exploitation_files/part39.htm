<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>0x271  Memory Segments in C</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part38.htm">&lt; Previous</a><span> | </span><a href="../hacking-the-art-of-exploitation.html">Contents</a><span> | </span><a href="part40.htm">Next &gt;</a></p><p class="s32" style="padding-left: 91pt;text-indent: 0pt;text-align: left;"><a name="bookmark29">0x271  Memory Segments in C</a></p><p class="s56" style="padding-left: 26pt;text-indent: 0pt;line-height: 5pt;text-align: left;">Low addresses</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s57" style="padding-left: 97pt;text-indent: 0pt;text-align: left;"><span><img width="4" height="33" alt="image" src="Image_242.png"/></span>	<span><img width="4" height="46" alt="image" src="Image_243.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s56" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">High addresses</p><p style="padding-top: 7pt;padding-left: 91pt;text-indent: 0pt;line-height: 108%;text-align: left;">In C, as in other compiled languages, the compiled code goes into the text segment, while the variables reside in the remaining segments. Exactly which memory segment a variable will be stored in depends on how the variable is defined. Variables that are defined outside of any functions are considered to be global. The <span class="s31">static </span>keyword can also be prepended to any variable declaration to make the variable static. If static or global variables are initial- ized with data, they are stored in the data memory segment; otherwise, these variables are put in the bss memory segment. Memory on the heap memory segment must first be allocated using a memory allocation function called <span class="s31">malloc()</span>. Usually, pointers are used to reference memory on the heap.</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 108%;text-align: left;">Finally, the remaining function variables are stored in the stack memory segment. Since the stack can contain many different stack frames, stack variables can maintain uniqueness within different functional contexts. The memory_segments.c program will help explain these concepts in C.</p><p class="s40" style="padding-top: 9pt;padding-left: 19pt;text-indent: 0pt;text-align: left;">memory_segments.c</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_244.png"/></span></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 214%;text-align: left;">#include &lt;stdio.h&gt; int global_var;</p><p class="s31" style="padding-top: 2pt;padding-left: 19pt;text-indent: 0pt;text-align: left;">int global_initialized_var = 5;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">void function() {  // This is just a demo function.</p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;text-align: left;">int stack_var; // Notice this variable has the same name as the one in main().</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-top: 4pt;padding-left: 32pt;text-indent: 0pt;text-align: left;">printf(&quot;the function&#39;s stack_var is at address 0x%08x\n&quot;, &amp;stack_var);</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">}</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-top: 4pt;padding-left: 19pt;text-indent: 0pt;text-align: left;">int main() {</p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;line-height: 107%;text-align: left;">int stack_var; // Same name as the variable in function() static int static_initialized_var = 5;</p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;text-align: left;">static int static_var; int *heap_var_ptr;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;text-align: left;">heap_var_ptr = (int *) malloc(4);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;text-align: left;">// These variables are in the data segment.</p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;line-height: 107%;text-align: left;">printf(&quot;global_initialized_var is at address 0x%08x\n&quot;, &amp;global_initialized_var); printf(&quot;static_initialized_var is at address 0x%08x\n\n&quot;, &amp;static_initialized_var);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;line-height: 107%;text-align: left;">// These variables are in the bss segment. printf(&quot;static_var is at address 0x%08x\n&quot;, &amp;static_var); printf(&quot;global_var is at address 0x%08x\n\n&quot;, &amp;global_var);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;text-align: left;">// This variable is in the heap segment.</p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;text-align: left;">printf(&quot;heap_var is at address 0x%08x\n\n&quot;, heap_var_ptr);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-top: 4pt;padding-left: 32pt;text-indent: 0pt;line-height: 106%;text-align: left;">// These variables are in the stack segment. printf(&quot;stack_var is at address 0x%08x\n&quot;, &amp;stack_var); function();</p><p class="s31" style="padding-bottom: 3pt;padding-left: 19pt;text-indent: 0pt;text-align: left;">}</p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_245.png"/></span></p><p style="padding-top: 7pt;padding-left: 91pt;text-indent: 18pt;line-height: 108%;text-align: left;">Most of this code is fairly self-explanatory because of the descriptive variable names. The global and static variables are declared as described earlier, and initialized counterparts are also declared. The stack variable is declared both in <span class="s31">main() </span>and in <span class="s31">function() </span>to showcase the effect of functional contexts. The heap variable is actually declared as an integer pointer, which will point to memory allocated on the heap memory segment. The <span class="s31">malloc() </span>function is called to allocate four bytes on the heap. Since the newly allocated memory could be of any data type, the <span class="s31">malloc() </span>function returns a void pointer, which needs to be typecast into an integer pointer.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_246.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 106%;text-align: left;">reader@hacking:~/booksrc $ gcc memory_segments.c reader@hacking:~/booksrc $ ./a.out global_initialized_var is at address 0x080497ec static_initialized_var is at address 0x080497f0</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">static_var is at address 0x080497f8 global_var is at address 0x080497fc</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">heap_var is at address 0x0804a008</p><p class="s31" style="padding-top: 2pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">stack_var is at address 0xbffff834</p><p class="s31" style="padding-bottom: 2pt;padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">the function&#39;s stack_var is at address 0xbffff814 reader@hacking:~/booksrc $</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_247.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s40" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">heap_example.c</p><p style="padding-top: 4pt;padding-left: 6pt;text-indent: 18pt;line-height: 108%;text-align: left;">The first two initialized variables have the lowest memory addresses, since they are located in the data memory segment. The next two variables, <span class="s31">static_var </span>and <span class="s31">global_var</span>, are stored in the bss memory segment, since they aren’t initialized. These memory addresses are slightly larger than the previous variables’ addresses, since the bss segment is located below the data segment. Since both of these memory segments have a fixed size after compilation, there is little wasted space, and the addresses aren’t very far apart.</p><p style="padding-left: 6pt;text-indent: 17pt;line-height: 108%;text-align: left;">The heap variable is stored in space allocated on the heap segment, which is located just below the bss segment. Remember that memory in this segment isn’t fixed, and more space can be dynamically allocated later. Finally, the last two <span class="s31">stack_var</span>s have very large memory addresses, since they are located in the stack segment. Memory in the stack isn’t fixed, either; however, this memory starts at the bottom and grows backward toward the heap segment. This allows both memory segments to be dynamic without wasting space in memory. The first <span class="s31">stack_var </span>in the <span class="s31">main() </span>function’s context is stored in the stack segment within a stack frame. The second <span class="s31">stack_var </span>in <span class="s31">function() </span>has its own unique context, so that variable is stored within a different stack frame in the stack segment. When <span class="s31">function() </span>is called near the end of the program, a new stack frame is created to store (among other things) the <span class="s31">stack_var </span>for <span class="s31">function()</span>’s context. Since the stack grows back up toward the heap segment with each new stack frame, the memory address for the second <span class="s31">stack_var </span>(<span class="s31">0xbffff814</span>) is smaller than the address for the first <span class="s31">stack_var </span>(<span class="s31">0xbffff834</span>) found within <span class="s31">main()</span>’s context.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part38.htm">&lt; Previous</a><span> | </span><a href="../hacking-the-art-of-exploitation.html">Contents</a><span> | </span><a href="part40.htm">Next &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
