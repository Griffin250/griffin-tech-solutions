<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>0x265 Typecasting</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part34.htm">&lt; Previous</a><span> | </span><a href="../hacking-the-art-of-exploitation.html">Contents</a><span> | </span><a href="part36.htm">Next &gt;</a></p><p class="s32" style="padding-left: 91pt;text-indent: 0pt;text-align: left;"><a name="bookmark25">0x265 Typecasting</a></p><p class="s27" style="padding-top: 7pt;padding-left: 91pt;text-indent: 0pt;line-height: 106%;text-align: left;">Typecasting <span class="p">is simply a way to temporarily change a variable’s data type, despite how it was originally defined. When a variable is typecast into a different type, the compiler is basically told to treat that variable as if it were the new data type, but only for that operation. The syntax for typecasting is</span></p><p style="padding-left: 91pt;text-indent: 0pt;text-align: left;">as follows:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_165.png"/></span></p><p class="s31" style="padding-bottom: 3pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">(typecast_data_type) variable</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_166.png"/></span></p><p style="padding-top: 7pt;padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: left;">This can be used when dealing with integers and floating-point variables, as typecasting.c demonstrates.</p><p class="s40" style="padding-top: 9pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">typecasting.c</p><p style="text-indent: 0pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_167.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 21pt;text-align: left;">#include &lt;stdio.h&gt; int main() {</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;line-height: 8pt;text-align: left;">int a, b;</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;text-align: left;">float c, d;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;text-align: left;">a = 13;</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;text-align: left;">b = 5;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;text-align: left;">c = a / b;          // Divide using integers.</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;text-align: left;">d = (float) a / (float) b;  // Divide integers typecast as floats.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-top: 4pt;padding-left: 104pt;text-indent: 0pt;line-height: 107%;text-align: left;">printf(&quot;[integers]\t a = %d\t b = %d\n&quot;, a, b); printf(&quot;[floats]\t c = %f\t d = %f\n&quot;, c, d);</p><p class="s31" style="padding-bottom: 3pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">}</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_168.png"/></span></p><p style="padding-top: 6pt;padding-left: 109pt;text-indent: 0pt;text-align: left;">The results of compiling and executing typecasting.c are as follows.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_169.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 106%;text-align: left;">reader@hacking:~/booksrc $ gcc typecasting.c reader@hacking:~/booksrc $ ./a.out [integers]    a = 13  b = 5</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">[floats]     c = 2.000000  d = 2.600000</p><p class="s31" style="padding-bottom: 3pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">reader@hacking:~/booksrc $</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_170.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s40" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">pointer_types.c</p><p style="padding-top: 3pt;padding-left: 8pt;text-indent: 17pt;line-height: 108%;text-align: left;">As discussed earlier, dividing the integer 13 by 5 will round down to the incorrect answer of 2, even if this value is being stored into a floating-point variable. However, if these integer variables are typecast into floats, they will be treated as such. This allows for the correct calculation of 2.6.</p><p style="padding-left: 8pt;text-indent: 18pt;line-height: 108%;text-align: left;">This example is illustrative, but where typecasting really shines is when it is used with pointer variables. Even though a pointer is just a memory address, the C compiler still demands a data type for every pointer. One reason for this is to try to limit programming errors. An integer pointer should only point to integer data, while a character pointer should only point to char- acter data. Another reason is for pointer arithmetic. An integer is four bytes in size, while a character only takes up a single byte. The pointer_types.c pro- gram will demonstrate and explain these concepts further. This code uses the format parameter <span class="s31">%p </span>to output memory addresses. This is shorthand meant for displaying pointers and is basically equivalent to <span class="s31">0x%08x</span>.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_171.png"/></span></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">#include &lt;stdio.h&gt;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 32pt;text-indent: -12pt;line-height: 107%;text-align: left;">int main() { int i;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;line-height: 107%;text-align: left;">char char_array[5] = {&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;}; int int_array[5] = {1, 2, 3, 4, 5};</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;line-height: 107%;text-align: left;">char *char_pointer; int *int_pointer;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;text-align: left;">char_pointer = char_array; int_pointer = int_array;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 44pt;text-indent: -12pt;line-height: 107%;text-align: left;">for(i=0; i &lt; 5; i++) { // Iterate through the int array with the int_pointer. printf(&quot;[integer pointer] points to %p, which contains the integer %d\n&quot;,</p><p class="s31" style="padding-left: 44pt;text-indent: 25pt;line-height: 107%;text-align: left;">int_pointer, *int_pointer); int_pointer = int_pointer + 1;</p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;line-height: 10pt;text-align: left;">}</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 44pt;text-indent: -12pt;line-height: 107%;text-align: left;">for(i=0; i &lt; 5; i++) { // Iterate through the char array with the char_pointer. printf(&quot;[char pointer] points to %p, which contains the char &#39;%c&#39;\n&quot;,</p><p class="s31" style="padding-left: 44pt;text-indent: 25pt;line-height: 107%;text-align: left;">char_pointer, *char_pointer); char_pointer = char_pointer + 1;</p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;line-height: 10pt;text-align: left;">}</p><p class="s31" style="padding-bottom: 3pt;padding-left: 19pt;text-indent: 0pt;text-align: left;">}</p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_172.png"/></span></p><p style="padding-top: 7pt;padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: left;">In this code two arrays are defined in memory—one containing integer data and the other containing character data. Two pointers are also defined, one with the integer data type and one with the character data type, and they are set to point at the start of the corresponding data arrays. Two separate for loops iterate through the arrays using pointer arithmetic to adjust the pointer to point at the next value. In the loops, when the integer and character values</p><p style="padding-top: 3pt;padding-left: 91pt;text-indent: 0pt;line-height: 108%;text-align: left;">are actually printed with the <span class="s31">%d </span>and <span class="s31">%c </span>format parameters, notice that the corresponding <span class="s31">printf() </span>arguments must dereference the pointer variables.</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 108%;text-align: left;">This is done using the unary <span class="s31">* </span>operator and has been marked above in bold.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_173.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">reader@hacking:~/booksrc $ gcc pointer_types.c reader@hacking:~/booksrc $ ./a.out</p><p class="s31" style="padding-bottom: 3pt;padding-left: 91pt;text-indent: 0pt;line-height: 106%;text-align: left;">[integer pointer] points to 0xbffff7f0, which contains the integer 1 [integer pointer] points to 0xbffff7f4, which contains the integer 2 [integer pointer] points to 0xbffff7f8, which contains the integer 3 [integer pointer] points to 0xbffff7fc, which contains the integer 4 [integer pointer] points to 0xbffff800, which contains the integer 5 [char pointer] points to 0xbffff810, which contains the char &#39;a&#39; [char pointer] points to 0xbffff811, which contains the char &#39;b&#39; [char pointer] points to 0xbffff812, which contains the char &#39;c&#39; [char pointer] points to 0xbffff813, which contains the char &#39;d&#39; [char pointer] points to 0xbffff814, which contains the char &#39;e&#39; reader@hacking:~/booksrc $</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_174.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s40" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">pointer_types2.c</p><p style="padding-top: 4pt;padding-left: 3pt;text-indent: 17pt;line-height: 108%;text-align: left;">Even though the same value of 1 is added to <span class="s31">int_pointer </span>and <span class="s31">char_pointer </span>in their respective loops, the compiler increments the pointer’s addresses by different amounts. Since a char is only 1 byte, the pointer to the next char would naturally also be 1 byte over. But since an integer is 4 bytes, a pointer to the next integer has to be 4 bytes over.</p><p style="padding-left: 3pt;text-indent: 18pt;line-height: 108%;text-align: left;">In pointer_types2.c, the pointers are juxtaposed such that the <span class="s31">int_pointer </span>points to the character data and vice versa. The major changes to the code are marked in bold.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_175.png"/></span></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">#include &lt;stdio.h&gt;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 32pt;text-indent: -12pt;line-height: 107%;text-align: left;">int main() { int i;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;line-height: 107%;text-align: left;">char char_array[5] = {&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;}; int int_array[5] = {1, 2, 3, 4, 5};</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;text-align: left;">char *char_pointer; int *int_pointer;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s46" style="padding-left: 32pt;text-indent: 0pt;line-height: 107%;text-align: left;">char_pointer = int_array; // The char_pointer and int_pointer now int_pointer = char_array; // point to incompatible data types.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 44pt;text-indent: -12pt;line-height: 107%;text-align: left;">for(i=0; i &lt; 5; i++) { // Iterate through the int array with the int_pointer. printf(&quot;[integer pointer] points to %p, which contains the <b>char &#39;%c&#39;</b>\n&quot;,</p><p class="s31" style="padding-left: 44pt;text-indent: 25pt;text-align: left;">int_pointer, *int_pointer); int_pointer = int_pointer + 1;</p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;text-align: left;">}</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;text-align: left;">for(i=0; i &lt; 5; i++) { // Iterate through the char array with the char_pointer.</p><p class="s31" style="padding-top: 2pt;padding-left: 71pt;text-indent: -27pt;text-align: left;">printf(&quot;[char pointer] points to %p, which contains the <b>integer %d</b>\n&quot;, char_pointer, *char_pointer);</p><p class="s31" style="padding-left: 44pt;text-indent: 0pt;text-align: left;">char_pointer = char_pointer + 1;</p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;text-align: left;">}</p><p class="s31" style="padding-bottom: 3pt;padding-left: 19pt;text-indent: 0pt;text-align: left;">}</p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_176.png"/></span></p><p style="padding-top: 7pt;padding-left: 109pt;text-indent: 0pt;text-align: left;">The output below shows the warnings spewed forth from the compiler.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_177.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: justify;">reader@hacking:~/booksrc $ gcc pointer_types2.c pointer_types2.c: In function `main&#39;:</p><p class="s31" style="padding-bottom: 2pt;padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: justify;">pointer_types2.c:12: warning: assignment from incompatible pointer type pointer_types2.c:13: warning: assignment from incompatible pointer type reader@hacking:~/booksrc $</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_178.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: left;">In an attempt to prevent programming mistakes, the compiler gives warn- ings about pointers that point to incompatible data types. But the compiler and perhaps the programmer are the only ones that care about a pointer’s type. In the compiled code, a pointer is nothing more than a memory address, so the compiler will still compile the code if a pointer points to an incompatible data type—it simply warns the programmer to anticipate</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 11pt;text-align: left;">unexpected results.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_179.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">reader@hacking:~/booksrc $ ./a.out</p><p class="s31" style="padding-bottom: 2pt;padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">[integer pointer] points to 0xbffff810, which contains the char &#39;a&#39; [integer pointer] points to 0xbffff814, which contains the char &#39;e&#39; [integer pointer] points to 0xbffff818, which contains the char &#39;8&#39; [integer pointer] points to 0xbffff81c, which contains the char &#39; [integer pointer] points to 0xbffff820, which contains the char &#39;?&#39; [char pointer] points to 0xbffff7f0, which contains the integer 1 [char pointer] points to 0xbffff7f1, which contains the integer 0 [char pointer] points to 0xbffff7f2, which contains the integer 0 [char pointer] points to 0xbffff7f3, which contains the integer 0 [char pointer] points to 0xbffff7f4, which contains the integer 2 reader@hacking:~/booksrc $</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_180.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 18pt;line-height: 108%;text-align: left;">Even though the <span class="s31">int_pointer </span>points to character data that only contains 5 bytes of data, it is still typed as an integer. This means that adding 1 to the pointer will increment the address by 4 each time. Similarly, the <span class="s31">char_pointer</span>’s address is only incremented by 1 each time, stepping through the 20 bytes of integer data (five 4-byte integers), one byte at a time. Once again, the little- endian byte order of the integer data is apparent when the 4-byte integer is examined one byte at a time. The 4-byte value of <span class="s31">0x00000001 </span>is actually stored in memory as <span class="s31">0x01</span>, <span class="s31">0x00</span>, <span class="s31">0x00</span>, <span class="s31">0x00</span>.</p><p style="padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: left;">There will be situations like this in which you are using a pointer that points to data with a conflicting type. Since the pointer type determines the size of the data it points to, it’s important that the type is correct. As you can see in pointer_types3.c below, typecasting is just a way to change the type of a variable on the fly.</p><p class="s40" style="padding-top: 4pt;padding-left: 19pt;text-indent: 0pt;text-align: left;">pointer_types3.c</p><p style="text-indent: 0pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_181.png"/></span></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 21pt;text-align: left;">#include &lt;stdio.h&gt; int main() {</p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;line-height: 8pt;text-align: left;">int i;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;line-height: 107%;text-align: left;">char char_array[5] = {&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;}; int int_array[5] = {1, 2, 3, 4, 5};</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;text-align: left;">char *char_pointer; int *int_pointer;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;line-height: 107%;text-align: left;">char_pointer = (char *) int_array; // Typecast into the int_pointer = (int *) char_array; // pointer&#39;s data type.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 44pt;text-indent: -12pt;line-height: 107%;text-align: left;">for(i=0; i &lt; 5; i++) { // Iterate through the int array with the int_pointer. printf(&quot;[integer pointer] points to %p, which contains the char &#39;%c&#39;\n&quot;,</p><p class="s31" style="padding-left: 71pt;text-indent: 0pt;text-align: left;">int_pointer, *int_pointer);</p><p class="s46" style="padding-left: 44pt;text-indent: 0pt;text-align: left;">int_pointer = (int *) ((char *) int_pointer + 1);</p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;text-align: left;">}</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 44pt;text-indent: -12pt;text-align: left;">for(i=0; i &lt; 5; i++) { // Iterate through the char array with the char_pointer. printf(&quot;[char pointer] points to %p, which contains the integer %d\n&quot;,</p><p class="s31" style="padding-left: 71pt;text-indent: 0pt;text-align: left;">char_pointer, *char_pointer);</p><p class="s46" style="padding-left: 44pt;text-indent: 0pt;text-align: left;">char_pointer = (char *) ((int *) char_pointer + 1);</p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;text-align: left;">}</p><p class="s31" style="padding-bottom: 3pt;padding-left: 19pt;text-indent: 0pt;text-align: left;">}</p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_182.png"/></span></p><p style="padding-top: 7pt;padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: left;">In this code, when the pointers are initially set, the data is typecast into the pointer’s data type. This will prevent the C compiler from complaining about the conflicting data types; however, any pointer arithmetic will still be incorrect. To fix that, when 1 is added to the pointers, they must first be type- cast into the correct data type so the address is incremented by the correct amount. Then this pointer needs to be typecast back into the pointer’s data type once again. It doesn’t look too pretty, but it works.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_183.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">reader@hacking:~/booksrc $ gcc pointer_types3.c reader@hacking:~/booksrc $ ./a.out</p><p class="s31" style="padding-bottom: 2pt;padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">[integer pointer] points to 0xbffff810, which contains the char &#39;a&#39; [integer pointer] points to 0xbffff811, which contains the char &#39;b&#39; [integer pointer] points to 0xbffff812, which contains the char &#39;c&#39; [integer pointer] points to 0xbffff813, which contains the char &#39;d&#39; [integer pointer] points to 0xbffff814, which contains the char &#39;e&#39; [char pointer] points to 0xbffff7f0, which contains the integer 1 [char pointer] points to 0xbffff7f4, which contains the integer 2 [char pointer] points to 0xbffff7f8, which contains the integer 3 [char pointer] points to 0xbffff7fc, which contains the integer 4 [char pointer] points to 0xbffff800, which contains the integer 5 reader@hacking:~/booksrc $</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_184.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s40" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">pointer_types4.c</p><p style="padding-top: 3pt;padding-left: 3pt;text-indent: 17pt;line-height: 108%;text-align: left;">Naturally, it is far easier just to use the correct data type for pointers in the first place; however, sometimes a generic, typeless pointer is desired. In C, a void pointer is a typeless pointer, defined by the <span class="s31">void </span>keyword.</p><p style="padding-left: 3pt;text-indent: 0pt;line-height: 108%;text-align: left;">Experimenting with void pointers quickly reveals a few things about typeless pointers. First, pointers cannot be dereferenced unless they have a type.</p><p style="padding-left: 3pt;text-indent: 0pt;line-height: 108%;text-align: left;">In order to retrieve the value stored in the pointer’s memory address, the compiler must first know what type of data it is. Secondly, void pointers must also be typecast before doing pointer arithmetic. These are fairly intuitive limitations, which means that a void pointer’s main purpose is to simply hold a memory address.</p><p style="padding-left: 3pt;text-indent: 17pt;line-height: 108%;text-align: left;">The pointer_types3.c program can be modified to use a single void pointer by typecasting it to the proper type each time it’s used. The compiler knows that a void pointer is typeless, so any type of pointer can be stored in a void pointer without typecasting. This also means a void pointer must always be typecast when dereferencing it, however. These differences can be seen in pointer_types4.c, which uses a void pointer.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_185.png"/></span></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">#include &lt;stdio.h&gt;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 32pt;text-indent: -12pt;line-height: 107%;text-align: left;">int main() { int i;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;line-height: 107%;text-align: left;">char char_array[5] = {&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;}; int int_array[5] = {1, 2, 3, 4, 5};</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;text-align: left;">void *void_pointer;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;text-align: left;">void_pointer = (void *) char_array;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 44pt;text-indent: -12pt;line-height: 107%;text-align: left;">for(i=0; i &lt; 5; i++) { // Iterate through the int array with the int_pointer. printf(&quot;[char pointer] points to %p, which contains the char &#39;%c&#39;\n&quot;,</p><p class="s31" style="padding-left: 44pt;text-indent: 25pt;line-height: 107%;text-align: left;">void_pointer, *((char *) void_pointer)); void_pointer = (void *) ((char *) void_pointer + 1);</p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;line-height: 10pt;text-align: left;">}</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;text-align: left;">void_pointer = (void *) int_array;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 44pt;text-indent: -12pt;line-height: 107%;text-align: left;">for(i=0; i &lt; 5; i++) { // Iterate through the int array with the int_pointer. printf(&quot;[integer pointer] points to %p, which contains the integer %d\n&quot;,</p><p class="s31" style="padding-left: 44pt;text-indent: 25pt;line-height: 107%;text-align: left;">void_pointer, *((int *) void_pointer)); void_pointer = (void *) ((int *) void_pointer + 1);</p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;line-height: 10pt;text-align: left;">}</p><p class="s31" style="padding-bottom: 3pt;padding-left: 19pt;text-indent: 0pt;text-align: left;">}</p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_186.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: left;">The results of compiling and executing pointer_types4.c are as follows.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_187.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">reader@hacking:~/booksrc $ gcc pointer_types4.c reader@hacking:~/booksrc $ ./a.out</p><p class="s31" style="padding-bottom: 3pt;padding-left: 91pt;text-indent: 0pt;line-height: 106%;text-align: left;">[char pointer] points to 0xbffff810, which contains the char &#39;a&#39; [char pointer] points to 0xbffff811, which contains the char &#39;b&#39; [char pointer] points to 0xbffff812, which contains the char &#39;c&#39; [char pointer] points to 0xbffff813, which contains the char &#39;d&#39; [char pointer] points to 0xbffff814, which contains the char &#39;e&#39; [integer pointer] points to 0xbffff7f0, which contains the integer 1 [integer pointer] points to 0xbffff7f4, which contains the integer 2 [integer pointer] points to 0xbffff7f8, which contains the integer 3 [integer pointer] points to 0xbffff7fc, which contains the integer 4 [integer pointer] points to 0xbffff800, which contains the integer 5 reader@hacking:~/booksrc $</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_188.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s40" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">pointer_types5.c</p><p style="padding-top: 4pt;padding-left: 3pt;text-indent: 17pt;line-height: 108%;text-align: justify;">The compilation and output of this pointer_types4.c is basically the same as that for pointer_types3.c. The void pointer is really just holding the memory addresses, while the hard-coded typecasting is telling the compiler to use the proper types whenever the pointer is used.</p><p style="padding-left: 3pt;text-indent: 17pt;line-height: 108%;text-align: left;">Since the type is taken care of by the typecasts, the void pointer is truly nothing more than a memory address. With the data types defined by type- casting, anything that is big enough to hold a four-byte value can work the same way as a void pointer. In pointer_types5.c, an unsigned integer is used to store this address.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_189.png"/></span></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">#include &lt;stdio.h&gt;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 32pt;text-indent: -12pt;line-height: 107%;text-align: left;">int main() { int i;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;line-height: 107%;text-align: left;">char char_array[5] = {&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;}; int int_array[5] = {1, 2, 3, 4, 5};</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;line-height: 212%;text-align: left;">unsigned int hacky_nonpointer; hacky_nonpointer = (unsigned int) char_array;</p><p class="s31" style="padding-left: 44pt;text-indent: -12pt;text-align: left;">for(i=0; i &lt; 5; i++) { // Iterate through the int array with the int_pointer. printf(&quot;[hacky_nonpointer] points to %p, which contains the char &#39;%c&#39;\n&quot;,</p><p class="s31" style="padding-left: 71pt;text-indent: 0pt;text-align: left;">hacky_nonpointer, *((char *) hacky_nonpointer));</p><p class="s46" style="padding-left: 44pt;text-indent: 0pt;text-align: left;">hacky_nonpointer = hacky_nonpointer + sizeof(char);</p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;text-align: left;">}</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;text-align: left;">hacky_nonpointer = (unsigned int) int_array;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 44pt;text-indent: -12pt;text-align: left;">for(i=0; i &lt; 5; i++) { // Iterate through the int array with the int_pointer. printf(&quot;[hacky_nonpointer] points to %p, which contains the integer %d\n&quot;,</p><p class="s31" style="padding-left: 70pt;text-indent: 0pt;text-align: left;">hacky_nonpointer, *((int *) hacky_nonpointer));</p><p class="s46" style="padding-left: 44pt;text-indent: 0pt;text-align: left;">hacky_nonpointer = hacky_nonpointer + sizeof(int);</p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;text-align: left;">}</p><p class="s31" style="padding-bottom: 3pt;padding-left: 19pt;text-indent: 0pt;text-align: left;">}</p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_190.png"/></span></p><p style="padding-top: 3pt;padding-left: 91pt;text-indent: 18pt;line-height: 108%;text-align: left;">This is rather hacky, but since this integer value is typecast into the proper pointer types when it is assigned and dereferenced, the end result is the same. Notice that instead of typecasting multiple times to do pointer arithmetic on an unsigned integer (which isn’t even a pointer), the <span class="s31">sizeof() </span>function is used to achieve the same result using normal arithmetic.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_191.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">reader@hacking:~/booksrc $ gcc pointer_types5.c reader@hacking:~/booksrc $ ./a.out</p><p class="s31" style="padding-bottom: 3pt;padding-left: 91pt;text-indent: 0pt;line-height: 106%;text-align: left;">[hacky_nonpointer] points to 0xbffff810, which contains the char &#39;a&#39; [hacky_nonpointer] points to 0xbffff811, which contains the char &#39;b&#39; [hacky_nonpointer] points to 0xbffff812, which contains the char &#39;c&#39; [hacky_nonpointer] points to 0xbffff813, which contains the char &#39;d&#39; [hacky_nonpointer] points to 0xbffff814, which contains the char &#39;e&#39; [hacky_nonpointer] points to 0xbffff7f0, which contains the integer 1 [hacky_nonpointer] points to 0xbffff7f4, which contains the integer 2 [hacky_nonpointer] points to 0xbffff7f8, which contains the integer 3 [hacky_nonpointer] points to 0xbffff7fc, which contains the integer 4 [hacky_nonpointer] points to 0xbffff800, which contains the integer 5 reader@hacking:~/booksrc $</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_192.png"/></span></p><p style="padding-top: 7pt;padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: left;">The important thing to remember about variables in C is that the com- piler is the only thing that cares about a variable’s type. In the end, after the program has been compiled, the variables are nothing more than memory addresses. This means that variables of one type can easily be coerced into behaving like another type by telling the compiler to typecast them into the desired type.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part34.htm">&lt; Previous</a><span> | </span><a href="../hacking-the-art-of-exploitation.html">Contents</a><span> | </span><a href="part36.htm">Next &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
