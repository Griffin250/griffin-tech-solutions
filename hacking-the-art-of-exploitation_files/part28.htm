<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>0x252  The x86 Processor</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part27.htm">&lt; Previous</a><span> | </span><a href="../hacking-the-art-of-exploitation.html">Contents</a><span> | </span><a href="part29.htm">Next &gt;</a></p><p class="s32" style="padding-left: 91pt;text-indent: 0pt;text-align: justify;"><a name="bookmark18">0x252  The </a><span class="s43">x</span>86 Processor</p><p style="padding-top: 7pt;padding-left: 91pt;text-indent: 0pt;line-height: 106%;text-align: left;">The 8086 CPU was the first <span class="s27">x</span>86 processor. It was developed and manufactured by Intel, which later developed more advanced processors in the same family: the 80186, 80286, 80386, and 80486. If you remember people talking about 386 and 486 processors in the ’80s and ’90s, this is what they were referring to.</p><p style="padding-left: 91pt;text-indent: 17pt;line-height: 107%;text-align: left;">The <span class="s27">x</span>86 processor has several registers, which are like internal variables for the processor. I could just talk abstractly about these registers now, but I think it’s always better to see things for yourself. The GNU development tools also include a debugger called GDB. <span class="s27">Debuggers </span>are used by program- mers to step through compiled programs, examine program memory, and view processor registers. A programmer who has never used a debugger to look at the inner workings of a program is like a seventeenth-century doctor who has never used a microscope. Similar to a microscope, a debugger allows a hacker to observe the microscopic world of machine code—but a debugger is far more powerful than this metaphor allows. Unlike a microscope, a debugger can view the execution from all angles, pause it, and change anything along the way.</p><p style="padding-top: 3pt;padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: left;">Below, GDB is used to show the state of the processor registers right before the program starts.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_074.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">reader@hacking:~/booksrc $ gdb -q ./a.out</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">Using host libthread_db library &quot;/lib/tls/i686/cmov/libthread_db.so.1&quot;. (gdb) break main</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">Breakpoint 1 at 0x804837a (gdb) run</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">Starting program: /home/reader/booksrc/a.out</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">Breakpoint 1, 0x0804837a in main () (gdb) info registers</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">eax      0xbffff894    -1073743724</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">ecx      0x48e0fe81    1222704769</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">edx      0x1   1</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">ebx      0xb7fd6ff4    -1208127500</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">esp      0xbffff800    0xbffff800</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">ebp       0xbffff808    0xbffff808</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">esi     0xb8000ce0   -1207956256</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">edi      0x0   0</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">eip      0x804837a    0x804837a &lt;main+6&gt;</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">eflags    0x286  [ PF SF IF ]</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">cs       0x73   115</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">ss       0x7b   123</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">ds       0x7b   123</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">es       0x7b   123</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">fs       0x0   0</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">gs       0x33   51</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">(gdb) quit</p><p class="s31" style="padding-bottom: 2pt;padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">The program is running. Exit anyway? (y or n) y reader@hacking:~/booksrc $</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_075.png"/></span></p><p style="padding-top: 7pt;padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: left;">A breakpoint is set on the <span class="s31">main() </span>function so execution will stop right before our code is executed. Then GDB runs the program, stops at the breakpoint, and is told to display all the processor registers and their current states.</p><p style="padding-left: 91pt;text-indent: 17pt;text-align: left;">The first four registers (<span class="s27">EAX</span>, <span class="s27">ECX</span>, <span class="s27">EDX</span>, and <span class="s27">EBX </span>) are known as general- purpose registers. These are called the <span class="s27">Accumulator</span>, <span class="s27">Counter</span>, <span class="s27">Data</span>, and <span class="s27">Base </span>registers, respectively. They are used for a variety of purposes, but they mainly act as temporary variables for the CPU when it is executing machine instructions.</p><p style="padding-left: 91pt;text-indent: 17pt;line-height: 106%;text-align: left;">The second four registers (<span class="s27">ESP</span>, <span class="s27">EBP</span>, <span class="s27">ESI</span>, and <span class="s27">EDI </span>) are also general- purpose registers, but they are sometimes known as pointers and indexes. These stand for <span class="s27">Stack Pointer</span>, <span class="s27">Base Pointer</span>, <span class="s27">Source Index</span>, and <span class="s27">Destination Index</span>, respectively. The first two registers are called pointers because they store 32-bit addresses, which essentially point to that location in memory. These registers are fairly important to program execution and memory management; we will discuss them more later. The last two registers are also technically pointers,</p><p style="padding-top: 3pt;padding-left: 91pt;text-indent: 0pt;line-height: 108%;text-align: left;">which are commonly used to point to the source and destination when data needs to be read from or written to. There are load and store instructions that use these registers, but for the most part, these registers can be thought of as just simple general-purpose registers.</p><p style="padding-left: 91pt;text-indent: 17pt;line-height: 107%;text-align: left;">The <span class="s27">EIP </span>register is the <span class="s27">Instruction Pointer </span>register, which points to the current instruction the processor is reading. Like a child pointing his finger at each word as he reads, the processor reads each instruction using the EIP register as its finger. Naturally, this register is quite important and will be used a lot while debugging. Currently, it points to a memory address at <span class="s31">0x804838a</span>.</p><p style="padding-left: 91pt;text-indent: 17pt;line-height: 106%;text-align: left;">The remaining <span class="s27">EFLAGS </span>register actually consists of several bit flags that are used for comparisons and memory segmentations. The actual memory is split into several different segments, which will be discussed later, and these registers keep track of that. For the most part, these registers can be ignored since they rarely need to be accessed directly.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part27.htm">&lt; Previous</a><span> | </span><a href="../hacking-the-art-of-exploitation.html">Contents</a><span> | </span><a href="part29.htm">Next &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
