<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>0x442 libpcap Sniffer</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part88.htm">&lt; Previous</a><span> | </span><a href="../hacking-the-art-of-exploitation.html">Contents</a><span> | </span><a href="part90.htm">Next &gt;</a></p><p class="s32" style="padding-top: 4pt;padding-left: 91pt;text-indent: 0pt;text-align: left;"><a name="bookmark78">0x442 libpcap Sniffer</a></p><p style="padding-top: 8pt;padding-left: 91pt;text-indent: 0pt;line-height: 108%;text-align: left;">A standardized programming library called libpcap can be used to smooth out the inconsistencies of raw sockets. The functions in this library still use raw sockets to do their magic, but the library knows how to correctly work with raw sockets on multiple architectures. Both tcpdump and dsniff use libpcap, which allows them to compile with relative ease on any platform. Let’s rewrite the raw packet sniffer program using the libpcap’s functions instead of our own. These functions are quite intuitive, so we will discuss them using the following code listing.</p><p class="s40" style="padding-top: 9pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">pcap_sniff.c</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_685.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">#include &lt;pcap.h&gt; #include &quot;hacking.h&quot;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 104pt;text-indent: -12pt;line-height: 107%;text-align: left;">void pcap_fatal(const char *failed_in, const char *errbuf) { printf(&quot;Fatal Error in %s: %s\n&quot;, failed_in, errbuf); exit(1);</p><p class="s31" style="padding-bottom: 3pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">}</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_686.png"/></span></p><p style="padding-top: 7pt;padding-left: 91pt;text-indent: 18pt;line-height: 108%;text-align: left;">First, pcap.h is included providing various structures and defines used by the pcap functions. Also, I’ve written a <span class="s31">pcap_fatal() </span>function for displaying fatal errors. The pcap functions use a error buffer to return error and status messages, so this function is designed to display this buffer to the user.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_687.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">int main() {</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;text-align: left;">struct pcap_pkthdr header; const u_char *packet;</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;line-height: 107%;text-align: left;">char errbuf[PCAP_ERRBUF_SIZE]; char *device;</p><p class="s31" style="padding-bottom: 3pt;padding-left: 104pt;text-indent: 0pt;text-align: left;">pcap_t *pcap_handle; int i;</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_688.png"/></span></p><p style="padding-top: 7pt;padding-left: 91pt;text-indent: 18pt;line-height: 108%;text-align: left;">The <span class="s31">errbuf </span>variable is the aforementioned error buffer, its size coming from a define in pcap.h set to <span class="s31">256</span>. The header variable is a <span class="s31">pcap_pkthdr </span>structure containing extra capture information about the packet, such as when it was captured and its length. The <span class="s31">pcap_handle </span>pointer works similarly to a file descriptor, but is used to reference a packet-capturing object.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_689.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">device = pcap_lookupdev(errbuf); if(device == NULL)</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;text-align: left;">pcap_fatal(&quot;pcap_lookupdev&quot;, errbuf);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-top: 4pt;padding-bottom: 3pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">printf(&quot;Sniffing on device %s\n&quot;, device);</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_690.png"/></span></p><p style="padding-top: 7pt;padding-left: 91pt;text-indent: 18pt;line-height: 108%;text-align: justify;">The <span class="s31">pcap_lookupdev() </span>function looks for a suitable device to sniff on. This device is returned as a string pointer referencing static function memory. For our system this will always be <span class="s31">/dev/eth0</span>, although it will be different on a BSD system. If the function can’t find a suitable interface, it will return <span class="s31">NULL</span>.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_691.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">pcap_handle = pcap_open_live(device, 4096, 1, 0, errbuf); if(pcap_handle == NULL)</p><p class="s31" style="padding-bottom: 3pt;padding-left: 104pt;text-indent: 0pt;text-align: left;">pcap_fatal(&quot;pcap_open_live&quot;, errbuf);</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_692.png"/></span></p><p style="padding-top: 7pt;padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: left;">Similar to the socket function and file open function, the <span class="s31">pcap_open_live() </span>function opens a packet-capturing device, returning a handle to it. The argu- ments for this function are the device to sniff, the maximum packet size, a promiscuous flag, a timeout value, and a pointer to the error buffer. Since we want to capture in promiscuous mode, the promiscuous flag is set to <span class="s31">1</span>.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_693.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">for(i=0; i &lt; 3; i++) {</p><p class="s31" style="padding-left: 116pt;text-indent: 0pt;line-height: 106%;text-align: left;">packet = pcap_next(pcap_handle, &amp;header); printf(&quot;Got a %d byte packet\n&quot;, header.len); dump(packet, header.len);</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;text-align: left;">}</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;text-align: left;">pcap_close(pcap_handle);</p><p class="s31" style="padding-bottom: 3pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">}</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_694.png"/></span></p><p style="padding-top: 7pt;padding-left: 91pt;text-indent: 18pt;line-height: 108%;text-align: justify;">Finally, the packet capture loop uses <span class="s31">pcap_next() </span>to grab the next packet. This function is passed the <span class="s31">pcap_handle </span>and a pointer to a <span class="s31">pcap_pkthdr </span>struc- ture so it can fill it with details of the capture. The function returns a pointer to the packet and then prints the packet, getting the length from the capture header. Then <span class="s31">pcap_close() </span>closes the capture interface.</p><p style="padding-left: 91pt;text-indent: 18pt;line-height: 108%;text-align: left;">When this program is compiled, the pcap libraries must be linked. This can be done using the <span class="s31">-l </span>flag with GCC, as shown in the output below. The pcap library has been installed on this system, so the library and include files are already in standard locations the compiler knows about.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_695.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">reader@hacking:~/booksrc $ gcc -o pcap_sniff pcap_sniff.c</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">/tmp/ccYgieqx.o: In function `main&#39;:</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 106%;text-align: left;">pcap_sniff.c:(.text+0x1c8): undefined reference to `pcap_lookupdev&#39; pcap_sniff.c:(.text+0x233): undefined reference to `pcap_open_live&#39; pcap_sniff.c:(.text+0x282): undefined reference to `pcap_next&#39; pcap_sniff.c:(.text+0x2c2): undefined reference to `pcap_close&#39; collect2: ld returned 1 exit status</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">reader@hacking:~/booksrc $ gcc -o pcap_sniff pcap_sniff.c -l pcap reader@hacking:~/booksrc $ ./pcap_sniff</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">Fatal Error in pcap_lookupdev: no suitable device found reader@hacking:~/booksrc $ sudo ./pcap_sniff</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">Sniffing on device eth0 Got a 82 byte packet</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">00 01 6c eb 1d 50 00 01 29 15 65 b6 08 00 45 10 | ..l..P..).e...E.</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">00 44 1e 39 40 00 40 06 46 20 c0 a8 2a 01 c0 a8 | .D.9@.@.F ..*...</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">2a f9 8b 12 1e d2 ac 14 cf c7 e5 10 6c c9 80 18 | *...........l...</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">05 b4 54 1a 00 00 01 01 08 0a 26 b6 a7 76 02 3c | ..T.   &amp;..v.&lt;</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">37 1e 74 68 69 73 20 69 73 20 61 20 74 65 73 74 | 7.this is a test</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">0d 0a                       | ..</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">Got a 66 byte packet</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">00 01 29 15 65 b6 00 01 6c eb 1d 50 08 00 45 00 | ..).e...l..P..E.</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">00 34 3d 2c 40 00 40 06 27 4d c0 a8 2a f9 c0 a8 | .4=,@.@.&#39;M..*...</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">2a 01 1e d2 8b 12 e5 10 6c c9 ac 14 cf d7 80 10 | *.......l.......</p><p class="s31" style="padding-top: 2pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">05 a8 2b 3f 00 00 01 01 08 0a 02 47 27 6c 26 b6 | ..+?    G&#39;l&amp;.</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">a7 76                       | .v</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">Got a 84 byte packet</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">00 01 6c eb 1d 50 00 01 29 15 65 b6 08 00 45 10 | ..l..P..).e. E.</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">00 46 1e 3a 40 00 40 06 46 1d c0 a8 2a 01 c0 a8 | .F.:@.@.F...*...</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">2a f9 8b 12 1e d2 ac 14 cf d7 e5 10 6c c9 80 18 | *...........l...</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">05 b4 11 b3 00 00 01 01 08 0a 26 b6 a9 c8 02 47 | ..........&amp;.  G</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">27 6c 41 41 41 41 41 41 41 41 41 41 41 41 41 41 | &#39;lAAAAAAAAAAAAAA</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">41 41 0d 0a                   | AA..</p><p class="s31" style="padding-bottom: 3pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">reader@hacking:~/booksrc $</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_696.png"/></span></p><p style="padding-top: 6pt;padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: justify;">Notice that there are many bytes preceding the sample text in the packet and many of these bytes are similar. Since these are raw packet captures, most of these bytes are layers of header information for Ethernet, IP, and TCP.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part88.htm">&lt; Previous</a><span> | </span><a href="../hacking-the-art-of-exploitation.html">Contents</a><span> | </span><a href="part90.htm">Next &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
