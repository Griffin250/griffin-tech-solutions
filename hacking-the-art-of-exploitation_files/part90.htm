<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>0x443 Decoding the Layers</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part89.htm">&lt; Previous</a><span> | </span><a href="../hacking-the-art-of-exploitation.html">Contents</a><span> | </span><a href="part91.htm">Next &gt;</a></p><p class="s32" style="padding-left: 91pt;text-indent: 0pt;text-align: left;"><a name="bookmark79">0x443 Decoding the Layers</a></p><p style="padding-top: 8pt;padding-left: 91pt;text-indent: 0pt;line-height: 108%;text-align: left;">In our packet captures, the outermost layer is Ethernet, which is also the lowest visible layer. This layer is used to send data between Ethernet end- points with MAC addresses. The header for this layer contains the source MAC address, the destination MAC address, and a 16-bit value that describes the type of Ethernet packet. On Linux, the structure for this header is defined in /usr/include/linux/if_ethernet.h and the structures for the IP header and TCP header are located in /usr/include/netinet/ip.h and /usr/include/ netinet/tcp.h, respectively. The source code for tcpdump also has structures for these headers, or we could just create our own header structures based on the RFCs. A better understanding can be gained from writing our own structures, so let’s use the structure definitions as guidance to create our own packet header structures to include in hacking-network.h.</p><p style="padding-left: 109pt;text-indent: 0pt;line-height: 11pt;text-align: left;">First, let’s look at the existing definition of the Ethernet header.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s40" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">From /usr/include/if_ether.h</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_697.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">#define ETH_ALEN 6  /* Octets in one ethernet addr  */ #define ETH_HLEN 14  /* Total octets in header */</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">/*</p><p class="s31" style="padding-left: 95pt;text-indent: 0pt;text-align: left;">* This is an Ethernet frame header.</p><p class="s31" style="padding-left: 95pt;text-indent: 0pt;text-align: left;">*/</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">struct ethhdr {</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;text-align: left;">unsigned char h_dest[ETH_ALEN]; /* Destination eth addr */ unsigned char h_source[ETH_ALEN]; /* Source ether addr */</p><p class="s67" style="padding-left: 99pt;text-indent: 0pt;text-align: left;"> <span class="s31">be16  h_proto;  /* Packet type ID field */</span></p><p class="s31" style="padding-bottom: 3pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">} <u>&nbsp;</u>attribute<u> </u>((packed));</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_698.png"/></span></p><p style="padding-top: 7pt;padding-left: 91pt;text-indent: 18pt;line-height: 108%;text-align: justify;">This structure contains the three elements of an Ethernet header. The variable declaration of <span class="s67">&nbsp; </span><span class="s31">be16 </span>turns out to be a type definition for a 16-bit unsigned short integer. This can be determined by recursively grepping for the type definition in the include files.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_699.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">reader@hacking:~/booksrc $</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">$ grep -R &quot;typedef.*<u> </u>be16&quot; /usr/include</p><p class="s46" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">/usr/include/linux/types.h:typedef <u>&nbsp;</u>u16 <u>&nbsp;</u>bitwise <u>&nbsp;</u>be16;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">$ grep -R &quot;typedef.*<u> </u>u16&quot; /usr/include | grep short</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">/usr/include/linux/i2o-dev.h:typedef unsigned short <u>&nbsp;</u>u16;</p><p class="s46" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">/usr/include/linux/cramfs_fs.h:typedef unsigned short <u>&nbsp;</u>u16;</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">/usr/include/asm/types.h:typedef unsigned short <u>&nbsp;</u>u16;</p><p class="s31" style="padding-bottom: 3pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">$</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_700.png"/></span></p><p style="padding-top: 7pt;padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: left;">The include file also defines the Ethernet header length in <span class="s31">ETH_HLEN </span>as 14 bytes. This adds up, since the source and destination MAC addresses use 6 bytes each, and the packet type field is a 16-bit short integer that takes up 2 bytes. However, many compilers will pad structures along 4-byte boundaries for alignment, which means that <span class="s31">sizeof(struct ethhdr) </span>would return an incorrect size. To avoid this, <span class="s31">ETH_HLEN </span>or a fixed value of 14 bytes should</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 11pt;text-align: left;">be used for the Ethernet header length.</p><p style="padding-left: 91pt;text-indent: 18pt;line-height: 108%;text-align: left;">By including <span class="s31">&lt;linux/if_ether.h&gt;</span>, these other include files containing the required <span class="s67">&nbsp; </span><span class="s31">be16 </span>type definition are also included. Since we want to make our own structures for hacking-network.h, we should strip out references to unknown type definitions. While we’re at it, let’s give these fields better names.</p><p class="s40" style="padding-top: 9pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">Added to hacking-network.h</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_701.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">#define ETHER_ADDR_LEN 6</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">#define ETHER_HDR_LEN 14</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">struct ether_hdr {</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;line-height: 106%;text-align: left;">unsigned char ether_dest_addr[ETHER_ADDR_LEN]; // Destination MAC address unsigned char ether_src_addr[ETHER_ADDR_LEN]; // Source MAC address unsigned short ether_type; // Type of Ethernet packet</p><p class="s31" style="padding-bottom: 3pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">};</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_702.png"/></span></p><p style="padding-top: 6pt;padding-left: 91pt;text-indent: 17pt;text-align: left;">We can do the same thing with the IP and TCP structures, using the corresponding structures and RFC diagrams as a reference.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s40" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">From /usr/include/netinet/ip.h</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_703.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">struct iphdr</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;text-align: left;">{</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">#if <u>&nbsp;</u>BYTE_ORDER == <u>&nbsp;</u>LITTLE_ENDIAN</p><p class="s31" style="padding-left: 108pt;text-indent: 0pt;line-height: 107%;text-align: left;">unsigned int ihl:4; unsigned int version:4;</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">#elif <u>&nbsp;</u>BYTE_ORDER == <u>&nbsp;</u>BIG_ENDIAN</p><p class="s31" style="padding-left: 108pt;text-indent: 0pt;line-height: 107%;text-align: left;">unsigned int version:4; unsigned int ihl:4;</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">#else</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;"># error &quot;Please fix &lt;bits/endian.h&gt;&quot; #endif</p><p class="s31" style="padding-left: 108pt;text-indent: 0pt;line-height: 107%;text-align: left;">u_int8_t tos; u_int16_t tot_len; u_int16_t id;</p><p class="s31" style="padding-top: 2pt;padding-left: 108pt;text-indent: 0pt;line-height: 106%;text-align: left;">u_int16_t frag_off; u_int8_t ttl; u_int8_t protocol; u_int16_t check; u_int32_t saddr; u_int32_t daddr;</p><p class="s31" style="padding-left: 108pt;text-indent: 0pt;text-align: left;">/*The options start here. */</p><p class="s31" style="padding-bottom: 3pt;padding-left: 99pt;text-indent: 0pt;text-align: left;">};</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_704.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s40" style="padding-top: 5pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">From RFC 791</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_705.png"/></span></p><p class="s31" style="padding-left: 108pt;text-indent: 0pt;text-align: left;">0          1          2          3</p><p class="s31" style="padding-left: 108pt;text-indent: 0pt;text-align: left;">0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;text-align: left;">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;text-align: left;">|Version|  IHL  |Type of Service|      Total Length     |</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;text-align: left;">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;text-align: left;">|     Identification     |Flags|    Fragment Offset  |</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;text-align: left;">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;text-align: left;">| Time to Live |  Protocol  |     Header Checksum    |</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;text-align: left;">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;text-align: left;">|            Source Address              |</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;text-align: left;">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;text-align: left;">|           Destination Address             |</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;text-align: left;">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;text-align: left;">|           Options           |   Padding   |</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;text-align: left;">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-top: 4pt;padding-bottom: 3pt;padding-left: 176pt;text-indent: 0pt;text-align: left;">Example Internet Datagram Header</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_706.png"/></span></p><p style="padding-top: 8pt;padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: left;">Each element in the structure corresponds to the fields shown in the RFC header diagram. Since the first two fields, Version and IHL (Internet Header Length) are only four bits in size and there aren’t any 4-bit variable types in C, the Linux header definition splits the byte differently depending on the byte order of the host. These fields are in the network byte order, so, if the host is little-endian, the IHL should come before Version since the byte order is reversed. For our purposes, we won’t really be using either of these fields, so we don’t even need to split up the byte.</p><p class="s40" style="padding-top: 9pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">Added to hacking-network.h</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_707.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">struct ip_hdr {</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;line-height: 107%;text-align: left;">unsigned char ip_version_and_header_length; // Version and header length unsigned char ip_tos;      // Type of service</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;text-align: left;">unsigned short ip_len;     // Total length</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;line-height: 107%;text-align: left;">unsigned short ip_id;     // Identification number unsigned short ip_frag_offset; // Fragment offset and flags unsigned char ip_ttl;     // Time to live</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;text-align: left;">unsigned char ip_type;     // Protocol type unsigned short ip_checksum;  // Checksum</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;line-height: 107%;text-align: left;">unsigned int ip_src_addr;   // Source IP address unsigned int ip_dest_addr;   // Destination IP address</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">};</p><p style="padding-top: 3pt;padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: justify;">The compiler padding, as mentioned earlier, will align this structure on a 4-byte boundary by padding the rest of the structure. IP headers are always 20 bytes.</p><p style="padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: justify;">For the TCP packet header, we reference /usr/include/netinet/tcp.h for the structure and RFC 793 for the header diagram.</p><p class="s40" style="padding-top: 9pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">From /usr/include/netinet/tcp.h</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_708.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">typedef u_int32_t tcp_seq;</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">/*</p><p class="s31" style="padding-left: 95pt;text-indent: 0pt;text-align: left;">* TCP header.</p><p class="s31" style="padding-left: 95pt;text-indent: 0pt;text-align: left;">* Per RFC 793, September, 1981.</p><p class="s31" style="padding-left: 95pt;text-indent: 0pt;text-align: left;">*/</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">struct tcphdr</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;text-align: left;">{</p><p class="s31" style="padding-left: 108pt;text-indent: 0pt;line-height: 106%;text-align: left;">u_int16_t th_sport;  /* source port */ u_int16_t th_dport;  /* destination port */ tcp_seq th_seq;  /* sequence number */ tcp_seq th_ack;  /* acknowledgment number */</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: justify;"># if <u>&nbsp;</u>BYTE_ORDER == <u>&nbsp;</u>LITTLE_ENDIAN</p><p class="s31" style="padding-left: 108pt;text-indent: 0pt;line-height: 107%;text-align: left;">u_int8_t th_x2:4;  /* (unused) */ u_int8_t th_off:4;   /* data offset */</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: justify;"># endif</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: justify;"># if <u>&nbsp;</u>BYTE_ORDER == <u>&nbsp;</u>BIG_ENDIAN</p><p class="s31" style="padding-left: 108pt;text-indent: 0pt;line-height: 107%;text-align: justify;">u_int8_t th_off:4;   /* data offset */ u_int8_t th_x2:4;  /* (unused) */</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: justify;"># endif</p><p class="s31" style="padding-left: 91pt;text-indent: 17pt;line-height: 106%;text-align: justify;">u_int8_t th_flags; # define TH_FIN 0x01 # define TH_SYN 0x02 # define TH_RST 0x04 # define TH_PUSH 0x08 # define TH_ACK 0x10 # define TH_URG 0x20</p><p class="s31" style="padding-left: 108pt;text-indent: 0pt;line-height: 106%;text-align: left;">u_int16_t th_win;  /* window */ u_int16_t th_sum;  /* checksum */ u_int16_t th_urp;  /* urgent pointer */</p><p class="s31" style="padding-bottom: 3pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">};</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_709.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s40" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">From RFC 793</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_710.png"/></span></p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;text-align: left;">TCP Header Format</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 108pt;text-indent: 0pt;text-align: left;">0          1          2          3</p><p class="s31" style="padding-left: 108pt;text-indent: 0pt;text-align: left;">0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;text-align: left;">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;text-align: left;">|      Source Port      |    Destination Port     |</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;text-align: left;">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;text-align: left;">|            Sequence Number            |</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;text-align: left;">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;text-align: left;">|          Acknowledgment Number           |</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;text-align: left;">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</p><table style="border-collapse:collapse;margin-left:101.657pt" cellspacing="0"><tr style="height:10pt"><td style="width:83pt"><p class="s42" style="padding-left: 2pt;text-indent: 0pt;line-height: 9pt;text-align: left;">| Data |</p></td><td style="width:85pt"><p class="s42" style="padding-left: 4pt;text-indent: 0pt;line-height: 9pt;text-align: left;">|U|A|P|R|S|F|</p></td><td style="width:79pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td><td style="width:34pt"><p class="s42" style="padding-right: 2pt;text-indent: 0pt;line-height: 9pt;text-align: right;">|</p></td></tr><tr style="height:11pt"><td style="width:83pt"><p class="s42" style="padding-left: 2pt;text-indent: 0pt;line-height: 9pt;text-align: left;">| Offset| Reserved</p></td><td style="width:85pt"><p class="s42" style="padding-left: 4pt;text-indent: 0pt;line-height: 9pt;text-align: left;">|R|C|S|S|Y|I|</p></td><td style="width:79pt"><p class="s42" style="padding-left: 25pt;text-indent: 0pt;line-height: 9pt;text-align: left;">Window</p></td><td style="width:34pt"><p class="s42" style="padding-right: 2pt;text-indent: 0pt;line-height: 9pt;text-align: right;">|</p></td></tr><tr style="height:10pt"><td style="width:83pt"><p class="s42" style="padding-left: 2pt;text-indent: 0pt;line-height: 9pt;text-align: left;">|   |</p></td><td style="width:85pt"><p class="s42" style="padding-left: 4pt;text-indent: 0pt;line-height: 9pt;text-align: left;">|G|K|H|T|N|N|</p></td><td style="width:79pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td><td style="width:34pt"><p class="s42" style="padding-right: 2pt;text-indent: 0pt;line-height: 9pt;text-align: right;">|</p></td></tr></table><p class="s31" style="padding-left: 104pt;text-indent: 0pt;text-align: left;">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;text-align: left;">|      Checksum      |     Urgent Pointer    |</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;text-align: left;">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;text-align: left;">|           Options           |   Padding   |</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;text-align: left;">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;text-align: left;">|                data                |</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;text-align: left;">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: justify;">Data Offset: 4 bits</p><p class="s31" style="padding-left: 108pt;text-indent: 0pt;text-align: justify;">The number of 32 bit words in the TCP Header. This indicates where the data begins. The TCP header (even one including options) is an integral number of 32 bits long.</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 10pt;text-align: justify;">Reserved: 6 bits</p><p class="s31" style="padding-left: 108pt;text-indent: 0pt;text-align: justify;">Reserved for future use. Must be zero.</p><p class="s31" style="padding-bottom: 3pt;padding-left: 91pt;text-indent: 0pt;text-align: justify;">Options: variable</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_711.png"/></span></p><p style="padding-top: 7pt;padding-left: 91pt;text-indent: 18pt;line-height: 108%;text-align: left;">Linux’s <span class="s31">tcphdr </span>structure also switches the ordering of the 4-bit data offset field and the 4-bit section of the reserved field depending on the host’s byte order. The data offset field is important, since it tells the size of the variable- length TCP header. You might have noticed that Linux’s <span class="s31">tcphdr </span>structure doesn’t save any space for TCP options. This is because the RFC defines this field as optional. The size of the TCP header will always be 32-bit-aligned, and the data offset tells us how many 32-bit words are in the header. So the TCP header size in bytes equals the data offset field from the header times four. Since the data offset field is required to calculate the header size, we’ll split the byte containing it, assuming little-endian host byte ordering.</p><p style="padding-left: 91pt;text-indent: 18pt;line-height: 108%;text-align: justify;">The <span class="s31">th_flags </span>field of Linux’s <span class="s31">tcphdr </span>structure is defined as an 8-bit unsigned character. The values defined below this field are the bitmasks that correspond to the six possible flags.</p><p class="s40" style="padding-top: 9pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">Added to hacking-network.h</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_712.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">struct tcp_hdr {</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;text-align: left;">unsigned short tcp_src_port;  // Source TCP port unsigned short tcp_dest_port;  // Destination TCP port unsigned int tcp_seq;      // TCP sequence number</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;text-align: left;">unsigned int tcp_ack;    // TCP acknowledgment number</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;text-align: left;">unsigned char reserved:4;   // 4 bits from the 6 bits of reserved space unsigned char tcp_offset:4;  // TCP data offset for little-endian host unsigned char tcp_flags;   // TCP flags (and 2 bits from reserved space)</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: justify;">#define TCP_FIN  0x01 #define TCP_SYN  0x02 #define TCP_RST  0x04 #define TCP_PUSH 0x08 #define TCP_ACK  0x10 #define TCP_URG  0x20</p><p class="s31" style="padding-left: 99pt;text-indent: 0pt;text-align: left;">unsigned short tcp_window;   // TCP window size unsigned short tcp_checksum;  // TCP checksum unsigned short tcp_urgent;   // TCP urgent pointer</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">};</p><p style="padding-top: 3pt;padding-left: 91pt;text-indent: 18pt;line-height: 108%;text-align: left;">Now that the headers are defined as structures, we can write a program to decode the layered headers of each packet. But before we do, let’s talk about libpcap for a moment. This library has a function called <span class="s31">pcap_loop()</span>, which is a better way to capture packets than just looping on a <span class="s31">pcap_next() </span>call. Very few programs actually use <span class="s31">pcap_next()</span>, because it’s clumsy and inefficient. The <span class="s31">pcap_loop() </span>function uses a callback function. This means the <span class="s31">pcap_loop() </span>function is passed a function pointer, which is called every time a packet is captured. The prototype for <span class="s31">pcap_loop() </span>is as follows:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_713.png"/></span></p><p class="s31" style="padding-bottom: 3pt;padding-left: 19pt;text-indent: 0pt;text-align: left;">int pcap_loop(pcap_t *handle, int count, pcap_handler callback, u_char *args);</p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_714.png"/></span></p><p style="padding-top: 7pt;padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: left;">The first argument is the pcap’s handle, the next one is a count of how many packets to capture, and the third is a function pointer to the callback function. If the count argument is set to <span class="s31">-1</span>, it will loop until the program breaks out of it. The final argument is an optional pointer that will get passed to the callback function. Naturally, the callback function needs to follow a certain prototype, since <span class="s31">pcap_loop() </span>must call this function. The callback function can be named whatever you like, but the arguments must be as follows:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_715.png"/></span></p><p class="s31" style="padding-bottom: 3pt;padding-left: 19pt;text-indent: 0pt;text-align: left;">void callback(u_char *args, const struct pcap_pkthdr *cap_header, const u_char *packet);</p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_716.png"/></span></p><p style="padding-top: 6pt;padding-left: 91pt;text-indent: 18pt;line-height: 108%;text-align: left;">The first argument is just the optional argument pointer from the last argument to <span class="s31">pcap_loop()</span>. It can be used to pass additional information to the callback function, but we aren’t going to be using this. The next two arguments should be familiar from <span class="s31">pcap_next()</span>: a pointer to the capture header and a pointer to the packet itself.</p><p style="padding-left: 91pt;text-indent: 18pt;line-height: 108%;text-align: justify;">The following example code uses <span class="s31">pcap_loop() </span>with a callback function to capture packets and our header structures to decode them. This program will be explained as the code is listed.</p><p class="s40" style="padding-top: 9pt;padding-left: 19pt;text-indent: 0pt;text-align: left;">decode_sniff.c</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_717.png"/></span></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">#include &lt;pcap.h&gt; #include &quot;hacking.h&quot;</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">#include &quot;hacking-network.h&quot;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">void pcap_fatal(const char *, const char *); void decode_ethernet(const u_char *);</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">void decode_ip(const u_char *); u_int decode_tcp(const u_char *);</p><p class="s31" style="padding-top: 1pt;padding-left: 19pt;text-indent: 0pt;line-height: 21pt;text-align: left;">void caught_packet(u_char *, const struct pcap_pkthdr *, const u_char *); int main() {</p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;line-height: 8pt;text-align: left;">struct pcap_pkthdr cap_header;</p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;line-height: 107%;text-align: left;">const u_char *packet, *pkt_data; char errbuf[PCAP_ERRBUF_SIZE]; char *device;</p><p class="s31" style="padding-top: 2pt;padding-left: 32pt;text-indent: 0pt;text-align: left;">pcap_t *pcap_handle;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;line-height: 107%;text-align: left;">device = pcap_lookupdev(errbuf); if(device == NULL)</p><p class="s31" style="padding-left: 32pt;text-indent: 12pt;line-height: 212%;text-align: left;">pcap_fatal(&quot;pcap_lookupdev&quot;, errbuf); printf(&quot;Sniffing on device %s\n&quot;, device);</p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;text-align: left;">pcap_handle = pcap_open_live(device, 4096, 1, 0, errbuf); if(pcap_handle == NULL)</p><p class="s31" style="padding-left: 32pt;text-indent: 12pt;line-height: 214%;text-align: left;">pcap_fatal(&quot;pcap_open_live&quot;, errbuf); pcap_loop(pcap_handle, 3, caught_packet, NULL);</p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;line-height: 10pt;text-align: left;">pcap_close(pcap_handle);</p><p class="s31" style="padding-bottom: 3pt;padding-left: 19pt;text-indent: 0pt;text-align: left;">}</p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_718.png"/></span></p><p style="padding-top: 6pt;padding-left: 91pt;text-indent: 18pt;line-height: 108%;text-align: left;">At the beginning of this program, the prototype for the callback func- tion, called <span class="s31">caught_packet()</span>, is declared along with several decoding functions. Everything else in <span class="s31">main() </span>is basically the same, except that the for loop has been replaced with a single call to <span class="s31">pcap_loop()</span>. This function is passed the <span class="s31">pcap_handle</span>, told to capture three packets, and pointed to the callback func- tion, <span class="s31">caught_packet()</span>. The final argument is <span class="s31">NULL</span>, since we don’t have any addi- tional data to pass along to <span class="s31">caught_packet()</span>. Also, notice that the <span class="s31">decode_tcp() </span>function returns a u_int. Since the TCP header length is variable, this function returns the length of the TCP header.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_719.png"/></span></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 10pt;text-align: left;">void caught_packet(u_char *user_args, const struct pcap_pkthdr *cap_header, const u_char</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 10pt;text-align: left;">*packet) {</p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;line-height: 107%;text-align: left;">int tcp_header_length, total_header_size, pkt_data_len; u_char *pkt_data;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;text-align: left;">printf(&quot;==== Got a %d byte packet ====\n&quot;, cap_header-&gt;len);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;text-align: left;">decode_ethernet(packet); decode_ip(packet+ETHER_HDR_LEN);</p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;text-align: left;">tcp_header_length = decode_tcp(packet+ETHER_HDR_LEN+sizeof(struct ip_hdr));</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-top: 4pt;padding-left: 32pt;text-indent: 0pt;text-align: left;">total_header_size = ETHER_HDR_LEN+sizeof(struct ip_hdr)+tcp_header_length;</p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;line-height: 107%;text-align: left;">pkt_data = (u_char *)packet + total_header_size; // pkt_data points to the data portion. pkt_data_len = cap_header-&gt;len - total_header_size;</p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;text-align: left;">if(pkt_data_len &gt; 0) {</p><p class="s31" style="padding-left: 44pt;text-indent: 0pt;text-align: left;">printf(&quot;\t\t\t%u bytes of packet data\n&quot;, pkt_data_len); dump(pkt_data, pkt_data_len);</p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;text-align: left;">} else</p><p class="s31" style="padding-left: 44pt;text-indent: 0pt;text-align: left;">printf(&quot;\t\t\tNo Packet Data\n&quot;);</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">}</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-top: 4pt;padding-left: 32pt;text-indent: -12pt;line-height: 107%;text-align: left;">void pcap_fatal(const char *failed_in, const char *errbuf) { printf(&quot;Fatal Error in %s: %s\n&quot;, failed_in, errbuf); exit(1);</p><p class="s31" style="padding-bottom: 3pt;padding-left: 19pt;text-indent: 0pt;line-height: 10pt;text-align: left;">}</p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_720.png"/></span></p><p style="padding-top: 3pt;padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: justify;">The <span class="s31">caught_packet() </span>function gets called whenever <span class="s31">pcap_loop() </span>captures a packet. This function uses the header lengths to split the packet up by layers and the decoding functions to print out details of each layer’s header.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_721.png"/></span></p><p class="s31" style="padding-left: 32pt;text-indent: -12pt;line-height: 107%;text-align: left;">void decode_ethernet(const u_char *header_start) { int i;</p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;text-align: left;">const struct ether_hdr *ethernet_header;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;line-height: 107%;text-align: left;">ethernet_header = (const struct ether_hdr *)header_start; printf(&quot;[[ Layer 2 :: Ethernet Header ]]\n&quot;);</p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;line-height: 107%;text-align: left;">printf(&quot;[ Source: %02x&quot;, ethernet_header-&gt;ether_src_addr[0]); for(i=1; i &lt; ETHER_ADDR_LEN; i++)</p><p class="s31" style="padding-left: 44pt;text-indent: 0pt;line-height: 10pt;text-align: left;">printf(&quot;:%02x&quot;, ethernet_header-&gt;ether_src_addr[i]);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-top: 4pt;padding-left: 32pt;text-indent: 0pt;line-height: 107%;text-align: left;">printf(&quot;\tDest: %02x&quot;, ethernet_header-&gt;ether_dest_addr[0]); for(i=1; i &lt; ETHER_ADDR_LEN; i++)</p><p class="s31" style="padding-left: 32pt;text-indent: 12pt;line-height: 107%;text-align: left;">printf(&quot;:%02x&quot;, ethernet_header-&gt;ether_dest_addr[i]); printf(&quot;\tType: %hu ]\n&quot;, ethernet_header-&gt;ether_type);</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">}</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-top: 4pt;padding-left: 32pt;text-indent: -12pt;line-height: 107%;text-align: left;">void decode_ip(const u_char *header_start) { const struct ip_hdr *ip_header;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-top: 4pt;padding-left: 32pt;text-indent: 0pt;text-align: left;">ip_header = (const struct ip_hdr *)header_start; printf(&quot;\t(( Layer 3 ::: IP Header ))\n&quot;);</p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;line-height: 107%;text-align: left;">printf(&quot;\t( Source: %s\t&quot;, inet_ntoa(ip_header-&gt;ip_src_addr)); printf(&quot;Dest: %s )\n&quot;, inet_ntoa(ip_header-&gt;ip_dest_addr)); printf(&quot;\t( Type: %u\t&quot;, (u_int) ip_header-&gt;ip_type);</p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;line-height: 10pt;text-align: left;">printf(&quot;ID: %hu\tLength: %hu )\n&quot;, ntohs(ip_header-&gt;ip_id), ntohs(ip_header-&gt;ip_len));</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">}</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-top: 4pt;padding-left: 32pt;text-indent: -12pt;text-align: left;">u_int decode_tcp(const u_char *header_start) { u_int header_size;</p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;text-align: left;">const struct tcp_hdr *tcp_header;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;text-align: left;">tcp_header = (const struct tcp_hdr *)header_start; header_size = 4 * tcp_header-&gt;tcp_offset;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;text-align: left;">printf(&quot;\t\t{{ Layer 4 :::: TCP Header }}\n&quot;);</p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;line-height: 106%;text-align: left;">printf(&quot;\t\t{ Src Port: %hu\t&quot;, ntohs(tcp_header-&gt;tcp_src_port)); printf(&quot;Dest Port: %hu }\n&quot;, ntohs(tcp_header-&gt;tcp_dest_port)); printf(&quot;\t\t{ Seq #: %u\t&quot;, ntohl(tcp_header-&gt;tcp_seq)); printf(&quot;Ack #: %u }\n&quot;, ntohl(tcp_header-&gt;tcp_ack)); printf(&quot;\t\t{ Header Size: %u\tFlags: &quot;, header_size); if(tcp_header-&gt;tcp_flags &amp; TCP_FIN)</p><p class="s31" style="padding-left: 44pt;text-indent: 0pt;text-align: left;">printf(&quot;FIN &quot;);</p><p class="s31" style="padding-left: 44pt;text-indent: -12pt;line-height: 107%;text-align: left;">if(tcp_header-&gt;tcp_flags &amp; TCP_SYN) printf(&quot;SYN &quot;);</p><p class="s31" style="padding-left: 44pt;text-indent: -12pt;line-height: 107%;text-align: left;">if(tcp_header-&gt;tcp_flags &amp; TCP_RST) printf(&quot;RST &quot;);</p><p class="s31" style="padding-left: 44pt;text-indent: -12pt;line-height: 107%;text-align: left;">if(tcp_header-&gt;tcp_flags &amp; TCP_PUSH) printf(&quot;PUSH &quot;);</p><p class="s31" style="padding-left: 44pt;text-indent: -12pt;line-height: 107%;text-align: left;">if(tcp_header-&gt;tcp_flags &amp; TCP_ACK) printf(&quot;ACK &quot;);</p><p class="s31" style="padding-top: 2pt;padding-left: 44pt;text-indent: -12pt;text-align: left;">if(tcp_header-&gt;tcp_flags &amp; TCP_URG) printf(&quot;URG &quot;);</p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;text-align: left;">printf(&quot; }\n&quot;);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-top: 4pt;padding-left: 32pt;text-indent: 0pt;text-align: left;">return header_size;</p><p class="s31" style="padding-bottom: 3pt;padding-left: 19pt;text-indent: 0pt;text-align: left;">}</p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_722.png"/></span></p><p style="padding-top: 7pt;padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: left;">The decoding functions are passed a pointer to the start of the header, which is typecast to the appropriate structure. This allows accessing various fields of the header, but it’s important to remember these values will be in network byte order. This data is straight from the wire, so the byte order needs to be converted for use on an <span class="s27">x</span>86 processor.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_723.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">reader@hacking:~/booksrc $ gcc -o decode_sniff decode_sniff.c -lpcap reader@hacking:~/booksrc $ sudo ./decode_sniff</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">Sniffing on device eth0</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">==== Got a 75 byte packet ====</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">[[ Layer 2 :: Ethernet Header ]]</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">[ Source: 00:01:29:15:65:b6  Dest: 00:01:6c:eb:1d:50 Type: 8 ]</p><p class="s31" style="padding-left: 124pt;text-indent: 0pt;text-align: left;">(( Layer 3 ::: IP Header ))</p><p class="s31" style="padding-left: 124pt;text-indent: 0pt;text-align: left;">( Source: 192.168.42.1 Dest: 192.168.42.249 )</p><p class="s31" style="padding-left: 124pt;text-indent: 0pt;text-align: left;">( Type: 6   ID: 7755    Length: 61 )</p><p class="s31" style="padding-left: 156pt;text-indent: 0pt;text-align: left;">{{ Layer 4 :::: TCP Header }}</p><p class="s31" style="padding-left: 156pt;text-indent: 0pt;text-align: left;">{ Src Port: 35602   Dest Port: 7890 }</p><p class="s31" style="padding-left: 156pt;text-indent: 0pt;text-align: left;">{ Seq #: 2887045274  Ack #: 3843058889 }</p><p class="s31" style="padding-left: 189pt;text-indent: -32pt;text-align: left;">{ Header Size: 32   Flags: PUSH ACK } 9 bytes of packet data</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">74 65 73 74 69 6e 67 0d 0a           | testing..</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">==== Got a 66 byte packet ====</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">[[ Layer 2 :: Ethernet Header ]]</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">[ Source: 00:01:6c:eb:1d:50  Dest: 00:01:29:15:65:b6 Type: 8 ]</p><p class="s31" style="padding-left: 124pt;text-indent: 0pt;text-align: left;">(( Layer 3 ::: IP Header ))</p><p class="s31" style="padding-left: 124pt;text-indent: 0pt;text-align: left;">( Source: 192.168.42.249   Dest: 192.168.42.1 )</p><p class="s31" style="padding-left: 124pt;text-indent: 0pt;text-align: left;">( Type: 6   ID: 15678   Length: 52 )</p><p class="s31" style="padding-left: 156pt;text-indent: 0pt;text-align: left;">{{ Layer 4 :::: TCP Header }}</p><p class="s31" style="padding-left: 156pt;text-indent: 0pt;text-align: left;">{ Src Port: 7890    Dest Port: 35602 }</p><p class="s31" style="padding-left: 156pt;text-indent: 0pt;text-align: left;">{ Seq #: 3843058889  Ack #: 2887045283 }</p><p class="s31" style="padding-left: 189pt;text-indent: -32pt;text-align: left;">{ Header Size: 32   Flags: ACK } No Packet Data</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">==== Got a 82 byte packet ====</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">[[ Layer 2 :: Ethernet Header ]]</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">[ Source: 00:01:29:15:65:b6  Dest: 00:01:6c:eb:1d:50 Type: 8 ]</p><p class="s31" style="padding-left: 124pt;text-indent: 0pt;text-align: left;">(( Layer 3 ::: IP Header ))</p><p class="s31" style="padding-left: 124pt;text-indent: 0pt;text-align: left;">( Source: 192.168.42.1 Dest: 192.168.42.249 )</p><p class="s31" style="padding-left: 124pt;text-indent: 0pt;text-align: left;">( Type: 6   ID: 7756    Length: 68 )</p><p class="s31" style="padding-left: 156pt;text-indent: 0pt;text-align: left;">{{ Layer 4 :::: TCP Header }}</p><p class="s31" style="padding-left: 156pt;text-indent: 0pt;text-align: left;">{ Src Port: 35602   Dest Port: 7890 }</p><p class="s31" style="padding-left: 156pt;text-indent: 0pt;text-align: left;">{ Seq #: 2887045283  Ack #: 3843058889 }</p><p class="s31" style="padding-left: 189pt;text-indent: -32pt;line-height: 107%;text-align: left;">{ Header Size: 32   Flags: PUSH ACK } 16 bytes of packet data</p><p class="s31" style="padding-bottom: 2pt;padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">74 68 69 73 20 69 73 20 61 20 74 65 73 74 0d 0a | this is a test.. reader@hacking:~/booksrc $</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_724.png"/></span></p><p style="padding-top: 3pt;padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: left;">With the headers decoded and separated into layers, the TCP/IP connec- tion is much easier to understand. Notice which IP addresses are associated with which MAC address. Also, notice how the sequence number in the two packets from 192.168.42.1 (the first and last packet) increases by nine, since the first packet contained nine bytes of actual data: 2887045283 – 2887045274 = 9. This is used by the TCP protocol to make sure all of the data arrives in order, since packets could be delayed for various reasons.</p><p style="padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: left;">Despite all of the mechanisms built into the packet headers, the packets are still visible to anyone on the same network segment. Protocols such as FTP, POP3, and telnet transmit data without encryption. Even without the assistance of a tool like dsniff, it’s fairly trivial for an attacker sniffing the network to find the usernames and passwords in these packets and use them to compromise other systems. From a security perspective, this isn’t too good, so more intelligent switches provide switched network environments.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part89.htm">&lt; Previous</a><span> | </span><a href="../hacking-the-art-of-exploitation.html">Contents</a><span> | </span><a href="part91.htm">Next &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
