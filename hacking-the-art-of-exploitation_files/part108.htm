<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>0x480 Reach Out and Hack Someone</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part107.htm">&lt; Previous</a><span> | </span><a href="../hacking-the-art-of-exploitation.html">Contents</a><span> | </span><a href="part109.htm">Next &gt;</a></p><p class="s30" style="padding-left: 37pt;text-indent: 0pt;text-align: left;"><a name="bookmark97">0x480 Reach Out and Hack Someone</a></p><p style="padding-top: 8pt;padding-left: 91pt;text-indent: 0pt;line-height: 108%;text-align: left;">Network programming tends to move many chunks of memory around and is heavy in typecasting. You’ve seen for yourself how crazy some of the typecasts can get. Mistakes thrive in this type of chaos. And since many network pro- grams need to run as root, these little mistakes can become critical vulner- abilities. One such vulnerability exists in the code from this chapter. Did you notice it?</p><p class="s40" style="padding-top: 9pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">From hacking-network.h</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_809.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">/* This function accepts a socket FD and a ptr to a destination</p><p class="s31" style="padding-left: 95pt;text-indent: 0pt;text-align: left;">* buffer. It will receive from the socket until the EOL byte</p><p class="s31" style="padding-left: 95pt;text-indent: 0pt;text-align: left;">* sequence in seen. The EOL bytes are read from the socket, but</p><p class="s31" style="padding-left: 95pt;text-indent: 0pt;text-align: left;">* the destination buffer is terminated before these bytes.</p><p class="s31" style="padding-left: 95pt;text-indent: 0pt;text-align: left;">* Returns the size of the read line (without EOL bytes).</p><p class="s31" style="padding-left: 95pt;text-indent: 0pt;text-align: left;">*/</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 106%;text-align: left;">int recv_line(int sockfd, unsigned char *dest_buffer) { #define EOL &quot;\r\n&quot; // End-of-line byte sequence #define EOL_SIZE 2</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;line-height: 107%;text-align: left;">unsigned char *ptr; int eol_matched = 0;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;text-align: left;">ptr = dest_buffer;</p><p class="s31" style="padding-top: 2pt;padding-left: 104pt;text-indent: 0pt;text-align: left;">while(recv(sockfd, ptr, 1, 0) == 1) { // Read a single byte.</p><p class="s31" style="padding-left: 129pt;text-indent: -12pt;line-height: 107%;text-align: left;">if(*ptr == EOL[eol_matched]) { // Does this byte match terminator? eol_matched++;</p><p class="s31" style="padding-left: 129pt;text-indent: 0pt;text-align: left;">if(eol_matched == EOL_SIZE) { // If all bytes match terminator,</p><p class="s31" style="padding-left: 142pt;text-indent: 0pt;text-align: left;">*(ptr+1-EOL_SIZE) = &#39;\0&#39;; // terminate the string. return strlen(dest_buffer); // Return bytes recevied.</p><p class="s31" style="text-indent: 0pt;text-align: center;">}</p><p class="s31" style="padding-left: 27pt;text-indent: 0pt;text-align: center;">} else {</p><p class="s31" style="padding-left: 86pt;text-indent: 0pt;text-align: center;">eol_matched = 0;</p><p class="s31" style="padding-left: 116pt;text-indent: 0pt;text-align: left;">}</p><p class="s31" style="padding-left: 116pt;text-indent: 0pt;text-align: left;">ptr++; // Increment the pointer to the next byte.</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;text-align: left;">}</p><p class="s31" style="padding-left: 104pt;text-indent: 0pt;text-align: left;">return 0; // Didn&#39;t find the end-of-line characters.</p><p class="s31" style="padding-bottom: 3pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">}</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_810.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 91pt;text-indent: 18pt;line-height: 108%;text-align: left;">The <span class="s31">recv_line() </span>function in hacking-network.h has a small mistake of omission—there is no code to limit the length. This means received bytes can overflow if they exceed the <span class="s31">dest_buffer </span>size. The tinyweb server program and any other programs that use this function are vulnerable to attack.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part107.htm">&lt; Previous</a><span> | </span><a href="../hacking-the-art-of-exploitation.html">Contents</a><span> | </span><a href="part109.htm">Next &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
