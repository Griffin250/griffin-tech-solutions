<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>0x427 A Tinyweb Server</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part81.htm">&lt; Previous</a><span> | </span><a href="../hacking-the-art-of-exploitation.html">Contents</a><span> | </span><a href="part83.htm">Next &gt;</a></p><p class="s32" style="padding-left: 91pt;text-indent: 0pt;text-align: left;"><a name="bookmark71">0x427 A Tinyweb Server</a></p><p style="padding-top: 7pt;padding-left: 91pt;text-indent: 0pt;line-height: 108%;text-align: left;">A webserver doesn’t have to be much more complex than the simple server we created in the previous section. After accepting a TCP-IP connection, the webserver needs to implement further layers of communication using the HTTP protocol.</p><p style="padding-left: 91pt;text-indent: 17pt;line-height: 107%;text-align: left;">The server code listed below is nearly identical to the simple server, except that connection handling code is separated into its own function. This func- tion handles HTTP <span class="s31">GET </span>and <span class="s31">HEAD </span>requests that would come from a web browser. The program will look for the requested resource in the local directory called webroot and send it to the browser. If the file can’t be found, the server will respond with a 404 HTTP response. You may already be familiar with this response, which means <span class="s27">File Not Found</span>. The complete source code listing follows.</p><p class="s40" style="padding-top: 4pt;padding-left: 19pt;text-indent: 0pt;text-align: left;"><a name="bookmark101">tinyweb.c</a></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_658.png"/></span></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 106%;text-align: left;">#include &lt;stdio.h&gt; #include &lt;fcntl.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;sys/stat.h&gt; #include &lt;sys/socket.h&gt; #include &lt;netinet/in.h&gt; #include &lt;arpa/inet.h&gt; #include &quot;hacking.h&quot;</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">#include &quot;hacking-network.h&quot;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">#define PORT 80  // The port users will be connecting to #define WEBROOT &quot;./webroot&quot; // The webserver&#39;s root directory</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;line-height: 107%;text-align: left;">void handle_connection(int, struct sockaddr_in *); // Handle web requests int get_file_size(int); // Returns the filesize of open file descriptor</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">int main(void) {</p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;text-align: left;">int sockfd, new_sockfd, yes=1;</p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;line-height: 107%;text-align: left;">struct sockaddr_in host_addr, client_addr;  // My address information socklen_t sin_size;</p><p class="s31" style="padding-top: 1pt;padding-left: 32pt;text-indent: 0pt;line-height: 21pt;text-align: left;">printf(&quot;Accepting web requests on port %d\n&quot;, PORT); if ((sockfd = socket(PF_INET, SOCK_STREAM, 0)) == -1)</p><p class="s31" style="padding-left: 44pt;text-indent: 0pt;line-height: 8pt;text-align: left;">fatal(&quot;in socket&quot;);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 44pt;text-indent: -12pt;line-height: 107%;text-align: left;">if (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &amp;yes, sizeof(int)) == -1) fatal(&quot;setting socket option SO_REUSEADDR&quot;);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;line-height: 107%;text-align: left;">host_addr.sin_family = AF_INET;   // Host byte order host_addr.sin_port = htons(PORT);  // Short, network byte order host_addr.sin_addr.s_addr = INADDR_ANY; // Automatically fill with my IP. memset(&amp;(host_addr.sin_zero), &#39;\0&#39;, 8); // Zero the rest of the struct.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 44pt;text-indent: -12pt;line-height: 107%;text-align: left;">if (bind(sockfd, (struct sockaddr *)&amp;host_addr, sizeof(struct sockaddr)) == -1) fatal(&quot;binding to socket&quot;);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 44pt;text-indent: -12pt;line-height: 107%;text-align: left;">if (listen(sockfd, 20) == -1) fatal(&quot;listening on socket&quot;);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;text-align: left;">while(1) {  // Accept loop.</p><p class="s31" style="padding-left: 44pt;text-indent: 0pt;text-align: left;">sin_size = sizeof(struct sockaddr_in);</p><p class="s31" style="padding-left: 44pt;text-indent: 0pt;line-height: 107%;text-align: left;">new_sockfd = accept(sockfd, (struct sockaddr *)&amp;client_addr, &amp;sin_size); if(new_sockfd == -1)</p><p class="s31" style="padding-left: 57pt;text-indent: 0pt;text-align: left;">fatal(&quot;accepting connection&quot;);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-top: 4pt;padding-left: 44pt;text-indent: 0pt;text-align: left;">handle_connection(new_sockfd, &amp;client_addr);</p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;text-align: left;">}</p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;text-align: left;">return 0;</p><p class="s31" style="padding-top: 2pt;padding-left: 19pt;text-indent: 0pt;text-align: left;">}</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">/* This function handles the connection on the passed socket from the</p><p class="s31" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">* passed client address. The connection is processed as a web request,</p><p class="s31" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">* and this function replies over the connected socket. Finally, the</p><p class="s31" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">* passed socket is closed at the end of the function.</p><p class="s31" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">*/</p><p class="s31" style="padding-left: 32pt;text-indent: -12pt;line-height: 107%;text-align: left;">void handle_connection(int sockfd, struct sockaddr_in *client_addr_ptr) { unsigned char *ptr, request[500], resource[500];</p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;line-height: 10pt;text-align: left;">int fd, length;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;text-align: left;">length = recv_line(sockfd, request);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 19pt;text-indent: 12pt;text-align: left;">printf(&quot;Got request from %s:%d \&quot;%s\&quot;\n&quot;, inet_ntoa(client_addr_ptr-&gt;sin_addr), ntohs(client_addr_ptr-&gt;sin_port), request);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;line-height: 107%;text-align: left;">ptr = strstr(request, &quot; HTTP/&quot;); // Search for valid-looking request. if(ptr == NULL) { // Then this isn&#39;t valid HTTP.</p><p class="s31" style="padding-left: 44pt;text-indent: 0pt;text-align: left;">printf(&quot; NOT HTTP!\n&quot;);</p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;text-align: left;">} else {</p><p class="s31" style="padding-left: 44pt;text-indent: 0pt;text-align: left;">*ptr = 0; // Terminate the buffer at the end of the URL.</p><p class="s31" style="padding-left: 44pt;text-indent: 0pt;line-height: 107%;text-align: left;">ptr = NULL; // Set ptr to NULL (used to flag for an invalid request). if(strncmp(request, &quot;GET &quot;, 4) == 0) // GET request</p><p class="s31" style="padding-left: 44pt;text-indent: 12pt;text-align: left;">ptr = request+4; // ptr is the URL. if(strncmp(request, &quot;HEAD &quot;, 5) == 0) // HEAD request</p><p class="s31" style="padding-left: 57pt;text-indent: 0pt;text-align: left;">ptr = request+5; // ptr is the URL.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 57pt;text-indent: -12pt;text-align: left;">if(ptr == NULL) { // Then this is not a recognized request. printf(&quot;\tUNKNOWN REQUEST!\n&quot;);</p><p class="s31" style="padding-left: 18pt;text-indent: 0pt;text-align: center;">} else { // Valid request, with ptr pointing to the resource name</p><p class="s31" style="padding-left: 59pt;text-indent: 0pt;line-height: 106%;text-align: center;">if (ptr[strlen(ptr) - 1] == &#39;/&#39;) // For resources ending with &#39;/&#39;, strcat(ptr, &quot;index.html&quot;);   // add &#39;index.html&#39; to the end. strcpy(resource, WEBROOT);   // Begin resource with web root path strcat(resource, ptr);     // and join it with resource path.</p><p class="s31" style="padding-left: 57pt;text-indent: 0pt;line-height: 107%;text-align: left;">fd = open(resource, O_RDONLY, 0); // Try to open the file. printf(&quot;\tOpening \&#39;%s\&#39;\t&quot;, resource);</p><p class="s31" style="padding-left: 70pt;text-indent: -12pt;line-height: 107%;text-align: left;">if(fd == -1) { // If file is not found printf(&quot; 404 Not Found\n&quot;);</p><p class="s31" style="padding-left: 70pt;text-indent: 0pt;line-height: 107%;text-align: left;">send_string(sockfd, &quot;HTTP/1.0 404 NOT FOUND\r\n&quot;); send_string(sockfd, &quot;Server: Tiny webserver\r\n\r\n&quot;);</p><p class="s31" style="padding-left: 70pt;text-indent: 0pt;line-height: 107%;text-align: left;">send_string(sockfd, &quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;404 Not Found&lt;/title&gt;&lt;/head&gt;&quot;); send_string(sockfd, &quot;&lt;body&gt;&lt;h1&gt;URL not found&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;\r\n&quot;);</p><p class="s31" style="padding-left: 70pt;text-indent: -12pt;line-height: 107%;text-align: left;">} else {   // Otherwise, serve up the file. printf(&quot; 200 OK\n&quot;);</p><p class="s31" style="padding-left: 70pt;text-indent: 0pt;line-height: 107%;text-align: left;">send_string(sockfd, &quot;HTTP/1.0 200 OK\r\n&quot;); send_string(sockfd, &quot;Server: Tiny webserver\r\n\r\n&quot;); if(ptr == request + 4) { // Then this is a GET request</p><p class="s31" style="padding-left: 95pt;text-indent: -12pt;text-align: left;">if( (length = get_file_size(fd)) == -1) fatal(&quot;getting resource file size&quot;);</p><p class="s31" style="padding-left: 83pt;text-indent: 0pt;line-height: 106%;text-align: center;">if( (ptr = (unsigned char *) malloc(length)) == NULL) fatal(&quot;allocating memory for reading resource&quot;); read(fd, ptr, length); // Read the file into memory. send(sockfd, ptr, length, 0);  // Send it to socket.</p><p class="s31" style="padding-top: 2pt;padding-left: 83pt;text-indent: 0pt;text-align: left;">free(ptr); // Free file memory.</p><p class="s31" style="padding-left: 70pt;text-indent: 0pt;text-align: left;">}</p><p class="s31" style="padding-left: 70pt;text-indent: 0pt;text-align: left;">close(fd); // Close the file.</p><p class="s31" style="padding-left: 57pt;text-indent: 0pt;text-align: left;">} // End if block for file found/not found.</p><p class="s31" style="padding-left: 44pt;text-indent: 0pt;text-align: left;">} // End if block for valid request.</p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;text-align: left;">} // End if block for valid HTTP.</p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;text-align: left;">shutdown(sockfd, SHUT_RDWR); // Close the socket gracefully.</p><p class="s31" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">}</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-top: 4pt;padding-left: 19pt;text-indent: 0pt;text-align: left;">/* This function accepts an open file descriptor and returns</p><p class="s31" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">* the size of the associated file. Returns -1 on failure.</p><p class="s31" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">*/</p><p class="s31" style="padding-left: 32pt;text-indent: -12pt;text-align: left;">int get_file_size(int fd) { struct stat stat_struct;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-top: 4pt;padding-left: 44pt;text-indent: -12pt;line-height: 107%;text-align: left;">if(fstat(fd, &amp;stat_struct) == -1) return -1;</p><p class="s31" style="padding-left: 32pt;text-indent: 0pt;line-height: 10pt;text-align: left;">return (int) stat_struct.st_size;</p><p class="s31" style="padding-bottom: 3pt;padding-left: 19pt;text-indent: 0pt;text-align: left;">}</p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="540" height="1" alt="image" src="Image_659.png"/></span></p><p style="padding-top: 8pt;padding-left: 91pt;text-indent: 18pt;line-height: 108%;text-align: left;">The <span class="s31">handle_connection </span>function uses the <span class="s31">strstr() </span>function to look for the substring <span class="s31">HTTP/ </span>in the request buffer. The <span class="s31">strstr() </span>function returns a pointer to the substring, which will be right at the end of the request. The string is terminated here, and the requests <span class="s31">HEAD </span>and <span class="s31">GET </span>are recognized as processable requests. A <span class="s31">HEAD </span>request will just return the headers, while a <span class="s31">GET </span>request will also return the requested resource (if it can be found).</p><p style="padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: left;"><a href="http://127.0.0.1/" class="a" target="_blank">The files index.html and image.jpg have been put into the directory webroot, as shown in the output below, and then the tinyweb program is compiled. Root privileges are needed to bind to any port below 1024, so the program is setuid root and executed. The server’s debugging output shows the results of a web browser’s request of </a><a href="http://127.0.0.1/" target="_blank">http://127.0.0.1:</a></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_660.png"/></span></p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 107%;text-align: left;">reader@hacking:~/booksrc $ ls -l webroot/ total 52</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">-rwxr--r-- 1 reader reader 46794 2007-05-28 23:43 image.jpg</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">-rw-r--r-- 1 reader reader  261 2007-05-28 23:42 index.html reader@hacking:~/booksrc $ cat webroot/index.html</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">&lt;html&gt;</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">&lt;head&gt;&lt;title&gt;A sample webpage&lt;/title&gt;&lt;/head&gt;</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">&lt;body bgcolor=&quot;#000000&quot; text=&quot;#ffffffff&quot;&gt;</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">&lt;center&gt;</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">&lt;h1&gt;This is a sample webpage&lt;/h1&gt;</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">...and here is some sample text&lt;br&gt;</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">&lt;br&gt;</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">..and even a sample image:&lt;br&gt;</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">&lt;img src=&quot;image.jpg&quot;&gt;&lt;br&gt;</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">&lt;/center&gt;</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">&lt;/body&gt;</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">&lt;/html&gt;</p><p class="s31" style="padding-left: 91pt;text-indent: 0pt;line-height: 106%;text-align: left;">reader@hacking:~/booksrc $ gcc -o tinyweb tinyweb.c reader@hacking:~/booksrc $ sudo chown root ./tinyweb reader@hacking:~/booksrc $ sudo chmod u+s ./tinyweb reader@hacking:~/booksrc $ ./tinyweb</p><p class="s31" style="padding-top: 2pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">Accepting web requests on port 80</p><p class="s31" style="padding-left: 125pt;text-indent: -34pt;line-height: 107%;text-align: left;">Got request from 127.0.0.1:52996 &quot;GET / HTTP/1.1&quot; Opening &#39;./webroot/index.html&#39;  200 OK</p><p class="s31" style="padding-left: 125pt;text-indent: -34pt;line-height: 107%;text-align: left;">Got request from 127.0.0.1:52997 &quot;GET /image.jpg HTTP/1.1&quot; Opening &#39;./webroot/image.jpg&#39;  200 OK</p><p class="s31" style="padding-bottom: 2pt;padding-left: 125pt;text-indent: -34pt;line-height: 107%;text-align: left;">Got request from 127.0.0.1:52998 &quot;GET /favicon.ico HTTP/1.1&quot; Opening &#39;./webroot/favicon.ico&#39;  404 Not Found</p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="444" height="1" alt="image" src="Image_661.png"/></span></p><p style="padding-top: 8pt;padding-left: 91pt;text-indent: 17pt;line-height: 108%;text-align: left;">The address 127.0.0.1 is a special loopback address that routes to the local machine. The initial request gets index.html from the webserver, which in turn requests image.jpg. In addition, the browser automatically requests favicon.ico in an attempt to retrieve an icon for the web page. The screen- shot below shows the results of this request in a browser.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 92pt;text-indent: 0pt;text-align: left;"><span><img width="436" height="357" alt="image" src="Image_662.gif"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="toc">&nbsp;</p><div class="toc"><a class="toc0" href="part83.htm">0x430 Peeling Back the Lower Layers</a></div><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part81.htm">&lt; Previous</a><span> | </span><a href="../hacking-the-art-of-exploitation.html">Contents</a><span> | </span><a href="part83.htm">Next &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
